# JAVASCRIPT:

JavaScript was initially created to “make web pages alive”.
The programs in this language are called scripts. They can be written right in a web page’s HTML and run automatically as the page loads.
Today, JavaScript can execute not only in the browser, but also on the server, or actually on any device that has a special program called the JavaScript engine.
The browser has an embedded engine sometimes called a “JavaScript virtual machine”.

Scripts are provided and executed as plain text. They don’t need special preparation or compilation to ru
JavaScript is an object-based scripting language which is lightweight and cross-platform.
JavaScript is not a compiled language, but it is a translated language. 
The JavaScript Translator (embedded in the browser) is responsible for translating the JavaScript code for the web browser.

JavaScript (js) is a light-weight object-oriented programming language which is used by several websites for scripting the webpages. 
It is an interpreted, full-fledged programming language that enables dynamic interactivity on websites when applied to an HTML document.

# There are following features of JavaScript:
All popular web browsers support JavaScript as they provide built-in execution environments.
JavaScript follows the syntax and structure of the C programming language. Thus, it is a structured programming language.
JavaScript is a weakly typed language, where certain types are implicitly cast (depending on the operation).
JavaScript is an object-oriented programming language that uses prototypes rather than using classes for inheritance.
It is a light-weighted and interpreted language.
It is a case-sensitive language.
JavaScript is supportable in several operating systems including, Windows, macOS, etc.
It provides good control to the users over the web browsers.

# JavaScript’s capabilities greatly depend on the environment it’s running in. For instance, Node.js supports functions that allow JavaScript to read/write arbitrary files, perform network requests, etc.
In-browser JavaScript can do everything related to webpage manipulation, interaction with the user, and the webserver.

For instance, in-browser JavaScript is able to:
Add new HTML to the page, change the existing content, modify styles.
React to user actions, run on mouse clicks, pointer movements, key presses.
Send requests over the network to remote servers, download and upload files (so-called AJAX and COMET technologies).
Get and set cookies, ask questions to the visitor, show messages.
Remember the data on the client-side (“local storage”).

# What CAN’T in-browser JavaScript do?
JavaScript on a webpage may not read/write arbitrary files on the hard disk, copy them or execute programs. It has no direct access to OS functions.
Different tabs/windows generally do not know about each other. Sometimes they do, for example when one window uses JavaScript to open the other one. 
But even in this case, JavaScript from one page may not access the other if they come from different sites (from a different domain, protocol or port).
This is called the “Same Origin Policy”. To work around that, both pages must agree for data exchange and contain a special JavaScript code that handles it.
Such limits do not exist if JavaScript is used outside of the browser, for example on a server. Modern browsers also allow plugin/extensions which may ask for extended permissions.

# What makes JavaScript unique?
There are at least three great things about JavaScript:

Full integration with HTML/CSS.
Simple things are done simply.
Supported by all major browsers and enabled by default.

JavaScript is the only browser technology that combines these three things.
JavaScript provides 3 places to put the JavaScript code: within body tag, within head tag and external JavaScript file.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Code editors:

A source-code editor is a text editor program designed specifically for editing source code of computer programs. 
It may be a standalone application or it may be built into an integrated development environment (IDE) or web browser
A code editor is the place where programmers spend most of their time.

There are two main types of code editors: 
IDEs and 
lightweight editors. 
Many people use one tool of each type.

# IDE:
An integrated development environment (IDE) is a software suite that consolidates basic tools required to write and test software.
An IDE typically contains a code editor, a compiler or interpreter, and a debugger, accessed through a single graphical user interface (GUI). 
The user writes and edits source code in the code editor. The compiler translates the source code into a readable language that is executable for a computer. And the debugger tests the software to solve any issues or bugs.
The term IDE (Integrated Development Environment) refers to a powerful editor with many features that usually operates on a “whole project.” 
As the name suggests, it’s not just an editor, but a full-scale “development environment.”

An IDE loads the project (which can be many files), allows navigation between files, provides autocompletion based on the whole project (not just the open file), and integrates with a version management system (like git), a testing environment, and other “project-level” stuff.

If you haven’t selected an IDE yet, consider the following options:
Visual Studio Code (cross-platform, free).
WebStorm (cross-platform, paid).
Netbeans

# Lightweight editors:
“Lightweight editors” are not as powerful as IDEs, but they’re fast, elegant and simple.
They are mainly used to open and edit a file instantly.
The main difference between a “lightweight editor” and an “IDE” is that an IDE works on a project-level, so it loads much more data on start, analyzes the project structure if needed and so on. A lightweight editor is much faster if we need only one file.
In practice, lightweight editors may have a lot of plugins including directory-level syntax analyzers and autocompleters, so there’s no strict border between a lightweight editor and an IDE.

The following options deserve your attention:
Sublime Text (cross-platform, shareware).
Notepad++ (Windows, free).
Vim and Emacs are also cool if you know how to use them.
Pycharm
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# The “script” tag:
JavaScript programs can be inserted almost anywhere into an HTML document using the <script> tag.
The <script> tag contains JavaScript code which is automatically executed when the browser processes the tag.

The <script> tag has a few attributes that are rarely used nowadays but can still be found in old code:
-The type attribute: <script type=…>
The old HTML standard, HTML4, required a script to have a type. Usually it was type="text/javascript". It’s not required anymore.

-The language attribute: <script language=…>
This attribute was meant to show the language of the script. This attribute no longer makes sense because JavaScript is the default language. There is no need to use it.

# External scripts
If we have a lot of JavaScript code, we can put it into a separate file.

Script files are attached to HTML with the src attribute:
<script src="/path/to/script.js"></script>
Here, /path/to/script.js is an absolute path to the script from the site root. One can also provide a relative path from the current page. 
For instance, src="script.js", just like src="./script.js", would mean a file "script.js" in the current folder.

Note: If src is set, the script content is ignored.
A single <script> tag can’t have both the src attribute and code inside.
We must choose either an external <script src="…"> or a regular <script> with code.

The example above can be split into two scripts to work:

<script src="file.js"></script>
<script>
  alert(1);
</script>

We can use a <script> tag to add JavaScript code to a page.
The type and language attributes are not required.
A script in an external file can be inserted with <script src="path/to/script.js"></script>.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Code structure:
The first thing we’ll study is the building blocks of code.

# Statements
Statements are syntax constructs and commands that perform actions.
We’ve already seen a statement, alert('Hello, world!'), which shows the message “Hello, world!”.
We can have as many statements in our code as we want. Statements can be separated with a semicolon.

Usually, statements are written on separate lines to make the code more readable:
alert('Hello');
alert('World');

# Semicolons
A semicolon may be omitted in most cases when a line break exists.

This would also work:
alert('Hello')
alert('World')

Here, JavaScript interprets the line break as an “implicit” semicolon. This is called an automatic semicolon insertion.

In most cases, a newline implies a semicolon. But “in most cases” does not mean “always”!

There are cases when a newline does not mean a semicolon. For example:

alert(3 +
1
+ 2);
The code outputs 6 because JavaScript does not insert semicolons here.

# But there are situations where JavaScript “fails” to assume a semicolon where it is really needed.
alert("Hello");
[1, 2].forEach(alert);
No need to think about the meaning of the brackets [] and forEach yet. We’ll study them later. For now, just remember the result of running the code: it shows Hello, then 1, then 2.

Now let’s remove the semicolon after the alert:
alert("Hello")
[1, 2].forEach(alert);
The difference compared to the code above is only one character: the semicolon at the end of the first line is gone.
If we run this code, only the first Hello shows (and there’s an error, you may need to open the console to see it). There are no numbers any more.
That’s because JavaScript does not assume a semicolon before square brackets [...]. So, the code in the last example is treated as a single statement.

Here’s how the engine sees it:
alert("Hello")[1, 2].forEach(alert);

# Comments:
Comments can be put into any place of a script. They don’t affect its execution because the engine simply ignores them.

-One-line comments start with two forward slash characters //.
The rest of the line is a comment. It may occupy a full line of its own or follow a statement.

-Multiline comments start with a forward slash and an asterisk /* and end with an asterisk and a forward slash */.
Like this:
/* An example with two messages.
This is a multiline comment.
*/
alert('Hello');
alert('World');

Note: The content of comments is ignored, so if we put code inside /* … */, it won’t execute.

Note: Nested comments are not supported!
There may not be /*...*/ inside another /*...*/.

Such code will die with an error:

/*
  /* nested comment ?!? */
*/
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# "use strict":
The purpose of "use strict" is to indicate that the code should be executed in "strict mode".
With strict mode, you can not, for example, use undeclared variables.

You can use strict mode in all your programs. It helps you to write cleaner code, like preventing you from using undeclared variables.
"use strict" is just a string, so IE 9 will not throw an error even if it does not understand it.

# Declaring Strict Mode
Strict mode is declared by adding "use strict"; to the beginning of a script or a function.
Declared at the beginning of a script, it has global scope (all code in the script will execute in strict mode):

Ex- "use strict";
x = 3.14;       // This will cause an error because x is not declared

Declared inside a function, it has local scope (only the code inside the function is in strict mode):
x = 3.14;       // This will not cause an error.
myFunction();

function myFunction() {
  "use strict";
  y = 3.14;   // This will cause an error
}

# Why Strict Mode?
Strict mode makes it easier to write "secure" JavaScript.
Strict mode changes previously accepted "bad syntax" into real errors.
As an example, in normal JavaScript, mistyping a variable name creates a new global variable. In strict mode, this will throw an error, making it impossible to accidentally create a global variable.
In normal JavaScript, a developer will not receive any error feedback assigning values to non-writable properties.
In strict mode, any assignment to a non-writable property, a getter-only property, a non-existing property, a non-existing variable, or a non-existing object, will throw an error.

# Things not Allowed in Strict Mode:
1.Using a variable, without declaring it, is not allowed:
"use strict";
x = 3.14;                // This will cause an error

2.Objects are variables too.
Using an object, without declaring it, is not allowed:

"use strict";
x = {p1:10, p2:20};      // This will cause an error

3.Deleting a variable (or object) is not allowed.

"use strict";
let x = 3.14;
delete x;                // This will cause an error

4.Deleting a function is not allowed.

"use strict";
function x(p1, p2) {};
delete x;                // This will cause an error 

5.Duplicating a parameter name is not allowed:

"use strict";
function x(p1, p1) {};   // This will cause an error

6.Octal numeric literals are not allowed:

"use strict";
let x = 010;             // This will cause an error

7.Octal escape characters are not allowed:

"use strict";
let x = "\010";            // This will cause an error

8.Writing to a read-only property is not allowed:
The readOnly property sets or returns whether a text field is read-only, or not
"use strict";
const obj = {};
Object.defineProperty(obj, "x", {value:0, writable:false});

obj.x = 3.14;            // This will cause an error

Note: Ensure that “use strict” is at the top
Please make sure that "use strict" is at the top of your scripts, otherwise strict mode may not be enabled.
There’s no way to cancel use strict

There is no directive like "no use strict" that reverts the engine to old behavior.
Once we enter strict mode, there’s no going back.

Modern JavaScript supports “classes” and “modules.So we don’t need to add the "use strict" directive, if we use them.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Variables:
Variables are used to store this information.
A variable is a “named storage” for data. We can use variables to store goodies, visitors, and other data.
To create a variable in JavaScript, use the let keyword.

# 4 Ways to Declare a JavaScript Variable:
Using var
Using let
Using const
Using nothing

The statement below creates (in other words: declares) a variable with the name “message”:
let message;

Now, we can put some data into it by using the assignment operator =:
let message;
message = 'Hello'; // store the string 'Hello' in the variable named message

We can also declare multiple variables in one line:
let user = 'John', age = 25, message = 'Hello';

Some people also define multiple variables in this multiline style:
let user = 'John',
  age = 25,
  message = 'Hello';

Or even in the “comma-first” style:
let user = 'John'
  , age = 25
  , message = 'Hello';
  
When the value is changed, the old data is removed from the variable:
let message;
message = 'Hello!';
message = 'World!'; // value changed
alert(message);

We can also declare two variables and copy data from one into the other.

Note: Declaring twice triggers an error
A variable should be declared only once.
A repeated declaration of the same variable is an error

# Variable naming
There are two limitations on variable names in JavaScript:
-The name must contain only letters, digits, or the symbols $ and _.
-The first character must not be a digit.

Examples of valid names:
let userName;
let test123;

Note: the dollar sign '$' and the underscore '_' can also be used in names. They are regular symbols, just like letters, without any special meaning.
let $ = 1; // declared a variable with the name "$"
let _ = 2; // and now a variable with the name "_"
alert($ + _); // 3

# Examples of incorrect variable names:
let 1a; // cannot start with a digit
let my-name; // hyphens '-' aren't allowed in the name

# Case matters
Variables named apple and APPLE are two different variables.

# Non-Latin letters are allowed, but not recommended
It is possible to use any language, including cyrillic letters or even hieroglyphs, like this:
let имя = '...';
let 我 = '...';

# Reserved names
There is a list of reserved words, which cannot be used as variable names because they are used by the language itself.
For example: let, class, return, and function are reserved.

The code below gives a syntax error:
let let = 5; // can't name a variable "let", error!
let return = 5; // also can't name it "return", error!

# An assignment without use strict.
// note: no "use strict" in this example
num = 5; // the variable "num" is created if it didn't exist
alert(num); // 5

This is a bad practice and would cause an error in strict mode:
"use strict";
num = 5; // error: num is not defined

# Constants
To declare a constant (unchanging) variable, use const instead of let:
const myBirthday = '18.04.1982';

Variables declared using const are called “constants”. They cannot be reassigned. An attempt to do so would cause an error:
const myBirthday = '18.04.1982';
myBirthday = '01.01.2001'; // error, can't reassign the constant!

When a programmer is sure that a variable will never change, they can declare it with const to guarantee and clearly communicate that fact to everyone.

Use const when you declare:
A new Array
A new Object
A new Function
A new RegExp

const – is like let, but the value of the variable can’t be changed.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Data types
A value in JavaScript is always of a certain type. For example, a string or a number.
There are eight basic data types in JavaScript. 

There are eight basic data types in JavaScript. They are:

Data Types	 Description	                                          Example
String	       represents textual data	                     'hello', "hello world!" etc
Number	     an integer or a floating-point number	              3, 3.234, 3e-2 etc.
BigInt	     an integer with arbitrary precision	              900719925124740999n , 1n etc.
Boolean      Any of two values: true or false	                      true and false
undefined    a data type whose variable is not initialized	       let a;
null	     denotes a null value	                              let a = null;
Symbol	     data type whose instances are unique and immutable      let value = Symbol('hello');
Object	     key-value pairs of collection of data	               let student = { };


# JavaScript String:
String is used to store text. In JavaScript, strings are surrounded by quotes:

Single quotes: 'Hello'
Double quotes: "Hello"
Backticks: `Hello`

Example:
//strings example
const name = 'ram';
const name1 = "hari";
const result = `The names are ${name} and ${name1}`;
Single quotes and double quotes are practically the same and you can use either of them.

Backticks are generally used when you need to include variables or expressions into a string. This is done by wrapping variables or expressions with ${variable or expression}

# JavaScript Number
Number represents integer and floating numbers (decimals and exponentials). For example,

const number1 = 3;
const number2 = 3.433;
const number3 = 3e5 // 3 * 10^5
A number type can also be +Infinity, -Infinity, and NaN (not a number). For example,

const number1 = 3/0;
console.log(number1); // Infinity

const number2 = -3/0;
console.log(number2); // -Infinity

// strings can't be divided by numbers
const number3 = "abc"/3; 
console.log(number3);  // NaN

# JavaScript BigInt
In JavaScript, Number type can only represent numbers less than (253 - 1) and more than -(253 - 1). However, if you need to use a larger number than that, you can use the BigInt data type.

A BigInt number is created by appending n to the end of an integer. For example,

// BigInt value
const value1 = 900719925124740998n;

// Adding two big integers
const result1 = value1 + 1n;
console.log(result1); // "900719925124740999n"

const value2 = 900719925124740998n;

// Error! BitInt and number cannot be added
const result2 = value2 + 1; 
console.log(result2); 
Output:
900719925124740999n
Uncaught TypeError: Cannot mix BigInt and other types

# JavaScript Boolean
This data type represents logical entities. Boolean represents one of two values: true or false. It is easier to think of it as a yes/no switch. For example,
const dataChecked = true;
const valueCounted = false;

# JavaScript undefined
The undefined data type represents value that is not assigned. If a variable is declared but the value is not assigned, then the value of that variable will be undefined. For example,

let name;
console.log(name); // undefined
Run Code
It is also possible to explicitly assign a variable value undefined. For example,

let name = undefined;
console.log(name); // undefined

Note: It is recommended not to explicitly assign undefined to a variable. Usually, null is used to assign 'unknown' or 'empty' value to a variable.

# JavaScript null
In JavaScript, null is a special value that represents empty or unknown value. For example,

const number = null;
The code above suggests that the number variable is empty.

Note: null is not the same as NULL or Null.

# JavaScript Symbol
This data type was introduced in a newer version of JavaScript (from ES2015).

A value having the data type Symbol can be referred to as a symbol value. Symbol is an immutable primitive value that is unique. For example,

// two symbols with the same description

const value1 = Symbol('hello');
const value2 = Symbol('hello');
Though value1 and value2 both contain 'hello', they are different as they are of the Symbol type.

# JavaScript Object
An object is a complex data type that allows us to store collections of data. For example,

const student = {
    firstName: 'ram',
    lastName: null,
    class: 10
};

# JavaScript Type
JavaScript is a dynamically typed (loosely typed) language. JavaScript automatically determines the variables' data type for you.
It also means that a variable can be of one data type and later it can be changed to another data type. For example,

// data is of undefined type
let data;

// data is of integer type
data = 5;

// data is of string type
data = "JavaScript Programming";

# JavaScript typeof
To find the type of a variable, you can use the typeof operator. For example,

const name = 'ram';
typeof(name); // returns "string"

const number = 4;
typeof(number); //returns "number"

const valueChecked = true;
typeof(valueChecked); //returns "boolean"

const a = null;
typeof(a); // returns "object"
Notice that typeof returned "object" for the null type.


There are 8 basic data types in JavaScript.
Seven primitive data types:
number for numbers of any kind: integer or floating-point, integers are limited by ±(253-1).
bigint for integer numbers of arbitrary length.
string for strings. A string may have zero or more characters, there’s no separate single-character type.
boolean for true/false.
null for unknown values – a standalone type that has a single value null.
undefined for unassigned values – a standalone type that has a single value undefined.
symbol for unique identifiers.
And one non-primitive data type:
object for more complex data structures.
The typeof operator allows us to see which type is stored in a variable.

Usually used as typeof x, but typeof(x) is also possible.
Returns a string with the name of the type, like "string".
For null returns "object" – this is an error in the language, it’s not actually an object.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Interaction: alert, prompt, confirm:
As we’ll be using the browser as our demo environment, let’s see a couple of functions to interact with the user: alert, prompt and confirm.

# alert
This one we’ve seen already. It shows a message and waits for the user to press “OK”.

For example:
alert("Hello");

The mini-window with the message is called a modal window. The word “modal” means that the visitor can’t interact with the rest of the page, press other buttons, etc, until they have dealt with the window. In this case – until they press “OK”.

# prompt
The function prompt accepts two arguments:
result = prompt(title, [default]);

It shows a modal window with a text message, an input field for the visitor, and the buttons OK/Cancel.

-title
The text to show the visitor.

-default
An optional second parameter, the initial value for the input field.

The square brackets in syntax [...]
The square brackets around default in the syntax above denote that the parameter is optional, not required.
The visitor can type something in the prompt input field and press OK. Then we get that text in the result. Or they can cancel the input by pressing Cancel or hitting the Esc key, then we get null as the result.

The call to prompt returns the text from the input field or null if the input was canceled.
For instance:
let age = prompt('How old are you?', 100);
alert(`You are ${age} years old!`); // You are 100 years old!

# confirm
The syntax:

result = confirm(question);
The function confirm shows a modal window with a question and two buttons: OK and Cancel.
The result is true if OK is pressed and false otherwise.

For example:
let isBoss = confirm("Are you the boss?");
alert( isBoss ); // true if OK is pressed

We covered 3 browser-specific functions to interact with visitors:
1. alert
shows a message.

2. prompt
shows a message asking the user to input text. It returns the text or, if Cancel button or Esc is clicked, null.

3. confirm
shows a message and waits for the user to press “OK” or “Cancel”. It returns true for OK and false for Cancel/Esc.

All these methods are modal: they pause script execution and don’t allow the visitor to interact with the rest of the page until the window has been dismissed.

There are two limitations shared by all the methods above:
The exact location of the modal window is determined by the browser. Usually, it’s in the center.
The exact look of the window also depends on the browser. We can’t modify it.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Type Conversions:

The three most widely used type conversions are to string, to number, and to boolean.

1.String Conversion – Occurs when we output something. Can be performed with String(value). The conversion to string is usually obvious for primitive values.
value = String(value); // now value is a string "true"
alert(typeof value); // string

2.Numeric Conversion – Occurs in math operations. Can be performed with Number(value).

The conversion follows the rules:
let str = "123";
alert(typeof str); // string
let num = Number(str); // becomes a number 123
alert(typeof num); // number

Value	                               Becomes…
undefined	                         NaN
null	                                  0
true / false	                        1 / 0
string	                               The string is read “as is”, whitespaces from both sides are ignored. An empty string becomes 0. An error gives NaN.

3.Boolean Conversion –Occurs in logical operations. Can be performed with Boolean(value).
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("hello") ); // true
alert( Boolean("") ); // false

Follows the rules:
Value
0, null, undefined, NaN, ""
any other value	

Most of these rules are easy to understand and memorize. The notable exceptions where people usually make mistakes are:
-undefined is NaN as a number, not 0.
-"0" and space-only strings like " " are true as a boolean.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Basic operators, maths:
An operand – is what operators are applied to. For instance, in the multiplication of 5 * 2 there are two operands: the left operand is 5 and the right operand is 2. Sometimes, people call these “arguments” instead of “operands”.

An operator is unary if it has a single operand. For example, the unary negation - reverses the sign of a number:
let x = 1;

x = -x;
alert( x ); // -1, unary negation was applied
An operator is binary if it has two operands. The same minus exists in binary form as well:

let x = 1, y = 3;
alert( y - x ); // 2, binary minus subtracts values
Formally, in the examples above we have two different operators that share the same symbol: the negation operator, a unary operator that reverses the sign, and the subtraction operator, a binary operator that subtracts one number from another.

# Maths
The following math operations are supported:
Addition +,
Subtraction -,
Multiplication *,
Division /,
Remainder %,
Exponentiation **

1. Remainder %
The remainder operator %, despite its appearance, is not related to percents.
The result of a % b is the remainder of the integer division of a by b.
For instance:
alert( 5 % 2 ); // 1, a remainder of 5 divided by 2
alert( 8 % 3 ); // 2, a remainder of 8 divided by 3

2. Exponentiation **
The exponentiation operator a ** b raises a to the power of b.
For instance:
alert( 2 ** 2 ); // 2² = 4
alert( 2 ** 3 ); // 2³ = 8
alert( 2 ** 4 ); // 2⁴ = 16
Just like in maths, the exponentiation operator is defined for non-integer numbers as well.

For example, a square root is an exponentiation by ½:
alert( 4 ** (1/2) ); // 2 (power of 1/2 is the same as a square root)
alert( 8 ** (1/3) ); // 2 (power of 1/3 is the same as a cubic root)

3. String concatenation with binary +
But, if the binary + is applied to strings, it merges (concatenates) them:

let s = "my" + "string";
alert(s); // mystring
Note that if any of the operands is a string, then the other one is converted to a string too.

For example:
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
See, it doesn’t matter whether the first operand is a string or the second one.

Here’s a more complex example:
alert(2 + 2 + '1' ); // "41" and not "221"

Here, operators work one after another. The first + sums two numbers, so it returns 4, then the next + adds the string 1 to it, so it’s like 4 + '1' = '41'.
alert('1' + 2 + 2); // "122" and not "14"
Here, the first operand is a string, the compiler treats the other two operands as strings too. The 2 gets concatenated to '1', so it’s like '1' + 2 = "12" and "12" + 2 = "122".
The binary + is the only operator that supports strings in such a way. Other arithmetic operators work only with numbers and always convert their operands to numbers.

Here’s the demo for subtraction and division:
alert( 6 - '2' ); // 4, converts '2' to a number
alert( '6' / '2' ); // 3, converts both operands to numbers

4. Numeric conversion, unary +
The plus + exists in two forms: the binary form that we used above and the unary form.
The unary plus or, in other words, the plus operator + applied to a single value, doesn’t do anything to numbers. But if the operand is not a number, the unary plus converts it into a number.

For example:
// No effect on numbers
let x = 1;
alert( +x ); // 1
let y = -2;
alert( +y ); // -2
// Converts non-numbers
alert( +true ); // 1
alert( +"" );   // 0

The need to convert strings to numbers arises very often. For example, if we are getting values from HTML form fields, they are usually strings. What if we want to sum them?

The binary plus would add them as strings:
let apples = "2";
let oranges = "3";
alert( apples + oranges ); // "23", the binary plus concatenates strings
If we want to treat them as numbers, we need to convert and then sum them:

let apples = "2";
let oranges = "3";
// both values converted to numbers before the binary plus
alert( +apples + +oranges ); // 5


# Operator precedence
If an expression has more than one operator, the execution order is defined by their precedence, or, in other words, the default priority order of operators.
Precedence	Name	      Sign
…	         …	        …
15	     unary plus	+
15	     unary negation	-
14	    exponentiation	**
13	    multiplication	*
13	    division	        /
12	    addition	        +
12	   subtraction	        -
…	      …	        … 
2	   assignment	        =
…	…	…
As we can see, the “unary plus” has a priority of 15 which is higher than the 12 of “addition” (binary plus). That’s why, in the expression "+apples + +oranges", unary pluses work before the addition.

5. Assignment
Let’s note that an assignment = is also an operator. It is listed in the precedence table with the very low priority of 2.
That’s why, when we assign a variable, like x = 2 * 2 + 1, the calculations are done first and then the = is evaluated, storing the result in x.
let x = 2 * 2 + 1;
alert( x ); // 5

Assignment = returns a value
All operators in JavaScript return a value. That’s obvious for + and -, but also true for =.
The call x = value writes the value into x and then returns it.

let a = 1;
let b = 2;
let c = 3 - (a = b + 1);
alert( a ); // 3
alert( c ); // 0
In the example above, the result of expression (a = b + 1) is the value which was assigned to a (that is 3).

-Chaining assignments:
let a, b, c;
a = b = c = 2 + 2;
alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
Chained assignments evaluate from right to left. First, the rightmost expression 2 + 2 is evaluated and then assigned to the variables on the left: c, b and a. At the end, all the variables share a single value.

# Modify-in-place
We often need to apply an operator to a variable and store the new result in that same variable.
let n = 2;
n = n + 5;
n = n * 2;
This notation can be shortened using the operators += and *=:
let n = 2;
n += 5; // now n = 7 (same as n = n + 5)
n *= 2; // now n = 14 (same as n = n * 2)
alert( n ); // 14

6. Increment/decrement
Increasing or decreasing a number by one is among the most common numerical operations.
So, there are special operators for it:

Increment ++ increases a variable by 1:
let counter = 2;
counter++;        // works the same as counter = counter + 1, but is shorter
alert( counter ); // 3

Decrement -- decreases a variable by 1:
let counter = 2;
counter--;        // works the same as counter = counter - 1, but is shorter
alert( counter ); // 1

Important:
Increment/decrement can only be applied to variables. Trying to use it on a value like 5++ will give an error.
The operators ++ and -- can be placed either before or after a variable.
When the operator goes after the variable, it is in “postfix form”: counter++.
The “prefix form” is when the operator goes before the variable: ++counter.
Both of these statements do the same thing: increase counter by 1.


Increment/decrement among other operators
The operators ++/-- can be used inside expressions as well. Their precedence is higher than most other arithmetical operations.

For instance:
let counter = 1;
alert( 2 * ++counter ); // 4
Compare with:
let counter = 1;
alert( 2 * counter++ ); // 2, because counter++ returns the "old" value.

7. Bitwise operators
Bitwise operators treat arguments as 32-bit integer numbers and work on the level of their binary representation.
These operators are not JavaScript-specific. They are supported in most programming languages.

The list of operators:
AND ( & )
OR ( | )
XOR ( ^ )
NOT ( ~ )
LEFT SHIFT ( << )
RIGHT SHIFT ( >> )
ZERO-FILL RIGHT SHIFT ( >>> )

Comma
The comma operator , is one of the rarest and most unusual operators.
For example:
let a = (1 + 2, 3 + 4);
alert( a ); // 7 (the result of 3 + 4)
Here, the first expression 1 + 2 is evaluated and its result is thrown away. Then, 3 + 4 is evaluated and returned as the result.

Comma has a very low precedence
Please note that the comma operator has very low precedence, lower than =, so parentheses are important in the example above.
Without them: a = 1 + 2, 3 + 4 evaluates + first, summing the numbers into a = 3, 7, then the assignment operator = assigns a = 3, and the rest is ignored. It’s like (a = 1 + 2), 3 + 4.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


