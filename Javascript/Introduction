# JAVASCRIPT:

JavaScript was initially created to “make web pages alive”.
The programs in this language are called scripts. They can be written right in a web page’s HTML and run automatically as the page loads.
Today, JavaScript can execute not only in the browser, but also on the server, or actually on any device that has a special program called the JavaScript engine.
The browser has an embedded engine sometimes called a “JavaScript virtual machine”.

Scripts are provided and executed as plain text. They don’t need special preparation or compilation to ru
JavaScript is an object-based scripting language which is lightweight and cross-platform.
JavaScript is not a compiled language, but it is a translated language. 
The JavaScript Translator (embedded in the browser) is responsible for translating the JavaScript code for the web browser.

JavaScript (js) is a light-weight object-oriented programming language which is used by several websites for scripting the webpages. 
It is an interpreted, full-fledged programming language that enables dynamic interactivity on websites when applied to an HTML document.

# There are following features of JavaScript:
All popular web browsers support JavaScript as they provide built-in execution environments.
JavaScript follows the syntax and structure of the C programming language. Thus, it is a structured programming language.
JavaScript is a weakly typed language, where certain types are implicitly cast (depending on the operation).
JavaScript is an object-oriented programming language that uses prototypes rather than using classes for inheritance.
It is a light-weighted and interpreted language.
It is a case-sensitive language.
JavaScript is supportable in several operating systems including, Windows, macOS, etc.
It provides good control to the users over the web browsers.

# JavaScript’s capabilities greatly depend on the environment it’s running in. For instance, Node.js supports functions that allow JavaScript to read/write arbitrary files, perform network requests, etc.
In-browser JavaScript can do everything related to webpage manipulation, interaction with the user, and the webserver.

For instance, in-browser JavaScript is able to:
Add new HTML to the page, change the existing content, modify styles.
React to user actions, run on mouse clicks, pointer movements, key presses.
Send requests over the network to remote servers, download and upload files (so-called AJAX and COMET technologies).
Get and set cookies, ask questions to the visitor, show messages.
Remember the data on the client-side (“local storage”).

# What CAN’T in-browser JavaScript do?
JavaScript on a webpage may not read/write arbitrary files on the hard disk, copy them or execute programs. It has no direct access to OS functions.
Different tabs/windows generally do not know about each other. Sometimes they do, for example when one window uses JavaScript to open the other one. 
But even in this case, JavaScript from one page may not access the other if they come from different sites (from a different domain, protocol or port).
This is called the “Same Origin Policy”. To work around that, both pages must agree for data exchange and contain a special JavaScript code that handles it.
Such limits do not exist if JavaScript is used outside of the browser, for example on a server. Modern browsers also allow plugin/extensions which may ask for extended permissions.

# What makes JavaScript unique?
There are at least three great things about JavaScript:

Full integration with HTML/CSS.
Simple things are done simply.
Supported by all major browsers and enabled by default.

JavaScript is the only browser technology that combines these three things.
JavaScript provides 3 places to put the JavaScript code: within body tag, within head tag and external JavaScript file.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Code editors:

A source-code editor is a text editor program designed specifically for editing source code of computer programs. 
It may be a standalone application or it may be built into an integrated development environment (IDE) or web browser
A code editor is the place where programmers spend most of their time.

There are two main types of code editors: 
IDEs and 
lightweight editors. 
Many people use one tool of each type.

# IDE:
An integrated development environment (IDE) is a software suite that consolidates basic tools required to write and test software.
An IDE typically contains a code editor, a compiler or interpreter, and a debugger, accessed through a single graphical user interface (GUI). 
The user writes and edits source code in the code editor. The compiler translates the source code into a readable language that is executable for a computer. And the debugger tests the software to solve any issues or bugs.
The term IDE (Integrated Development Environment) refers to a powerful editor with many features that usually operates on a “whole project.” 
As the name suggests, it’s not just an editor, but a full-scale “development environment.”

An IDE loads the project (which can be many files), allows navigation between files, provides autocompletion based on the whole project (not just the open file), and integrates with a version management system (like git), a testing environment, and other “project-level” stuff.

If you haven’t selected an IDE yet, consider the following options:
Visual Studio Code (cross-platform, free).
WebStorm (cross-platform, paid).
Netbeans

# Lightweight editors:
“Lightweight editors” are not as powerful as IDEs, but they’re fast, elegant and simple.
They are mainly used to open and edit a file instantly.
The main difference between a “lightweight editor” and an “IDE” is that an IDE works on a project-level, so it loads much more data on start, analyzes the project structure if needed and so on. A lightweight editor is much faster if we need only one file.
In practice, lightweight editors may have a lot of plugins including directory-level syntax analyzers and autocompleters, so there’s no strict border between a lightweight editor and an IDE.

The following options deserve your attention:
Sublime Text (cross-platform, shareware).
Notepad++ (Windows, free).
Vim and Emacs are also cool if you know how to use them.
Pycharm
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# The “script” tag:
JavaScript programs can be inserted almost anywhere into an HTML document using the <script> tag.
The <script> tag contains JavaScript code which is automatically executed when the browser processes the tag.

The <script> tag has a few attributes that are rarely used nowadays but can still be found in old code:
-The type attribute: <script type=…>
The old HTML standard, HTML4, required a script to have a type. Usually it was type="text/javascript". It’s not required anymore.

-The language attribute: <script language=…>
This attribute was meant to show the language of the script. This attribute no longer makes sense because JavaScript is the default language. There is no need to use it.

# External scripts
If we have a lot of JavaScript code, we can put it into a separate file.

Script files are attached to HTML with the src attribute:
<script src="/path/to/script.js"></script>
Here, /path/to/script.js is an absolute path to the script from the site root. One can also provide a relative path from the current page. 
For instance, src="script.js", just like src="./script.js", would mean a file "script.js" in the current folder.

Note: If src is set, the script content is ignored.
A single <script> tag can’t have both the src attribute and code inside.
We must choose either an external <script src="…"> or a regular <script> with code.

The example above can be split into two scripts to work:

<script src="file.js"></script>
<script>
  alert(1);
</script>

We can use a <script> tag to add JavaScript code to a page.
The type and language attributes are not required.
A script in an external file can be inserted with <script src="path/to/script.js"></script>.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Code structure:
The first thing we’ll study is the building blocks of code.

# Statements
Statements are syntax constructs and commands that perform actions.
We’ve already seen a statement, alert('Hello, world!'), which shows the message “Hello, world!”.
We can have as many statements in our code as we want. Statements can be separated with a semicolon.

Usually, statements are written on separate lines to make the code more readable:
alert('Hello');
alert('World');

# Semicolons
A semicolon may be omitted in most cases when a line break exists.

This would also work:
alert('Hello')
alert('World')

Here, JavaScript interprets the line break as an “implicit” semicolon. This is called an automatic semicolon insertion.

In most cases, a newline implies a semicolon. But “in most cases” does not mean “always”!

There are cases when a newline does not mean a semicolon. For example:

alert(3 +
1
+ 2);
The code outputs 6 because JavaScript does not insert semicolons here.

# But there are situations where JavaScript “fails” to assume a semicolon where it is really needed.
alert("Hello");
[1, 2].forEach(alert);
No need to think about the meaning of the brackets [] and forEach yet. We’ll study them later. For now, just remember the result of running the code: it shows Hello, then 1, then 2.

Now let’s remove the semicolon after the alert:
alert("Hello")
[1, 2].forEach(alert);
The difference compared to the code above is only one character: the semicolon at the end of the first line is gone.
If we run this code, only the first Hello shows (and there’s an error, you may need to open the console to see it). There are no numbers any more.
That’s because JavaScript does not assume a semicolon before square brackets [...]. So, the code in the last example is treated as a single statement.

Here’s how the engine sees it:
alert("Hello")[1, 2].forEach(alert);

# Comments:
Comments can be put into any place of a script. They don’t affect its execution because the engine simply ignores them.

-One-line comments start with two forward slash characters //.
The rest of the line is a comment. It may occupy a full line of its own or follow a statement.

-Multiline comments start with a forward slash and an asterisk /* and end with an asterisk and a forward slash */.
Like this:
/* An example with two messages.
This is a multiline comment.
*/
alert('Hello');
alert('World');

Note: The content of comments is ignored, so if we put code inside /* … */, it won’t execute.

Note: Nested comments are not supported!
There may not be /*...*/ inside another /*...*/.

Such code will die with an error:

/*
  /* nested comment ?!? */
*/
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# "use strict":
The purpose of "use strict" is to indicate that the code should be executed in "strict mode".
With strict mode, you can not, for example, use undeclared variables.

You can use strict mode in all your programs. It helps you to write cleaner code, like preventing you from using undeclared variables.
"use strict" is just a string, so IE 9 will not throw an error even if it does not understand it.

# Declaring Strict Mode
Strict mode is declared by adding "use strict"; to the beginning of a script or a function.
Declared at the beginning of a script, it has global scope (all code in the script will execute in strict mode):

Ex- "use strict";
x = 3.14;       // This will cause an error because x is not declared

Declared inside a function, it has local scope (only the code inside the function is in strict mode):
x = 3.14;       // This will not cause an error.
myFunction();

function myFunction() {
  "use strict";
  y = 3.14;   // This will cause an error
}

# Why Strict Mode?
Strict mode makes it easier to write "secure" JavaScript.
Strict mode changes previously accepted "bad syntax" into real errors.
As an example, in normal JavaScript, mistyping a variable name creates a new global variable. In strict mode, this will throw an error, making it impossible to accidentally create a global variable.
In normal JavaScript, a developer will not receive any error feedback assigning values to non-writable properties.
In strict mode, any assignment to a non-writable property, a getter-only property, a non-existing property, a non-existing variable, or a non-existing object, will throw an error.

# Things not Allowed in Strict Mode:
1.Using a variable, without declaring it, is not allowed:
"use strict";
x = 3.14;                // This will cause an error

2.Objects are variables too.
Using an object, without declaring it, is not allowed:

"use strict";
x = {p1:10, p2:20};      // This will cause an error

3.Deleting a variable (or object) is not allowed.

"use strict";
let x = 3.14;
delete x;                // This will cause an error

4.Deleting a function is not allowed.

"use strict";
function x(p1, p2) {};
delete x;                // This will cause an error 

5.Duplicating a parameter name is not allowed:

"use strict";
function x(p1, p1) {};   // This will cause an error

6.Octal numeric literals are not allowed:

"use strict";
let x = 010;             // This will cause an error

7.Octal escape characters are not allowed:

"use strict";
let x = "\010";            // This will cause an error

8.Writing to a read-only property is not allowed:
The readOnly property sets or returns whether a text field is read-only, or not
"use strict";
const obj = {};
Object.defineProperty(obj, "x", {value:0, writable:false});

obj.x = 3.14;            // This will cause an error

Note: Ensure that “use strict” is at the top
Please make sure that "use strict" is at the top of your scripts, otherwise strict mode may not be enabled.
There’s no way to cancel use strict

There is no directive like "no use strict" that reverts the engine to old behavior.
Once we enter strict mode, there’s no going back.

Modern JavaScript supports “classes” and “modules.So we don’t need to add the "use strict" directive, if we use them.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Variables:
Variables are used to store this information.
A variable is a “named storage” for data. We can use variables to store goodies, visitors, and other data.
To create a variable in JavaScript, use the let keyword.

# 4 Ways to Declare a JavaScript Variable:
Using var
Using let
Using const
Using nothing

The statement below creates (in other words: declares) a variable with the name “message”:
let message;

Now, we can put some data into it by using the assignment operator =:
let message;
message = 'Hello'; // store the string 'Hello' in the variable named message

We can also declare multiple variables in one line:
let user = 'John', age = 25, message = 'Hello';

Some people also define multiple variables in this multiline style:
let user = 'John',
  age = 25,
  message = 'Hello';

Or even in the “comma-first” style:
let user = 'John'
  , age = 25
  , message = 'Hello';
  
When the value is changed, the old data is removed from the variable:
let message;
message = 'Hello!';
message = 'World!'; // value changed
alert(message);

We can also declare two variables and copy data from one into the other.

Note: Declaring twice triggers an error
A variable should be declared only once.
A repeated declaration of the same variable is an error

# Variable naming
There are two limitations on variable names in JavaScript:
-The name must contain only letters, digits, or the symbols $ and _.
-The first character must not be a digit.

Examples of valid names:
let userName;
let test123;

Note: the dollar sign '$' and the underscore '_' can also be used in names. They are regular symbols, just like letters, without any special meaning.
let $ = 1; // declared a variable with the name "$"
let _ = 2; // and now a variable with the name "_"
alert($ + _); // 3

# Examples of incorrect variable names:
let 1a; // cannot start with a digit
let my-name; // hyphens '-' aren't allowed in the name

# Case matters
Variables named apple and APPLE are two different variables.

# Non-Latin letters are allowed, but not recommended
It is possible to use any language, including cyrillic letters or even hieroglyphs, like this:
let имя = '...';
let 我 = '...';

# Reserved names
There is a list of reserved words, which cannot be used as variable names because they are used by the language itself.
For example: let, class, return, and function are reserved.

The code below gives a syntax error:
let let = 5; // can't name a variable "let", error!
let return = 5; // also can't name it "return", error!

# An assignment without use strict.
// note: no "use strict" in this example
num = 5; // the variable "num" is created if it didn't exist
alert(num); // 5

This is a bad practice and would cause an error in strict mode:
"use strict";
num = 5; // error: num is not defined

# Constants
To declare a constant (unchanging) variable, use const instead of let:
const myBirthday = '18.04.1982';

Variables declared using const are called “constants”. They cannot be reassigned. An attempt to do so would cause an error:
const myBirthday = '18.04.1982';
myBirthday = '01.01.2001'; // error, can't reassign the constant!

When a programmer is sure that a variable will never change, they can declare it with const to guarantee and clearly communicate that fact to everyone.

Use const when you declare:
A new Array
A new Object
A new Function
A new RegExp

const – is like let, but the value of the variable can’t be changed.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Data types
A value in JavaScript is always of a certain type. For example, a string or a number.
There are eight basic data types in JavaScript. 

There are eight basic data types in JavaScript. They are:

Data Types	 Description	                                          Example
String	       represents textual data	                     'hello', "hello world!" etc
Number	     an integer or a floating-point number	              3, 3.234, 3e-2 etc.
BigInt	     an integer with arbitrary precision	              900719925124740999n , 1n etc.
Boolean      Any of two values: true or false	                      true and false
undefined    a data type whose variable is not initialized	       let a;
null	     denotes a null value	                              let a = null;
Symbol	     data type whose instances are unique and immutable      let value = Symbol('hello');
Object	     key-value pairs of collection of data	               let student = { };


# JavaScript String:
String is used to store text. In JavaScript, strings are surrounded by quotes:

Single quotes: 'Hello'
Double quotes: "Hello"
Backticks: `Hello`

Example:
//strings example
const name = 'ram';
const name1 = "hari";
const result = `The names are ${name} and ${name1}`;
Single quotes and double quotes are practically the same and you can use either of them.

Backticks are generally used when you need to include variables or expressions into a string. This is done by wrapping variables or expressions with ${variable or expression}

# JavaScript Number
Number represents integer and floating numbers (decimals and exponentials). For example,

const number1 = 3;
const number2 = 3.433;
const number3 = 3e5 // 3 * 10^5
A number type can also be +Infinity, -Infinity, and NaN (not a number). For example,

const number1 = 3/0;
console.log(number1); // Infinity

const number2 = -3/0;
console.log(number2); // -Infinity

// strings can't be divided by numbers
const number3 = "abc"/3; 
console.log(number3);  // NaN

# JavaScript BigInt
In JavaScript, Number type can only represent numbers less than (253 - 1) and more than -(253 - 1). However, if you need to use a larger number than that, you can use the BigInt data type.

A BigInt number is created by appending n to the end of an integer. For example,

// BigInt value
const value1 = 900719925124740998n;

// Adding two big integers
const result1 = value1 + 1n;
console.log(result1); // "900719925124740999n"

const value2 = 900719925124740998n;

// Error! BitInt and number cannot be added
const result2 = value2 + 1; 
console.log(result2); 
Output:
900719925124740999n
Uncaught TypeError: Cannot mix BigInt and other types

# JavaScript Boolean
This data type represents logical entities. Boolean represents one of two values: true or false. It is easier to think of it as a yes/no switch. For example,
const dataChecked = true;
const valueCounted = false;

# JavaScript undefined
The undefined data type represents value that is not assigned. If a variable is declared but the value is not assigned, then the value of that variable will be undefined. For example,

let name;
console.log(name); // undefined
Run Code
It is also possible to explicitly assign a variable value undefined. For example,

let name = undefined;
console.log(name); // undefined

Note: It is recommended not to explicitly assign undefined to a variable. Usually, null is used to assign 'unknown' or 'empty' value to a variable.

# JavaScript null
In JavaScript, null is a special value that represents empty or unknown value. For example,

const number = null;
The code above suggests that the number variable is empty.

Note: null is not the same as NULL or Null.

# JavaScript Symbol
This data type was introduced in a newer version of JavaScript (from ES2015).

A value having the data type Symbol can be referred to as a symbol value. Symbol is an immutable primitive value that is unique. For example,

// two symbols with the same description

const value1 = Symbol('hello');
const value2 = Symbol('hello');
Though value1 and value2 both contain 'hello', they are different as they are of the Symbol type.

# JavaScript Object
An object is a complex data type that allows us to store collections of data. For example,

const student = {
    firstName: 'ram',
    lastName: null,
    class: 10
};

# JavaScript Type
JavaScript is a dynamically typed (loosely typed) language. JavaScript automatically determines the variables' data type for you.
It also means that a variable can be of one data type and later it can be changed to another data type. For example,

// data is of undefined type
let data;

// data is of integer type
data = 5;

// data is of string type
data = "JavaScript Programming";

# JavaScript typeof
To find the type of a variable, you can use the typeof operator. For example,

const name = 'ram';
typeof(name); // returns "string"

const number = 4;
typeof(number); //returns "number"

const valueChecked = true;
typeof(valueChecked); //returns "boolean"

const a = null;
typeof(a); // returns "object"
Notice that typeof returned "object" for the null type.


There are 8 basic data types in JavaScript.
Seven primitive data types:
number for numbers of any kind: integer or floating-point, integers are limited by ±(253-1).
bigint for integer numbers of arbitrary length.
string for strings. A string may have zero or more characters, there’s no separate single-character type.
boolean for true/false.
null for unknown values – a standalone type that has a single value null.
undefined for unassigned values – a standalone type that has a single value undefined.
symbol for unique identifiers.
And one non-primitive data type:
object for more complex data structures.
The typeof operator allows us to see which type is stored in a variable.

Usually used as typeof x, but typeof(x) is also possible.
Returns a string with the name of the type, like "string".
For null returns "object" – this is an error in the language, it’s not actually an object.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Interaction: alert, prompt, confirm:
As we’ll be using the browser as our demo environment, let’s see a couple of functions to interact with the user: alert, prompt and confirm.

# alert
This one we’ve seen already. It shows a message and waits for the user to press “OK”.

For example:
alert("Hello");

The mini-window with the message is called a modal window. The word “modal” means that the visitor can’t interact with the rest of the page, press other buttons, etc, until they have dealt with the window. In this case – until they press “OK”.

# prompt
The function prompt accepts two arguments:
result = prompt(title, [default]);

It shows a modal window with a text message, an input field for the visitor, and the buttons OK/Cancel.

-title
The text to show the visitor.

-default
An optional second parameter, the initial value for the input field.

The square brackets in syntax [...]
The square brackets around default in the syntax above denote that the parameter is optional, not required.
The visitor can type something in the prompt input field and press OK. Then we get that text in the result. Or they can cancel the input by pressing Cancel or hitting the Esc key, then we get null as the result.

The call to prompt returns the text from the input field or null if the input was canceled.
For instance:
let age = prompt('How old are you?', 100);
alert(`You are ${age} years old!`); // You are 100 years old!

# confirm
The syntax:

result = confirm(question);
The function confirm shows a modal window with a question and two buttons: OK and Cancel.
The result is true if OK is pressed and false otherwise.

For example:
let isBoss = confirm("Are you the boss?");
alert( isBoss ); // true if OK is pressed

We covered 3 browser-specific functions to interact with visitors:
1. alert
shows a message.

2. prompt
shows a message asking the user to input text. It returns the text or, if Cancel button or Esc is clicked, null.

3. confirm
shows a message and waits for the user to press “OK” or “Cancel”. It returns true for OK and false for Cancel/Esc.

All these methods are modal: they pause script execution and don’t allow the visitor to interact with the rest of the page until the window has been dismissed.

There are two limitations shared by all the methods above:
The exact location of the modal window is determined by the browser. Usually, it’s in the center.
The exact look of the window also depends on the browser. We can’t modify it.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Type Conversions:

The three most widely used type conversions are to string, to number, and to boolean.

1.String Conversion – Occurs when we output something. Can be performed with String(value). The conversion to string is usually obvious for primitive values.
value = String(value); // now value is a string "true"
alert(typeof value); // string

2.Numeric Conversion – Occurs in math operations. Can be performed with Number(value).

The conversion follows the rules:
let str = "123";
alert(typeof str); // string
let num = Number(str); // becomes a number 123
alert(typeof num); // number

Value	                               Becomes…
undefined	                         NaN
null	                                  0
true / false	                        1 / 0
string	                               The string is read “as is”, whitespaces from both sides are ignored. An empty string becomes 0. An error gives NaN.

3.Boolean Conversion –Occurs in logical operations. Can be performed with Boolean(value).
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("hello") ); // true
alert( Boolean("") ); // false

Follows the rules:
Value
0, null, undefined, NaN, ""
any other value	

Most of these rules are easy to understand and memorize. The notable exceptions where people usually make mistakes are:
-undefined is NaN as a number, not 0.
-"0" and space-only strings like " " are true as a boolean.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Basic operators, maths:
An operand – is what operators are applied to. For instance, in the multiplication of 5 * 2 there are two operands: the left operand is 5 and the right operand is 2. Sometimes, people call these “arguments” instead of “operands”.

An operator is unary if it has a single operand. For example, the unary negation - reverses the sign of a number:
let x = 1;

x = -x;
alert( x ); // -1, unary negation was applied
An operator is binary if it has two operands. The same minus exists in binary form as well:

let x = 1, y = 3;
alert( y - x ); // 2, binary minus subtracts values
Formally, in the examples above we have two different operators that share the same symbol: the negation operator, a unary operator that reverses the sign, and the subtraction operator, a binary operator that subtracts one number from another.

# Maths
The following math operations are supported:
Addition +,
Subtraction -,
Multiplication *,
Division /,
Remainder %,
Exponentiation **

1. Remainder %
The remainder operator %, despite its appearance, is not related to percents.
The result of a % b is the remainder of the integer division of a by b.
For instance:
alert( 5 % 2 ); // 1, a remainder of 5 divided by 2
alert( 8 % 3 ); // 2, a remainder of 8 divided by 3

2. Exponentiation **
The exponentiation operator a ** b raises a to the power of b.
For instance:
alert( 2 ** 2 ); // 2² = 4
alert( 2 ** 3 ); // 2³ = 8
alert( 2 ** 4 ); // 2⁴ = 16
Just like in maths, the exponentiation operator is defined for non-integer numbers as well.

For example, a square root is an exponentiation by ½:
alert( 4 ** (1/2) ); // 2 (power of 1/2 is the same as a square root)
alert( 8 ** (1/3) ); // 2 (power of 1/3 is the same as a cubic root)

3. String concatenation with binary +
But, if the binary + is applied to strings, it merges (concatenates) them:

let s = "my" + "string";
alert(s); // mystring
Note that if any of the operands is a string, then the other one is converted to a string too.

For example:
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
See, it doesn’t matter whether the first operand is a string or the second one.

Here’s a more complex example:
alert(2 + 2 + '1' ); // "41" and not "221"

Here, operators work one after another. The first + sums two numbers, so it returns 4, then the next + adds the string 1 to it, so it’s like 4 + '1' = '41'.
alert('1' + 2 + 2); // "122" and not "14"
Here, the first operand is a string, the compiler treats the other two operands as strings too. The 2 gets concatenated to '1', so it’s like '1' + 2 = "12" and "12" + 2 = "122".
The binary + is the only operator that supports strings in such a way. Other arithmetic operators work only with numbers and always convert their operands to numbers.

Here’s the demo for subtraction and division:
alert( 6 - '2' ); // 4, converts '2' to a number
alert( '6' / '2' ); // 3, converts both operands to numbers

4. Numeric conversion, unary +
The plus + exists in two forms: the binary form that we used above and the unary form.
The unary plus or, in other words, the plus operator + applied to a single value, doesn’t do anything to numbers. But if the operand is not a number, the unary plus converts it into a number.

For example:
// No effect on numbers
let x = 1;
alert( +x ); // 1
let y = -2;
alert( +y ); // -2
// Converts non-numbers
alert( +true ); // 1
alert( +"" );   // 0

The need to convert strings to numbers arises very often. For example, if we are getting values from HTML form fields, they are usually strings. What if we want to sum them?

The binary plus would add them as strings:
let apples = "2";
let oranges = "3";
alert( apples + oranges ); // "23", the binary plus concatenates strings
If we want to treat them as numbers, we need to convert and then sum them:

let apples = "2";
let oranges = "3";
// both values converted to numbers before the binary plus
alert( +apples + +oranges ); // 5


# Operator precedence
If an expression has more than one operator, the execution order is defined by their precedence, or, in other words, the default priority order of operators.
Precedence	Name	      Sign
…	         …	        …
15	     unary plus	+
15	     unary negation	-
14	    exponentiation	**
13	    multiplication	*
13	    division	        /
12	    addition	        +
12	   subtraction	        -
…	      …	        … 
2	   assignment	        =
…	…	…
As we can see, the “unary plus” has a priority of 15 which is higher than the 12 of “addition” (binary plus). That’s why, in the expression "+apples + +oranges", unary pluses work before the addition.

5. Assignment
Let’s note that an assignment = is also an operator. It is listed in the precedence table with the very low priority of 2.
That’s why, when we assign a variable, like x = 2 * 2 + 1, the calculations are done first and then the = is evaluated, storing the result in x.
let x = 2 * 2 + 1;
alert( x ); // 5

Assignment = returns a value
All operators in JavaScript return a value. That’s obvious for + and -, but also true for =.
The call x = value writes the value into x and then returns it.

let a = 1;
let b = 2;
let c = 3 - (a = b + 1);
alert( a ); // 3
alert( c ); // 0
In the example above, the result of expression (a = b + 1) is the value which was assigned to a (that is 3).

-Chaining assignments:
let a, b, c;
a = b = c = 2 + 2;
alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
Chained assignments evaluate from right to left. First, the rightmost expression 2 + 2 is evaluated and then assigned to the variables on the left: c, b and a. At the end, all the variables share a single value.

# Modify-in-place
We often need to apply an operator to a variable and store the new result in that same variable.
let n = 2;
n = n + 5;
n = n * 2;
This notation can be shortened using the operators += and *=:
let n = 2;
n += 5; // now n = 7 (same as n = n + 5)
n *= 2; // now n = 14 (same as n = n * 2)
alert( n ); // 14

6. Increment/decrement
Increasing or decreasing a number by one is among the most common numerical operations.
So, there are special operators for it:

Increment ++ increases a variable by 1:
let counter = 2;
counter++;        // works the same as counter = counter + 1, but is shorter
alert( counter ); // 3

Decrement -- decreases a variable by 1:
let counter = 2;
counter--;        // works the same as counter = counter - 1, but is shorter
alert( counter ); // 1

Important:
Increment/decrement can only be applied to variables. Trying to use it on a value like 5++ will give an error.
The operators ++ and -- can be placed either before or after a variable.
When the operator goes after the variable, it is in “postfix form”: counter++.
The “prefix form” is when the operator goes before the variable: ++counter.
Both of these statements do the same thing: increase counter by 1.


Increment/decrement among other operators
The operators ++/-- can be used inside expressions as well. Their precedence is higher than most other arithmetical operations.

For instance:
let counter = 1;
alert( 2 * ++counter ); // 4
Compare with:
let counter = 1;
alert( 2 * counter++ ); // 2, because counter++ returns the "old" value.

7. Bitwise operators
Bitwise operators treat arguments as 32-bit integer numbers and work on the level of their binary representation.
These operators are not JavaScript-specific. They are supported in most programming languages.

The list of operators:
AND ( & )
OR ( | )
XOR ( ^ )
NOT ( ~ )
LEFT SHIFT ( << )
RIGHT SHIFT ( >> )
ZERO-FILL RIGHT SHIFT ( >>> )

Comma
The comma operator , is one of the rarest and most unusual operators.
For example:
let a = (1 + 2, 3 + 4);
alert( a ); // 7 (the result of 3 + 4)
Here, the first expression 1 + 2 is evaluated and its result is thrown away. Then, 3 + 4 is evaluated and returned as the result.

Comma has a very low precedence
Please note that the comma operator has very low precedence, lower than =, so parentheses are important in the example above.
Without them: a = 1 + 2, 3 + 4 evaluates + first, summing the numbers into a = 3, 7, then the assignment operator = assigns a = 3, and the rest is ignored. It’s like (a = 1 + 2), 3 + 4.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Comparisons:
We know many comparison operators from maths.
In JavaScript they are written like this:
Greater/less than: a > b, a < b.
Greater/less than or equals: a >= b, a <= b.
Equals: a == b, please note the double equality sign == means the equality test, while a single one a = b means an assignment.
Not equals: In maths the notation is ≠, but in JavaScript it’s written as a != b.

Boolean is the result
All comparison operators return a boolean value:
true – means “yes”, “correct” or “the truth”.
false – means “no”, “wrong” or “not the truth”.

For example:
alert( 2 > 1 );  // true (correct)
alert( 2 == 1 ); // false (wrong)
alert( 2 != 1 ); // true (correct)

A comparison result can be assigned to a variable, just like any value:
let result = 5 > 4; // assign the result of the comparison
alert( result ); // true

# String comparison:
To see whether a string is greater than another, JavaScript uses the so-called “dictionary” or “lexicographical” order.
In other words, strings are compared letter-by-letter.

The algorithm to compare two strings is simple:
1.Compare the first character of both strings.
2.If the first character from the first string is greater (or less) than the other string’s, then the first string is greater (or less) than the second. We’re done.
3.Otherwise, if both strings’ first characters are the same, compare the second characters the same way.
4.Repeat until the end of either string.
5.If both strings end at the same length, then they are equal. Otherwise, the longer string is greater.

alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
In the first example above, the comparison 'Z' > 'A' gets to a result at the first step.
The second comparison 'Glow' and 'Glee' needs more steps as strings are compared character-by-character:
G is the same as G.
l is the same as l.
o is greater than e. Stop here. The first string is greater.

# Comparison of different types
When comparing values of different types, JavaScript converts the values to numbers.

For example:
alert( '2' > 1 ); // true, string '2' becomes a number 2
alert( '01' == 1 ); // true, string '01' becomes a number 1
For boolean values, true becomes 1 and false becomes 0.

For example:
alert( true == 1 ); // true
alert( false == 0 ); // true

Note: It is possible that at the same time:

Two values are equal.
One of them is true as a boolean and the other one is false as a boolean.
For example:
let a = 0;
alert( Boolean(a) ); // false
let b = "0";
alert( Boolean(b) ); // true
alert(a == b); // true!

From JavaScript’s standpoint, this result is quite normal. An equality check converts values using the numeric conversion (hence "0" becomes 0), while the explicit Boolean conversion uses another set of rules.

# Strict equality
A regular equality check == has a problem. It cannot differentiate 0 from false:
alert( 0 == false ); // true
The same thing happens with an empty string:
alert( '' == false ); // true
This happens because operands of different types are converted to numbers by the equality operator ==. An empty string, just like false, becomes a zero.

A strict equality operator === checks the equality without type conversion.
In other words, if a and b are of different types, then a === b immediately returns false without an attempt to convert them.

# Comparison with null and undefined
For a strict equality check ===
These values are different, because each of them is a different type.
alert( null === undefined ); // false

For a non-strict check ==
There’s a special rule. These two are a “sweet couple”: they equal each other (in the sense of ==), but not any other value.
alert( null == undefined ); // true
For maths and other comparisons < > <= >=
null/undefined are converted to numbers: null becomes 0, while undefined becomes NaN.

# Strange result: null vs 0:
alert( null > 0 );  // (1) false
The reason is that an equality check == and comparisons > < >= <= work differently. 
Comparisons convert null to a number, treating it as 0. That’s why (3) null >= 0 is true and (1) null > 0 is false.
On the other hand, the equality check == for undefined and null is defined such that, without any conversions, they equal each other and don’t equal anything else. That’s why (2) null == 0 is false.

# An incomparable undefined
The value undefined shouldn’t be compared to other values:
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
We get these results because:
Comparisons (1) and (2) return false because undefined gets converted to NaN and NaN is a special numeric value which returns false for all comparisons.
The equality check (3) returns false because undefined only equals null, undefined, and no other value.

-Comparison operators return a boolean value.
-Strings are compared letter-by-letter in the “dictionary” order.
-When values of different types are compared, they get converted to numbers (with the exclusion of a strict equality check).
-The values null and undefined equal == each other and do not equal any other value.
-Be careful when using comparisons like > or < with variables that can occasionally be null/undefined. Checking for null/undefined separately is a good idea.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Conditional branching: if, '?'
Sometimes, we need to perform different actions based on different conditions.
To do that, we can use the if statement and the conditional operator ?, that’s also called a “question mark” operator.

# The “if” statement
The if(...) statement evaluates a condition in parentheses and, if the result is true, executes a block of code.

For example:
let year = prompt('In which year was ECMAScript-2015 specification published?', '');
if (year == 2015) alert( 'You are right!' );
In the example above, the condition is a simple equality check (year == 2015), but it can be much more complex.

If we want to execute more than one statement, we have to wrap our code block inside curly braces:
if (year == 2015) {
  alert( "That's correct!" );
  alert( "You're so smart!" );
}
We recommend wrapping your code block with curly braces {} every time you use an if statement, even if there is only one statement to execute.

# Boolean conversion
The if (…) statement evaluates the expression in its parentheses and converts the result to a boolean.
Let’s recall the conversion rules from the chapter Type Conversions:
A number 0, an empty string "", null, undefined, and NaN all become false. Because of that they are called “falsy” values.
Other values become true, so they are called “truthy”.

# The “else” clause
The if statement may contain an optional “else” block. It executes when the condition is falsy.

# Several conditions: “else if”
Sometimes, we’d like to test several variants of a condition. The else if clause lets us do that.

# Conditional operator ‘?’
Sometimes, we need to assign a variable depending on a condition.

The operator is represented by a question mark ?. Sometimes it’s called “ternary”, because the operator has three operands. It is actually the one and only operator in JavaScript which has that many.

The syntax is:
let result = condition ? value1 : value2;

The condition is evaluated: if it’s truthy then value1 is returned, otherwise – value2.
For example:
let accessAllowed = (age > 18) ? true : false;

# Multiple ‘?’
A sequence of question mark operators ? can return a value that depends on more than one condition.

# Non-traditional use of ‘?’
Sometimes the question mark ? is used as a replacement for if:

let company = prompt('Which company created JavaScript?', '');

(company == 'Netscape') ?
   alert('Right!') : alert('Wrong.');

The purpose of the question mark operator ? is to return one value or another depending on its condition. Please use it for exactly that. Use if when you need to execute different branches of code.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Logical operators:

There are four logical operators in JavaScript: 
|| (OR) 
&& (AND) 
! (NOT), 
?? (Nullish Coalescing)

Although they are called “logical”, they can be applied to values of any type, not only boolean. Their result can also be of any type.

1. || (OR)
The “OR” operator is represented with two vertical line symbols:
result = a || b;

There are four possible logical combinations:
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false

As we can see, the result is always true except for the case when both operands are false.
If an operand is not a boolean, it’s converted to a boolean for the evaluation.

For instance, the number 1 is treated as true, the number 0 as false:
if (1 || 0) { // works just like if( true || false )
  alert( 'truthy!' );
}

Most of the time, OR || is used in an if statement to test if any of the given conditions is true.
For example:
let hour = 9;
if (hour < 10 || hour > 18) {
  alert( 'The office is closed.' );
}

# The OR || operator does the following:
Evaluates operands from left to right.
For each operand, converts it to boolean. If the result is true, stops and returns the original value of that operand.
If all operands have been evaluated (i.e. all were false), returns the last operand.
A value is returned in its original form, without the conversion.

# Short-circuit evaluation:
Another feature of OR || operator is the so-called “short-circuit” evaluation.
It means that || processes its arguments until the first truthy value is reached, and then the value is returned immediately, without even touching the other argument.

2. && (AND)
The AND operator is represented with two ampersands &&:
result = a && b;

In classical programming, AND returns true if both operands are truthy and false otherwise:
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false

# The AND && operator does the following:
Evaluates operands from left to right.
For each operand, converts it to a boolean. If the result is false, stops and returns the original value of that operand.
If all operands have been evaluated (i.e. all were truthy), returns the last operand.
In other words, AND returns the first falsy value or the last value if none were found.

Note: Precedence of AND && is higher than OR ||
The precedence of AND && operator is higher than OR ||.
Don’t replace if with || or &&


3. ! (NOT)
The boolean NOT operator is represented with an exclamation sign !.
The syntax is pretty simple:
result = !value;

The operator accepts a single argument and does the following:
Converts the operand to boolean type: true/false.
Returns the inverse value.

A double NOT !! is sometimes used for converting a value to boolean type:

Note: The precedence of NOT ! is the highest of all logical operators, so it always executes first, before && or ||.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Nullish coalescing operator '??':
The nullish coalescing operator is written as two question marks ??.
As it treats null and undefined similarly, we’ll use a special term here, in this article. For brevity, we’ll say that a value is “defined” when it’s neither null nor undefined.

The result of a ?? b is:
if a is defined, then a,
if a isn’t defined, then b.

In other words, ?? returns the first argument if it’s not null/undefined. Otherwise, the second one.

We can rewrite result = a ?? b using the operators that we already know, like this:
result = (a !== null && a !== undefined) ? a : b;

For example, here we show user if its value isn’t null/undefined, otherwise Anonymous:
let user;
alert(user ?? "Anonymous"); // Anonymous (user not defined)


Here’s the example with user assigned to a name:
let user = "John";
alert(user ?? "Anonymous"); // John (user defined)

# Comparison with ||(or) and ?? :
The important difference between them is that:
|| returns the first truthy value.
?? returns the first defined value.

let height = 0;
alert(height || 100); // 100
alert(height ?? 100); // 0

The height || 100 checks height for being a falsy value, and it’s 0, falsy indeed.
so the result of || is the second argument, 100.
The height ?? 100 checks height for being null/undefined, and it’s not,
so the result is height “as is”, that is 0.

Note: The precedence of the ?? operator is the same as ||


# Using ?? with && or ||:
let x = 1 && 2 ?? 3; // Syntax error

Use explicit parentheses to work around it:
let x = (1 && 2) ?? 3; // Works
alert(x); // 2

Important:
The nullish coalescing operator ?? provides a short way to choose the first “defined” value from a list.
It’s used to assign default values to variables:
// set height=100, if height is null or undefined
height = height ?? 100;
The operator ?? has a very low precedence, only a bit higher than ? and =, so consider adding parentheses when using it in an expression.
It’s forbidden to use it with || or && without explicit parentheses.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Loops: while and for:

-> While:
The while loop has the following syntax:
while (condition) {
  // code
  // so-called "loop body"
}

While the condition is truthy, the code from the loop body is executed.
Curly braces are not required for a single-line body
If the loop body has a single statement, we can omit the curly braces {…}:
let i = 3;
while (i) alert(i--);

-> The “do…while” loop
The condition check can be moved below the loop body using the do..while syntax:

do {
  // loop body
} while (condition);
The loop will first execute the body, then check the condition, and, while it’s truthy, execute it again and again.

-> The “for” loop
It looks like this:
for (begin; condition; step) {
  // ... loop body ...
}

for (let i = 0; i < 3; i++) { // shows 0, then 1, then 2
  alert(i);
}

Let’s examine the for statement part-by-part:
part		
begin	let i = 0	Executes once upon entering the loop.
condition	i < 3	Checked before every loop iteration. If false, the loop stops.
body	alert(i)	Runs again and again while the condition is truthy.
step	i++	Executes after the body on each iteration.
The general loop algorithm works like this:

Run begin
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ ...
That is, begin executes once, and then it iterates: after each condition test, body and step are executed.


# Inline variable declaration:
Here, the “counter” variable i is declared right in the loop. This is called an “inline” variable declaration. Such variables are visible only inside the loop.
for (let i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // error, no such variable


# Skipping parts
Any part of for can be skipped.

For example, we can omit begin if we don’t need to do anything at the loop start.

Like here:
let i = 0; // we have i already declared and assigned
for (; i < 3; i++) { // no need for "begin"
  alert( i ); // 0, 1, 2
}
We can also remove the step part:
let i = 0;

for (; i < 3;) {
  alert( i++ );
}
This makes the loop identical to while (i < 3).

We can actually remove everything, creating an infinite loop:
for (;;) {
  // repeats without limits
}

Please note that the two for semicolons ; must be present. Otherwise, there would be a syntax error.

# Breaking the loop
Normally, a loop exits when its condition becomes falsy.
But we can force the exit at any time using the special break directive.

The break directive is activated at the line (*) if the user enters an empty line or cancels the input. It stops the loop immediately, passing control to the first line after the loop. Namely, alert.
The combination “infinite loop + break as needed” is great for situations when a loop’s condition must be checked not in the beginning or end of the loop, but in the middle or even in several places of its body.


# Continue to the next iteration
The continue directive is a “lighter version” of break. It doesn’t stop the whole loop. Instead, it stops the current iteration and forces the loop to start a new one (if the condition allows).
We can use it if we’re done with the current iteration and would like to move on to the next one.

The loop below uses continue to output only odd values:
for (let i = 0; i < 10; i++) {

  // if true, skip the remaining part of the body
  if (i % 2 == 0) continue;

  alert(i); // 1, then 3, 5, 7, 9
}

For even values of i, the continue directive stops executing the body and passes control to the next iteration of for (with the next number). So the alert is only called for odd values.

Note:
No break/continue to the right side of ‘?’
Please note that syntax constructs that are not expressions cannot be used with the ternary operator ?. In particular, directives such as break/continue aren’t allowed there.


# Labels for break/continue
Sometimes we need to break out from multiple nested loops at once.

A label is an identifier with a colon before a loop:
labelName: for (...) {
  ...
}

The break <labelName> statement in the loop below breaks out to the label:
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`Value at coords (${i},${j})`, '');
    // if an empty string or canceled, then break out of both loops
    if (!input) break outer; // (*)
    // do something with the value...
  }
}

alert('Done!');

In the code above, break outer looks upwards for the label named outer and breaks out of that loop.
So the control goes straight from (*) to alert('Done!').
We can also move the label onto a separate line:
outer:
for (let i = 0; i < 3; i++) { ... }

Note:
The continue directive can also be used with a label. In this case, code execution jumps to the next iteration of the labeled loop.
Labels do not allow to “jump” anywhere
Labels do not allow us to jump into an arbitrary place in the code.

For example, it is impossible to do this:
break label; // jump to the label below (doesn't work)
label: for (...)

A break directive must be inside a code block. Technically, any labelled code block will do, e.g.:
label: {
  // ...
  break label; // works
  // ...
}

We covered 3 types of loops:
while – The condition is checked before each iteration.
do..while – The condition is checked after each iteration.
for (;;) – The condition is checked before each iteration, additional settings available.

To make an “infinite” loop, usually the while(true) construct is used. Such a loop, just like any other, can be stopped with the break directive.
If we don’t want to do anything in the current iteration and would like to forward to the next one, we can use the continue directive.
break/continue support labels before the loop. A label is the only way for break/continue to escape a nested loop to go to an outer one.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# The "switch" statement:
A switch statement can replace multiple if checks.
It gives a more descriptive way to compare a value with multiple variants.

The syntax:
The switch has one or more case blocks and an optional default.

It looks like this:
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}

The value of x is checked for a strict equality to the value from the first case (that is, value1) then to the second (value2) and so on.
If the equality is found, switch starts to execute the code starting from the corresponding case, until the nearest break (or until the end of switch).
If no case is matched then the default code is executed (if it exists).

An example of switch (the executed code is highlighted):
let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Too small' );
    break;
  case 4:
    alert( 'Exactly!' );
    break;
  case 5:
    alert( 'Too big' );
    break;
  default:
    alert( "I don't know such values" );
}

Here the switch starts to compare a from the first case variant that is 3. The match fails.
Then 4. That’s a match, so the execution starts from case 4 until the nearest break.
If there is no break then the execution continues with the next case without any checks.

# If there is no break then the execution continues with the next case without any checks.
An example without break:
let a = 2 + 2;
switch (a) {
  case 3:
    alert( 'Too small' );
  case 4:
    alert( 'Exactly!' );
  case 5:
    alert( 'Too big' );
  default:
    alert( "I don't know such values" );
}
In the example above we’ll see sequential execution of three alerts:

alert( 'Exactly!' );
alert( 'Too big' );
alert( "I don't know such values" );

# Grouping of “case”:
Several variants of case which share the same code can be grouped.

For example, if we want the same code to run for case 3 and case 5:
let a = 3;
switch (a) {
  case 4:
    alert('Right!');
    break;

  case 3: // (*) grouped two cases
  case 5:
    alert('Wrong!');
    alert("Why don't you take a math class?");
    break;

  default:
    alert('The result is strange. Really.');
}
Now both 3 and 5 show the same message.
The ability to “group” cases is a side effect of how switch/case works without break. Here the execution of case 3 starts from the line (*) and goes through case 5, because there’s no break.

# Type matters
Let’s emphasize that the equality check is always strict. The values must be of the same type to match.

For example, let’s consider the code:
let arg = prompt("Enter a value?");
switch (arg) {
  case '0':
  case '1':
    alert( 'One or zero' );
    break;

  case '2':
    alert( 'Two' );
    break;

  case 3:
    alert( 'Never executes!' );
    break;
  default:
    alert( 'An unknown value' );
}
For 0, 1, the first alert runs.
For 2 the second alert runs.
But for 3, the result of the prompt is a string "3", which is not strictly equal === to the number 3. So we’ve got a dead code in case 3! The default variant will execute.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Functions:
Functions are the main “building blocks” of the program. 
They allow the code to be called many times without repetition.
We’ve already seen examples of built-in functions, like alert(message), prompt(message, default) and confirm(question). But we can create functions of our own as well.

# Function Declaration
To create a function we can use a function declaration.
function showMessage() {
  alert( 'Hello everyone!' );
}

The function keyword goes first, then goes the name of the function, then a list of parameters between the parentheses (comma-separated, empty in the example above, we’ll see examples later) and finally the code of the function, also named “the function body”, between curly braces.

function name(parameter1, parameter2, ... parameterN) {
  ...body...
}

Our new function can be called by its name: showMessage().
For instance:
function showMessage() {
  alert( 'Hello everyone!' );
}
showMessage();
showMessage();

The call showMessage() executes the code of the function. Here we will see the message two times.
This example clearly demonstrates one of the main purposes of functions: to avoid code duplication.
If we ever need to change the message or the way it is shown, it’s enough to modify the code in one place: the function which outputs it.

# Local variables
A variable declared inside a function is only visible inside that function.

# Outer variables:
A function can access an outer variable as well, for example:

let userName = 'John';
function showMessage() {
  let message = 'Hello, ' + userName;
  alert(message);
}
showMessage(); // Hello, John

The outer variable is only used if there’s no local one.
If a same-named variable is declared inside the function then it shadows the outer one.

# Global variables
Variables declared outside of any function, such as the outer userName in the code above, are called global.
Global variables are visible from any function (unless shadowed by locals).

Parameters
We can pass arbitrary data to functions using parameters.
In the example below, the function has two parameters: from and text.

function showMessage(from, text) { // parameters: from, text
  alert(from + ': ' + text);
}
showMessage('Ann', 'Hello!'); // Ann: Hello! (*)
showMessage('Ann', "What's up?"); // Ann: What's up? (**)
When the function is called in lines (*) and (**), the given values are copied to local variables from and text. Then the function uses them.

A parameter is the variable listed inside the parentheses in the function declaration (it’s a declaration time term).
An argument is the value that is passed to the function when it is called (it’s a call time term).
We declare functions listing their parameters, then call them passing arguments.

# Default values
If a function is called, but an argument is not provided, then the corresponding value becomes undefined.
For instance, the aforementioned function showMessage(from, text) can be called with a single argument:
showMessage("Ann");
That’s not an error. Such a call would output "*Ann*: undefined". As the value for text isn’t passed, it becomes undefined.
We can specify the so-called “default” (to use if omitted) value for a parameter in the function declaration, using =:

# Returning a value
A function can return a value back into the calling code as the result.
The simplest example would be a function that sums two values.
function sum(a, b) {
  return a + b;
}
let result = sum(1, 2);
alert( result ); // 3

The directive return can be in any place of the function. When the execution reaches it, the function stops, and the value is returned to the calling code (assigned to result above).

Note: A function with an empty return or without it returns undefined
If a function does not return a value, it is the same as if it returns undefined:
An empty return is also the same as return undefined.
Never add a newline between return and the value

# Naming a function
Functions are actions. So their name is usually a verb. It should be brief, as accurate as possible and describe what the function does, so that someone reading the code gets an indication of what the function does.

Function starting with…

"get…" – return a value,
"calc…" – calculate something,
"create…" – create something,
"check…" – check something and return a boolean, etc.
Examples of such names:

showMessage(..)     // shows a message
getAge(..)          // returns the age (gets it somehow)
calcSum(..)         // calculates a sum and returns the result
createForm(..)      // creates a form (and usually returns it)
checkPermission(..) // checks a permission, returns true/false

One function – one action
getAge – would be bad if it shows an alert with the age (should only get).

Summary:
A function declaration looks like this:
function name(parameters, delimited, by, comma) {
  /* code */
}

Values passed to a function as parameters are copied to its local variables.
A function may access outer variables. But it works only from inside out. The code outside of the function doesn’t see its local variables.
A function can return a value. If it doesn’t, then its result is undefined.
To make the code clean and easy to understand, it’s recommended to use mainly local variables and parameters in the function, not outer variables.
It is always easier to understand a function which gets parameters, works with them and returns a result than a function which gets no parameters, but modifies outer variables as a side effect.

Function naming:
A name should clearly describe what the function does. When we see a function call in the code, a good name instantly gives us an understanding what it does and returns.
A function is an action, so function names are usually verbal.
There exist many well-known function prefixes like create…, show…, get…, check… and so on. Use them to hint what a function does.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Coding Style:
1. Syntax:
- No space between the function name and parentheses between the parentheses and the parameter
-Indentation 2 spaces
- A space after for/if/while…
} else { without a line break
- Spaces around a nested call
- An empty line between logical blocks
- Lines are not very long
- A semicolon ; is mandatory
- Spaces around operators
- Curly brace { on the same line, after a space
- A space between arguments
- A space between parameters

2. Curly Braces
In most JavaScript projects curly braces are written in “Egyptian” style with the opening brace on the same line as the corresponding keyword – not on a new line. There should also be a space before the opening bracket, like this:
if (condition) {
  // do this
  // ...and that
  // ...and that
}

The best variant:
if (n < 0) {
  alert(`Power ${n} is not supported`);
}

3. Line Length
No one likes to read a long horizontal line of code. It’s best practice to split them.

For example:
// backtick quotes ` allow to split the string into multiple lines
let str = `
  ECMA International's TC39 is a group of JavaScript developers,
  implementers, academics, and more, collaborating with the community
  to maintain and evolve the definition of JavaScript.
`;

4. Indents
There are two types of indents:
Horizontal indents: 2 or 4 spaces.
A horizontal indentation is made using either 2 or 4 spaces or the horizontal tab symbol (key Tab). Which one to choose is an old holy war. Spaces are more common nowadays.
One advantage of spaces over tabs is that spaces allow more flexible configurations of indents than the tab symbol.

Vertical indents: empty lines for splitting code into logical blocks.
Even a single function can often be divided into logical blocks. In the example below, the initialization of variables, the main loop and returning the result are split vertically
function pow(x, n) {
  let result = 1;
  //              <--
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  //              <--
  return result;
}

5. Semicolons
A semicolon should be present after each statement, even if it could possibly be skipped.

6. Nesting Levels
Try to avoid nesting code too many levels deep.
For example, in the loop, it’s sometimes a good idea to use the continue directive to avoid extra nesting.

7. Function Placement
If you are writing several “helper” functions and the code that uses them, there are three ways to organize the functions.
Declare the functions above the code that uses them:

// function declarations
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}

// the code which uses them
let elem = createElement();
setHandler(elem);
walkAround();
Code first, then functions

// the code which uses the functions
let elem = createElement();
setHandler(elem);
walkAround();

// --- helper functions ---
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}

Mixed: a function is declared where it’s first used.
Most of time, the second variant is preferred.
That’s because when reading code, we first want to know what it does. If the code goes first, then it becomes clear from the start. 

# Style Guides
A style guide contains general rules about “how to write” code, e.g. which quotes to use, how many spaces to indent, the maximal line length, etc. A lot of minor things.
When all members of a team use the same style guide, the code looks uniform, regardless of which team member wrote it.

# Automated Linters
Linters are tools that can automatically check the style of your code and make improving suggestions.
The great thing about them is that style-checking can also find some bugs, like typos in variable or function names.

Here are some well-known linting tools:

JSLint – one of the first linters.
JSHint – more settings than JSLint.
ESLint – probably the newest one.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Automated testing with Mocha:
Mocha is an open source test framework that is used to run your automated tests in Node. It comes with a wide range of features that allow you to create descriptive automated tests, robust reports and even execute your automated tests every time a file is changed locally.
Mocha.js provides functions that execute in a specific order and logs the results in the terminal window. 
It also cleans the state of the software being tested to ensure that test cases run independently of each other.

Automated testing will be used in further tasks, and it’s also widely used in real projects.
Automated testing means that tests are written separately, in addition to the code. They run our functions in various ways and compare results with the expected.
When we write a function, we can usually imagine what it should do: which parameters give which results.
During development, we can check the function by running it and comparing the outcome with the expected one. For instance, we can do it in the console.
If something is wrong – then we fix the code, run again, check the result – and so on till it works.

# A spec has three main building blocks that you can see above:
describe("title", function() { ... })
What functionality we’re describing? In our case we’re describing the function pow. Used to group “workers” – the it blocks.
it("use case description", function() { ... })
In the title of it we in a human-readable way describe the particular use case, and the second argument is a function that tests it.
assert.equal(value1, value2)
The code inside it block, if the implementation is correct, should execute without errors.
Functions assert.* are used to check whether pow works as expecte

# The development flow
The flow of development usually looks like this:
-An initial spec is written, with tests for the most basic functionality.
-An initial implementation is created.
-To check whether it works, we run the testing framework Mocha (more details soon) that runs the spec. While the functionality is not complete, errors are displayed. We make corrections until everything works.
-Now we have a working initial implementation with tests.
-We add more use cases to the spec, probably not yet supported by the implementations. Tests start to fail.
-Go to 3, update the implementation till tests give no errors.
-Repeat steps 3-6 till the functionality is ready.
-So, the development is iterative. We write the spec, implement it, make sure tests pass, then write more tests, make sure they work etc. At the end we have both a working implementation and tests for it.

# The spec in action:
-Mocha – the core framework: it provides common testing functions including describe and it and the main function that runs tests.
-Chai – the library with many assertions. It allows to use a lot of different assertions, for now we need only assert.equal.
-Sinon – a library to spy over functions, emulate built-in functions and more, we’ll need it much later.
These libraries are suitable for both in-browser and server-side testing.

# Other assertions
Please note the assertion assert.isNaN: it checks for NaN.
There are other assertions in Chai as well, for instance:
assert.equal(value1, value2) – checks the equality value1 == value2.
assert.strictEqual(value1, value2) – checks the strict equality value1 === value2.
assert.notEqual, assert.notStrictEqual – inverse checks to the ones above.
assert.isTrue(value) – checks that value === true
assert.isFalse(value) – checks that value === false
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Polyfills and transpilers:
A transpiler will convert a new syntax to an older syntax.
A transpiler is a special piece of software that translates source code to another source code. 
It can parse (“read and understand”) modern code and rewrite it using older syntax constructs, so that it’ll also work in outdated engines.

A transpiler would analyze our code and rewrite height ?? 100 into (height !== undefined && height !== null) ? height : 100.
// before running the transpiler
height = height ?? 100;
// after running the transpiler
height = (height !== undefined && height !== null) ? height : 100;

Usually, a developer runs the transpiler on their own computer, and then deploys the transpiled code to the server.
Speaking of names, Babel is one of the most prominent transpilers out there.

# Polyfills
Polyfills are useful when the issue is related to a missing API rather than some new syntax.
For example, Math.trunc(n) is a function that “cuts off” the decimal part of a number, e.g Math.trunc(1.23) returns 1.
A script that updates/adds new functions is called “polyfill”. It “fills in” the gap and adds missing implementations.

Two interesting polyfill libraries are:
-core js that supports a lot, allows to include only needed features.
-polyfill.io service that provides a script with polyfills, depending on the features and user’s browser.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Objects:
Objects are used to store keyed collections of various data and more complex entities.
An object can be created with figure brackets {…} with an optional list of properties. 
A property is a “key: value” pair, where key is a string (also called a “property name”), and value can be anything.

An empty object (“empty cabinet”) can be created using one of two syntaxes:
let user = new Object(); // "object constructor" syntax
let user = {};  // "object literal" syntax

Usually, the figure brackets {...} are used. That declaration is called an object literal.

# Literals and properties:
We can immediately put some properties into {...} as “key: value” pairs:
let user = {     // an object
  name: "John",  // by key "name" store value "John"
  age: 30        // by key "age" store value 30
};

A property has a key (also known as “name” or “identifier”) before the colon ":" and a value to the right of it.
In the user object, there are two properties:
The first property has the name "name" and the value "John".
The second one has the name "age" and the value 30.

Property values are accessible using the dot notation:
// get property values of the object:
alert( user.name ); // John
alert( user.age ); // 30

The value can be of any type. Let’s add a boolean one:
user.isAdmin = true;

To remove a property, we can use the delete operator:
delete user.age;

# Computed properties
We can use square brackets in an object literal, when creating an object. That’s called computed properties.
let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};

# Property names limitations
As we already know, a variable cannot have a name equal to one of the language-reserved words like “for”, “let”, “return” etc.
But for an object property, there’s no such restriction

Reading a non-existing property just returns undefined. So we can easily test whether the property exists:
There’s also a special operator "in" for that.

The syntax is:
"key" in object

For instance:
let user = { name: "John", age: 30 };
alert( "age" in user ); // true, user.age exists
alert( "blabla" in user ); // false, user.blabla doesn't exist

# The "for..in" loop:
The syntax:

for (key in object) {
  // executes the body for each key among object properties
}

-Objects are associative arrays with several special features.
-They store properties (key-value pairs), where:
-Property keys must be strings or symbols (usually strings).
-Values can be of any type.
-To access a property, we can use:
-The dot notation: obj.property.
-Square brackets notation obj["property"]. Square brackets allow taking the key from a variable, like obj[varWithKey].

Additional operators:
-To delete a property: delete obj.prop.
-To check if a property with the given key exists: "key" in obj.
-To iterate over an object: for (let key in obj) loop.

There are many other kinds of objects in JavaScript:
Array to store ordered data collections,
Date to store the information about the date and time,
Error to store the information about an error.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Garbage collection:
Garbage collection (GC) is a form of automatic memory management. The garbage collector, or just collector, attempts to reclaim garbage, or memory occupied by objects that are no longer in use by the program. 
The majority of memory management issues occur when we try to release the allocated memory. The main concern that arises is the determination of unused memory resources. 
In case of the low-level languages where the developer has to manually decide when the memory is no longer needed, high-level languages such as JavaScript use an automated form of memory management known as Garbage Collection(GC).
The general problem of automatically finding whether some memory "is not needed anymore" is undecidable.
The main concept of the algorithms designed for garbage collection is the concept of reference. 

Here’s the simplest example:

// user has a reference to the object
let user = {
  name: "John"
};
Here the arrow depicts an object reference. The global variable "user" references the object {name: "John"}
If the value of user is overwritten, the reference is lost:
i.e user = null;
Now John becomes unreachable. There’s no way to access it, no references to it. Garbage collector will junk the data and free the memory.

# Two references:
Now let’s imagine we copied the reference from user to admin:

// user has a reference to the object
let user = {
  name: "John"
};
let admin = user;

Now if we do the same:
user = null;
Then the object is still reachable via admin global variable, so it must stay in memory. If we overwrite admin too, then it can be removed.

# Internal algorithms
The basic garbage collection algorithm is called “mark-and-sweep”.
The following “garbage collection” steps are regularly performed:
The garbage collector takes roots and “marks” (remembers) them.
Then it visits and “marks” all references from them.
Then it visits marked objects and marks their references. All visited objects are remembered, so as not to visit the same object twice in the future.
…And so on until every reachable (from the roots) references are visited.
All objects except marked ones are removed.

The main things to know:
Garbage collection is performed automatically. We cannot force or prevent it.
Objects are retained in memory while they are reachable.
Being referenced is not the same as being reachable (from a root): a pack of interlinked objects can become unreachable as a whole, as we’ve seen in the example above.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# “this” in methods:

It’s common that an object method needs to access the information stored in the object to do its job.
For instance, the code inside user.sayHi() may need the name of the user.
To access the object, a method can use the this keyword.
The value of this is the object “before dot”, the one used to call the method.

# “this” is not bound
In JavaScript, keyword this behaves unlike most other programming languages. It can be used in any function, even if it’s not a method of an object.

There’s no syntax error in the following example:
function sayHi() {
  alert( this.name );
}
The value of this is evaluated during the run-time, depending on the context. 
Calling without an object: this == undefined
We can even call the function without an object at all:

function sayHi() {
  alert(this);
}
sayHi(); // undefined

In this case this is undefined in strict mode. If we try to access this.name, there will be an error.

The consequences of unbound this
If you come from another programming language, then you are probably used to the idea of a "bound this", where methods defined in an object always have this referencing that object.
In JavaScript this is “free”, its value is evaluated at call-time and does not depend on where the method was declared, but rather on what object is “before the dot”.

# Arrow functions have no “this”
Arrow functions are special: they don’t have their “own” this. If we reference this from such a function, it’s taken from the outer “normal” function.

For instance, here arrow() uses this from the outer user.sayHi() method:

let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};
user.sayHi(); // Ilya

Functions that are stored in object properties are called “methods”.
Methods allow objects to “act” like object.doSomething().
Methods can reference the object as this.
The value of this is defined at run-time.
When a function is declared, it may use this, but that this has no value until the function is called.
A function can be copied between objects.
When a function is called in the “method” syntax: object.method(), the value of this during the call is object.
Please note that arrow functions are special: they have no this. When this is accessed inside an arrow function, it is taken from outside.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Constructor, operator "new":
The regular {...} syntax allows us to create one object. But often we need to create many similar objects, like multiple users or menu items and so on.
That can be done using constructor functions and the "new" operator.

# Constructor function
Constructor functions technically are regular functions. There are two conventions though:
-They are named with capital letter first.
-They should be executed only with "new" operator.

That’s the main purpose of constructors – to implement reusable object creation code.
# new function() { … }
If we have many lines of code all about creation of a single complex object, we can wrap them in an immediately called constructor function, like this:
// create a function and immediately call it with new
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...other code for user creation
  // maybe complex logic and statements
  // local variables etc
};
This constructor can’t be called again, because it is not saved anywhere, just created and called. So this trick aims to encapsulate the code that constructs the single object, without future reuse.

# Constructor mode test: new.target:
Inside a function, we can check whether it was called with new or without it, using a special new.target property.

# Return from constructors:
Usually, constructors do not have a return statement. Their task is to write all necessary stuff into this, and it automatically becomes the result.
But if there is a return statement, then the rule is simple:
If return is called with an object, then the object is returned instead of this.
If return is called with a primitive, it’s ignored.
In other words, return with an object returns that object, in all other cases this is returned.

# Omitting parentheses
By the way, we can omit parentheses after new, if it has no arguments:
let user = new User; // <-- no parentheses
// same as
let user = new User();
Omitting parentheses here is not considered a “good style”, but the syntax is permitted by specification.

# Methods in constructor
Using constructor functions to create objects gives a great deal of flexibility. The constructor function may have parameters that define how to construct the object, and what to put in it.
Of course, we can add to this not only properties, but methods as well.

Constructor functions or, briefly, constructors, are regular functions, but there’s a common agreement to name them with capital letter first.
Constructor functions should only be called using new. Such a call implies a creation of empty this at the start and returning the populated one at the end.
We can use constructor functions to make multiple similar objects.
JavaScript provides constructor functions for many built-in language objects: like Date for dates, Set for sets and others that we plan to study.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Symbol is a primitive type for unique identifiers.
Symbols are created with Symbol() call with an optional description (name).
Symbols are always different values, even if they have the same name. If we want same-named symbols to be equal, then we should use the global registry: 
Symbol.for(key) returns (creates if needed) a global symbol with key as the name. Multiple calls of Symbol.for with the same key return exactly the same symbol.

# System symbols:
There exist many “system” symbols that JavaScript uses internally, and we can use them to fine-tune various aspects of our objects.
They are listed in the specification in the Well-known symbols table:
Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.iterator
Symbol.toPrimitive
…and so on.
For instance, Symbol.toPrimitive allows us to describe object to primitive conversion.

# Symbols in an object literal
If we want to use a symbol in an object literal {...}, we need square brackets around it.

Like this:
let id = Symbol("id");
let user = {
  name: "John",
  [id]: 123 // not "id": 123
};
That’s because we need the value from the variable id as the key, not the string “id”

# Symbols are skipped by for…in
Symbolic properties do not participate in for..in loop.

# “Hidden” properties
Symbols allow us to create “hidden” properties of an object, that no other part of code can accidentally access or overwrite.
If another script or a library loops over our object, it won’t unexpectedly access a symbolic property.

# Global symbols
As we’ve seen, usually all symbols are different, even if they have the same name. But sometimes we want same-named symbols to be same entities. 
For instance, different parts of our application want to access symbol "id" meaning exactly the same property.
To achieve that, there exists a global symbol registry. We can create symbols in it and access them later, and it guarantees that repeated accesses by the same name return exactly the same symbol.
In order to read (create if absent) a symbol from the registry, use Symbol.for(key).
That call checks the global registry, and if there’s a symbol described as key, then returns it, otherwise creates a new symbol Symbol(key) and stores it in the registry by the given key.

# Symbol.keyFor
We have seen that for global symbols, Symbol.for(key) returns a symbol by name. To do the opposite – return a name by global symbol – we can use: Symbol.keyFor(sym):

Symbols have two main use cases:
-“Hidden” object properties.
If we want to add a property into an object that “belongs” to another script or a library, we can create a symbol and use it as a property key. A symbolic property does not appear in for..in, so it won’t be accidentally processed together with other properties. 
Also it won’t be accessed directly, because another script does not have our symbol. So the property will be protected from accidental use or overwrite.
So we can “covertly” hide something into objects that we need, but others should not see, using symbolic properties.
-There are many system symbols used by JavaScript which are accessible as Symbol.*. We can use them to alter some built-in behaviors. 
For instance, later in the tutorial we’ll use Symbol.iterator for iterables, Symbol.toPrimitive to setup object-to-primitive conversion and so on.
Technically, symbols are not 100% hidden. There is a built-in method Object.getOwnPropertySymbols(obj) that allows us to get all symbols. 
Also there is a method named Reflect.ownKeys(obj) that returns all keys of an object including symbolic ones. But most libraries, built-in functions and syntax constructs don’t use these methods.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Object to primitive conversion:
What happens when objects are added obj1 + obj2, subtracted obj1 - obj2 or printed using alert(obj)?
JavaScript doesn’t allow you to customize how operators work on objects. Unlike some other programming languages, such as Ruby or C++, we can’t implement a special object method to handle addition (or other operators).
In case of such operations, objects are auto-converted to primitives, and then the operation is carried out over these primitives and results in a primitive value.

# Conversion rules:
-There’s no conversion to boolean. All objects are true in a boolean context, as simple as that. There exist only numeric and string conversions.
-The numeric conversion happens when we subtract objects or apply mathematical functions. 
For instance, Date objects (to be covered in the chapter Date and time) can be subtracted, and the result of date1 - date2 is the time difference between two dates.
-As for the string conversion – it usually happens when we output an object with alert(obj) and in similar contexts.
-We can implement string and numeric conversion by ourselves, using special object methods.

# Hints:
There are three variants of type conversion, that happen in various situations. They’re called “hints”.

1. "string"
For an object-to-string conversion, when we’re doing an operation on an object that expects a string, like alert:
// output
alert(obj);
// using object as a property key
anotherObj[obj] = 123;

2. "number"
For an object-to-number conversion, like when we’re doing maths:
// explicit conversion
let num = Number(obj);
// maths (except binary plus)
let n = +obj; // unary plus
let delta = date1 - date2;
// less/greater comparison
let greater = user1 > user2;

3. "default"
Occurs in rare cases when the operator is “not sure” what type to expect.
For instance, binary plus + can work both with strings (concatenates them) and numbers (adds them). 
So if a binary plus gets an object as an argument, it uses the "default" hint to convert it.

The greater and less comparison operators, such as < >, can work with both strings and numbers too. Still, they use the "number" hint, not "default".

# To do the conversion, JavaScript tries to find and call three object methods:

-Call obj[Symbol.toPrimitive](hint) – the method with the symbolic key Symbol.toPrimitive (system symbol), if such method exists,
Otherwise if hint is "string"
-try calling obj.toString() or obj.valueOf(), whatever exists.
Otherwise if hint is "number" or "default"
-try calling obj.valueOf() or obj.toString(), whatever exists.

# Symbol.toPrimitive
Let’s start from the first method. There’s a built-in symbol named Symbol.toPrimitive that should be used to name the conversion method.
Syntax:
obj[Symbol.toPrimitive] = function(hint) {
  // here goes the code to convert this object to a primitive
  // it must return a primitive value
  // hint = one of "string", "number", "default"
};

# toString/valueOf
If there’s no Symbol.toPrimitive then JavaScript tries to find methods toString and valueOf:
For the "string" hint: call toString method, and if it doesn’t exist, then valueOf (so toString has the priority for string conversions).
For other hints: valueOf, and if it doesn’t exist, then toString (so valueOf has the priority for maths).

By default, a plain object has following toString and valueOf methods:

The toString method returns a string "[object Object]".
The valueOf method returns the object itself.

# Further conversions
As we know already, many operators and functions perform type conversions, e.g. multiplication * converts operands to numbers.
If we pass an object as an argument, then there are two stages of calculations:
The object is converted to a primitive (using the rules described above).
If the necessary for further calculations, the resulting primitive is also converted.
1. The multiplication obj * 2 first converts the object to primitive (that’s a string "2").
2.Then "2" * 2 becomes 2 * 2 (the string is converted to number).

The object-to-primitive conversion is called automatically by many built-in functions and operators that expect a primitive as a value.

There are 3 types (hints) of it:
"string" (for alert and other operations that need a string)
"number" (for maths)
"default" (few operators, usually objects implement it the same way as "number")
The specification describes explicitly which operator uses which hint.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Methods of primitives
JavaScript allows us to work with primitives (strings, numbers, etc.) as if they were objects. They also provide methods to call as such.

Let’s look at the key distinctions between primitives and objects.
A primitive
Is a value of a primitive type.
There are 7 primitive types: string, number, bigint, boolean, symbol, null and undefined.

An object
Is capable of storing multiple values as properties.
Can be created with {}, for instance: {name: "John", age: 30}. There are other kinds of objects in JavaScript: functions

# A primitive as an object:
The language allows access to methods and properties of strings, numbers, booleans and symbols.

The “object wrappers” are different for each primitive type and are called: String, Number, Boolean, Symbol and BigInt. Thus, they provide different sets of methods.
For instance, there exists a string method str.toUpperCase() that returns a capitalized str.
let str = "Hello";

alert( str.toUpperCase() ); // HELLO
Simple, right? Here’s what actually happens in str.toUpperCase():
The string str is a primitive. So in the moment of accessing its property, a special object is created that knows the value of the string, and has useful methods, like toUpperCase().
That method runs and returns a new string (shown by alert).
The special object is destroyed, leaving the primitive str alone.

A number has methods of its own, for instance, toFixed(n) rounds the number to the given precision:
Constructors String/Number/Boolean are for internal use only
Some languages like Java allow us to explicitly create “wrapper objects” for primitives using a syntax like new Number(1) or new Boolean(false)
ex- alert( typeof 0 ); // "number"
alert( typeof new Number(0) ); // "object"!

Objects are always truthy in if, so here the alert will show up:
let zero = new Number(0);
if (zero) { // zero is true, because it's an object
  alert( "zero is truthy!?!" );
}

On the other hand, using the same functions String/Number/Boolean without new is totally fine and useful thing. They convert a value to the corresponding type: to a string, a number, or a boolean (primitive).
For example, this is entirely valid:
let num = Number("123"); // convert a string to number

null/undefined have no methods
The special primitives null and undefined are exceptions. They have no corresponding “wrapper objects” and provide no methods
alert(null.test); // error
Formally, these methods work via temporary objects, but JavaScript engines are well tuned to optimize that internally, so they are not expensive to call.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Numbers
In modern JavaScript, there are two types of numbers:
-Regular numbers in JavaScript are stored in 64-bit format IEEE-754, also known as “double precision floating point numbers”. These are numbers that we’re using most of the time, and we’ll talk about them in this chapter.
-BigInt numbers represent integers of arbitrary length. They are sometimes needed because a regular integer number can’t safely exceed (253-1) or be less than -(253-1), as we mentioned earlier in the chapter Data types. As bigints are used in few special areas, we devote them a special chapter BigInt.

# More ways to write a number:
Imagine we need to write 1 billion. The obvious way is:
let billion = 1000000000;
We also can use underscore _ as the separator:
let billion = 1_000_000_000;

Syntactic sugar is syntax within a programming language that is designed to make things easier to read or to express.
Here the underscore _ plays the role of the “syntactic sugar”, it makes the number more readable. The JavaScript engine simply ignores _ between digits, so it’s exactly the same one billion as above.

In JavaScript, we can shorten a number by appending the letter "e" to it and specifying the zeroes count:
let billion = 1e9;  // 1 billion, literally: 1 and 9 zeroes

In other words, e multiplies the number by 1 with the given zeroes count.
1e3 === 1 * 1000; // e3 means *1000

Now let’s write something very small. Say, 1 microsecond (one millionth of a second):
let mсs = 0.000001;
Just like before, using "e" can help. If we’d like to avoid writing the zeroes explicitly, we could write the same as:
let mcs = 1e-6; // five zeroes to the left from 1.
If we count the zeroes in 0.000001, there are 6 of them. So naturally it’s 1e-6.

In other words, a negative number after "e" means a division by 1 with the given number of zeroes:

// -3 divides by 1 with 3 zeroes
1e-3 === 1 / 1000; // 0.001
// -6 divides by 1 with 6 zeroes
1.23e-6 === 1.23 / 1000000; // 0.00000123
// an example with a bigger number
1234e-2 === 1234 / 100; // 12.34, decimal point moves 2 times

# Hex, binary and octal numbers
Hexadecimal numbers are widely used in JavaScript to represent colors, encode characters, and for many other things. So naturally, there exists a shorter way to write them: 0x and then the number.
alert( 0xff ); // 255

# Binary and octal numeral systems are rarely used, but also supported using the 0b and 0o prefixes:
let a = 0b11111111; // binary form of 255
let b = 0o377; // octal form of 255
alert( a == b ); // true, the same number 255 at both sides

# toString(base)
The method num.toString(base) returns a string representation of num in the numeral system with the given base.
For example:
let num = 255;
alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
The base can vary from 2 to 36. By default it’s 10.

Common use cases for this are:
base=16 is used for hex colors, character encodings etc, digits can be 0..9 or A..F.

base=2 is mostly for debugging bitwise operations, digits can be 0 or 1.

base=36 is the maximum, digits can be 0..9 or A..Z. The whole latin alphabet is used to represent a number. A funny, but useful case for 36 is when we need to turn a long numeric identifier into something shorter, for example to make a short url. Can simply represent it in the numeral system with base 36:
alert( 123456..toString(36) ); // 2n9c

# Two dots to call a method
Please note that two dots in 123456..toString(36) is not a typo. If we want to call a method directly on a number, like toString in the example above, then we need to place two dots .. after it.
If we placed a single dot: 123456.toString(36), then there would be an error, because JavaScript syntax implies the decimal part after the first dot. And if we place one more dot, then JavaScript knows that the decimal part is empty and now goes the method.
Also could write (123456).toString(36).

# Rounding
One of the most used operations when working with numbers is rounding.

There are several built-in functions for rounding:
1. Math.floor
Rounds down: 3.1 becomes 3, and -1.1 becomes -2.
2. Math.ceil
Rounds up: 3.1 becomes 4, and -1.1 becomes -1.
3. Math.round
Rounds to the nearest integer: 3.1 becomes 3, 3.6 becomes 4, the middle case: 3.5 rounds up to 4 too.
4. Math.trunc (not supported by Internet Explorer)
Removes anything after the decimal point without rounding: 3.1 becomes 3, -1.1 becomes -1.

Here’s the table to summarize the differences between them:

       Math.floor	Math.ceil	Math.round	Math.trunc
3.1	   3	           4	            3	           3
3.6	   3	           4	            4	           3
-1.1	  -2	          -1	           -1	          -1
-1.6	  -2	          -1	           -2	          -1

# But what if we’d like to round the number to n-th digit after the decimal?
For instance, we have 1.2345 and want to round it to 2 digits, getting only 1.23.
There are two ways to do so:

1. Multiply-and-divide.
For example, to round the number to the 2nd digit after the decimal, we can multiply the number by 100, call the rounding function and then divide it back.
let num = 1.23456;
alert( Math.round(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23

2. The method toFixed(n) rounds the number to n digits after the point and returns a string representation of the result.
let num = 12.34;
alert( num.toFixed(1) ); // "12.3"

This rounds up or down to the nearest value, similar to Math.round:

let num = 12.36;
alert( num.toFixed(1) ); // "12.4"
Please note that the result of toFixed is a string. If the decimal part is shorter than required, zeroes are appended to the end:

let num = 12.34;
alert( num.toFixed(5) ); // "12.34000", added zeroes to make exactly 5 digits
We can convert it to a number using the unary plus or a Number() call, e.g write +num.toFixed(5).


# Imprecise calculations
Internally, a number is represented in 64-bit format IEEE-754, so there are exactly 64 bits to store a number: 52 of them are used to store the digits, 11 of them store the position of the decimal point, and 1 bit is for the sign.

If a number is really huge, it may overflow the 64-bit storage and become a special numeric value Infinity:
alert( 1e500 ); // Infinity

The most reliable method is to round the result with the help of a method toFixed(n):
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // "0.30"
Please note that toFixed always returns a string. It ensures that it has 2 digits after the decimal point. 

# We also can temporarily multiply the numbers by 100 (or a bigger number) to turn them into integers, do the maths, and then divide back. Then, as we’re doing maths with integers, the error somewhat decreases, but we still get it on division:
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
So, multiply/divide approach reduces the error, but doesn’t remove it totally.

# Two zeroes
Another funny consequence of the internal representation of numbers is the existence of two zeroes: 0 and -0.
That’s because a sign is represented by a single bit, so it can be set or not set for any number including a zero.
In most cases the distinction is unnoticeable, because operators are suited to treat them as the same.

# Tests: isFinite and isNaN
Remember these two special numeric values?
-Infinity (and -Infinity) is a special numeric value that is greater (less) than anything.
-NaN represents an error.

They belong to the type number, but are not “normal” numbers, so there are special functions to check for them:
1. isNaN(value) converts its argument to a number and then tests it for being NaN:
alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true

The value NaN is unique in that it does not equal anything, including itself:
alert( NaN === NaN ); // false

2. isFinite(value) converts its argument to a number and returns true if it’s a regular number, not NaN/Infinity/-Infinity:
alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, because a special value: NaN
alert( isFinite(Infinity) ); // false, because a special value: Infinity

Sometimes isFinite is used to validate whether a string value is a regular number:
Note: Please note that an empty or a space-only string is treated as 0 in all numeric functions including isFinite.

Compare with Object.is:
There is a special built-in method Object.is that compares values like ===, but is more reliable for two edge cases:
It works with NaN: Object.is(NaN, NaN) === true, that’s a good thing.
Values 0 and -0 are different: Object.is(0, -0) === false, technically that’s true, because internally the number has a sign bit that may be different even if all other bits are zeroes.
In all other cases, Object.is(a, b) is the same as a === b.
This way of comparison is often used in JavaScript specification. When an internal algorithm needs to compare two values for being exactly the same, it uses Object.is (internally called SameValue).

# parseInt and parseFloat
Numeric conversion using a plus + or Number() is strict. If a value is not exactly a number, it fails:
alert( +"100px" ); // NaN

They “read” a number from a string until they can’t. In case of an error, the gathered number is returned. 
The function parseInt returns an integer, while parseFloat will return a floating-point number.

There are situations when parseInt/parseFloat will return NaN. It happens when no digits could be read:
alert( parseInt('a123') ); // NaN, the first symbol stops the process

# The second argument of parseInt(str, radix)
The parseInt() function has an optional second parameter. It specifies the base of the numeral system, so parseInt can also parse strings of hex numbers, binary numbers and so on:
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, without 0x also works
alert( parseInt('2n9c', 36) ); // 123456

# Other math functions
JavaScript has a built-in Math object which contains a small library of mathematical functions and constants.
1. Math.random()
Returns a random number from 0 to 1 (not including 1).
alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (any random numbers)

2. Math.max(a, b, c...) and Math.min(a, b, c...)
Returns the greatest and smallest from the arbitrary number of arguments.
alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1

3. Math.pow(n, power)
Returns n raised to the given power.
alert( Math.pow(2, 10) ); // 2 in power 10 = 1024
There are more functions and constants in Math object, including trigonometry, which you can find in the docs for the Math object.

Summary:
-To write numbers with many zeroes:
Append "e" with the zeroes count to the number. Like: 123e6 is the same as 123 with 6 zeroes 123000000.
A negative number after "e" causes the number to be divided by 1 with given zeroes. E.g. 123e-6 means 0.000123 (123 millionths).

-For different numeral systems:
Can write numbers directly in hex (0x), octal (0o) and binary (0b) systems.
parseInt(str, base) parses the string str into an integer in numeral system with given base, 2 ≤ base ≤ 36.
num.toString(base) converts a number to a string in the numeral system with the given base.

-For regular number tests:
isNaN(value) converts its argument to a number and then tests it for being NaN
isFinite(value) converts its argument to a number and returns true if it’s a regular number, not NaN/Infinity/-Infinity

-For converting values like 12pt and 100px to a number:
Use parseInt/parseFloat for the “soft” conversion, which reads a number from a string and then returns the value they could read before the error.

-For fractions:
Round using Math.floor, Math.ceil, Math.trunc, Math.round or num.toFixed(precision).
Make sure to remember there’s a loss of precision when working with fractions.

-More mathematical functions:
See the Math object when you need them. The library is very small, but can cover basic needs.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Strings:
In JavaScript, the textual data is stored as strings. There is no separate type for a single character.
The internal format for strings is always UTF-16, it is not tied to the page encoding.

Quotes:
Strings can be enclosed within either single quotes, double quotes or backticks:
let single = 'single-quoted';
let double = "double-quoted";
let backticks = `backticks`;

-> Single and double quotes are essentially the same. Backticks, however, allow us to embed any expression into the string, by wrapping it in ${…}:
ex- 
function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.

-> Another advantage of using backticks is that they allow a string to span multiple lines:
let guestList = `Guests:
 * John
 * Pete
 * Mary
`;
alert(guestList); // a list of guests, multiple lines


Character	        Description
\n	                New line
\r	                In Windows text files a combination of two characters \r\n represents a new break, while on non-Windows OS it’s just \n. That’s for historical reasons, most Windows  software                also understands \n.
\', \"	                Quotes
\\	                Backslash
\t	                Tab
\b, \f, \v	        Backspace, Form Feed, Vertical Tab – kept for compatibility, not used nowadays.
\xXX	                Unicode character with the given hexadecimal Unicode XX, e.g. '\x7A' is the same as 'z'.
\uXXXX	                A Unicode symbol with the hex code XXXX in UTF-16 encoding, for instance \u00A9 – is a Unicode for the copyright symbol ©. It must be exactly 4 hex digits.
\u{X…XXXXXX} (1 to 6 hex characters)	A Unicode symbol with the given UTF-32 encoding. Some rare characters are encoded with two Unicode symbols, taking 4 bytes. This way we can insert long codes.

# Examples with Unicode:
alert( "\u00A9" ); // ©
alert( "\u{20331}" ); // 佫, a rare Chinese hieroglyph (long Unicode)
alert( "\u{1F60D}" ); // 😍, a smiling face symbol (another long Unicode)
All special characters start with a backslash character \. It is also called an “escape character”.
We might also use it if we wanted to insert a quote into the string.

For instance:
alert( 'I\'m the Walrus!' ); // I'm the Walrus!

Note that the backslash \ serves for the correct reading of the string by JavaScript, then disappears. The in-memory string has no \.

# String length:
The length property has the string length:
alert( `My\n`.length ); // 3
Note that \n is a single “special” character, so the length is indeed 3.

-> length is a property
People with a background in some other languages sometimes mistype by calling str.length() instead of just str.length. That doesn’t work.
Please note that str.length is a numeric property, not a function. There is no need to add parenthesis after it.

# Accessing characters
To get a character at position pos, use square brackets [pos] or call the method str.charAt(pos). 
The first character starts from the zero position
The square brackets are a modern way of getting a character, while charAt exists mostly for historical reasons.

The only difference between them is that if no character is found, [] returns undefined, and charAt returns an empty string:
ex let str = `Hello`;

alert( str[1000] ); // undefined
alert( str.charAt(1000) ); // '' (an empty string)

# We can also iterate over characters using for..of:

for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char becomes "H", then "e", then "l" etc)
}

# Strings are immutable
Strings can’t be changed in JavaScript. It is impossible to change a character.

The usual workaround is to create a whole new string and assign it to str instead of the old one.
let str = 'Hi';
str = 'h' + str[1]; // replace the string
alert( str ); // hi

Instead of this we can write as :
let str = 'Hi';
str = 'h' + str[1]; // replace the string
alert( str ); // hi

# Changing the case
Methods toLowerCase() and toUpperCase() change the case:
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface

Or, if we want a single character lowercased:
alert( 'Interface'[0].toLowerCase() ); // 'i'

# Searching for a substring
There are multiple ways to look for a substring within a string.

1. str.indexOf
The first method is str.indexOf(substr, pos).
It looks for the substr in str, starting from the given position pos, and returns the position where the match was found or -1 if nothing can be found.
let str = 'Widget with id';
alert( str.indexOf('Widget') ); // 0, because 'Widget' is found at the beginning
alert( str.indexOf('widget') ); // -1, not found, the search is case-sensitive
alert( str.indexOf("id") ); // 1, "id" is found at the position 1 (..idget with id)

The optional second parameter allows us to start searching from a given position.
For instance, the first occurrence of "id" is at position 1. To look for the next occurrence, let’s start the search from position 2
let str = 'Widget with id';
alert( str.indexOf('id', 2) ) // 12

If we’re interested in all occurrences, we can run indexOf in a loop. Every new call is made with the position after the previous match.
let str = "As sly as a fox, as strong as an ox";
let target = "as";
let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}

# str.lastIndexOf(substr, position)
There is also a similar method str.lastIndexOf(substr, position) that searches from the end of a string to its beginning.
It would list the occurrences in the reverse order.

So, we should actually check for -1, like this:
let str = "Widget with id";
if (str.indexOf("Widget") != -1) {
    alert("We found it"); // works now!
}

# The bitwise NOT trick:
One of the old tricks used here is the bitwise NOT ~ operator. It converts the number to a 32-bit integer (removes the decimal part if exists) and then reverses all bits in its binary representation.
In practice, that means a simple thing: for 32-bit integers ~n equals -(n+1).

For instance:
alert( ~2 ); // -3, the same as -(2+1)
alert( ~1 ); // -2, the same as -(1+1)
alert( ~-1 ); // 0, the same as -(-1+1)
As we can see, ~n is zero only if n == -1 (that’s for any 32-bit signed integer n).
So, the test if ( ~str.indexOf("...") ) is truthy only if the result of indexOf is not -1. In other words, when there is a match.
People use it to shorten indexOf checks:
let str = "Widget";
if (~str.indexOf("Widget")) {
  alert( 'Found it!' ); // works
}

# includes, startsWith, endsWith:
The more modern method str.includes(substr, pos) returns true/false depending on whether str contains substr within.
It’s the right choice if we need to test for the match, but don’t need its position.

alert( "Widget with id".includes("Widget") ); // true
alert( "Hello".includes("Bye") ); // false

-> The optional second argument of str.includes is the position to start searching from:
alert( "Widget".includes("id") ); // true
alert( "Widget".includes("id", 3) ); // false, from position 3 there is no "id"

-> The methods str.startsWith and str.endsWith do exactly what they say:
alert( "Widget".startsWith("Wid") ); // true, "Widget" starts with "Wid"
alert( "Widget".endsWith("get") ); // true, "Widget" ends with "get"


# Getting a substring
There are 3 methods in JavaScript to get a substring: substring, substr and slice.

1. str.slice(start [, end])
Returns the part of the string from start to (but not including) end.
For instance:
let str = "stringify";
alert( str.slice(0, 5) ); // 'strin', the substring from 0 to 5 (not including 5)
alert( str.slice(0, 1) ); // 's', from 0 to 1, but not including 1, so only character at 0

If there is no second argument, then slice goes till the end of the string:
let str = "stringify";
alert( str.slice(2) ); // 'ringify', from the 2nd position till the end

# Negative values for start/end are also possible. They mean the position is counted from the string end:
let str = "stringify";
// start at the 4th position from the right, end at the 1st from the right
alert( str.slice(-4, -1) ); // 'gif'

# str.substring(start [, end])
Returns the part of the string between start and end.
This is almost the same as slice, but it allows start to be greater than end.
Negative arguments are (unlike slice) not supported, they are treated as 0.

# str.substr(start [, length])
Returns the part of the string from start, with the given length.
In contrast with the previous methods, this one allows us to specify the length instead of the ending position

Let’s recap these methods to avoid any confusion:

method	                                selects…	              negatives
slice(start, end)	from start to end (not including end)	     allows negatives
substring(start, end)	between start and end	negative values mean      0
substr(start, length)	from start get length characters	      allows negative start

# Comparing strings
As we know from the chapter Comparisons, strings are compared character-by-character in alphabetical order

Although, there are some oddities.

1. A lowercase letter is always greater than the uppercase:
alert( 'a' > 'Z' ); // true

2. Letters with diacritical marks are “out of order”:
alert( 'Österreich' > 'Zealand' ); // true
This may lead to strange results if we sort these country names. Usually people would expect Zealand to come after Österreich in the list.

# str.codePointAt(pos)
Returns the code for the character at position pos:
// different case letters have different codes
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePointAt(0) ); // 90

# String.fromCodePoint(code)
Creates a character by its numeric code
alert( String.fromCodePoint(90) ); // Z
We can also add Unicode characters by their codes using \u followed by the hex code:
// 90 is 5a in hexadecimal system
alert( '\u005a' ); // Z

# Correct comparisons
The “right” algorithm to do string comparisons is more complex than it may seem, because alphabets are different for different languages

It provides a special method to compare strings in different languages, following their rules.

The call str.localeCompare(str2) returns an integer indicating whether str is less, equal or greater than str2 according to the language rules:
Returns a negative number if str is less than str2.
Returns a positive number if str is greater than str2.
Returns 0 if they are equivalent.

# Surrogate pairs
All frequently used characters have 2-byte codes. Letters in most european languages, numbers, and even most hieroglyphs, have a 2-byte representation.
But 2 bytes only allow 65536 combinations and that’s not enough for every possible symbol. So rare symbols are encoded with a pair of 2-byte characters called “a surrogate pair”.
The length of such symbols is 2.
alert( '𝒳'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X
alert( '😂'.length ); // 2, FACE WITH TEARS OF JOY
alert( '𩷶'.length ); // 2, a rare Chinese hieroglyph

We actually have a single symbol in each of the strings above, but the length shows a length of 2.
String.fromCodePoint and str.codePointAt are few rare methods that deal with surrogate pairs right.

# Diacritical marks and normalization:
In many languages, there are symbols that are composed of the base character with a mark above/under it.
For instance, the letter a can be the base character for: àáâäãåā.

For instance, if we have S followed by the special “dot above” character (code \u0307), it is shown as Ṡ.
alert( 'S\u0307' ); // Ṡ

For instance, if we append a character “dot below” (code \u0323), then we’ll have “S with dots above and below”: Ṩ.

For example:
alert( 'S\u0307\u0323' ); // Ṩ

There exists a “Unicode normalization” algorithm that brings each string to the single “normal” form.
It is implemented by str.normalize().
alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true

# Summary
There are 3 types of quotes. Backticks allow a string to span multiple lines and embed expressions ${…}.
Strings in JavaScript are encoded using UTF-16.
We can use special characters like \n and insert letters by their Unicode using \u....
To get a character, use: [].
To get a substring, use: slice or substring.
To lowercase/uppercase a string, use: toLowerCase/toUpperCase.
To look for a substring, use: indexOf, or includes/startsWith/endsWith for simple checks.
To compare strings according to the language, use: localeCompare, otherwise they are compared by character codes.
There are several other helpful methods in strings:
str.trim() – removes (“trims”) spaces from the beginning and end of the string.
str.repeat(n) – repeats the string n times
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Arrays
Objects allow you to store keyed collections of values.
There exists a special data structure named Array, to store ordered collections.

# Declaration
There are two syntaxes for creating an empty array:
let arr = new Array();
let arr = [];

Almost all the time, the second syntax is used. We can supply initial elements in the brackets:
let fruits = ["Apple", "Orange", "Plum"];
Array elements are numbered, starting with zero.

We can get an element by its number in square brackets:
let fruits = ["Apple", "Orange", "Plum"];
alert( fruits[0] ); // Apple
alert( fruits[1] ); // Orange
alert( fruits[2] ); // Plum

We can replace an element:
fruits[2] = 'Pear'; // now ["Apple", "Orange", "Pear"]

Or add a new one to the array:
fruits[3] = 'Lemon'; // now ["Apple", "Orange", "Pear", "Lemon"]

# The total count of the elements in the array is its length:
let fruits = ["Apple", "Orange", "Plum"];
alert( fruits.length ); // 3

We can also use alert to show the whole array.
let fruits = ["Apple", "Orange", "Plum"];
alert( fruits ); // Apple,Orange,Plum

# An array can store elements of any type.

For instance:
// mix of values
let arr = [ 'Apple', { name: 'John' }, true, function() { alert('hello'); } ];
// get the object at index 1 and then show its name
alert( arr[1].name ); // John
// get the function at index 3 and run it
arr[3](); // hello

# Trailing comma
An array, just like an object, may end with a comma:

let fruits = [
  "Apple",
  "Orange",
  "Plum",
];
The “trailing comma” style makes it easier to insert/remove items, because all lines become alike.

Get last elements with “at”

Let’s say we want the last element of the array.
Some programming languages allow to use negative indexes for the same purpose, like fruits[-1].
Although, in JavaScript it won’t work. The result will be undefined, because the index in square brackets is treated literally.

We can explicitly calculate the last element index and then access it: fruits[fruits.length - 1].
let fruits = ["Apple", "Orange", "Plum"];
alert( fruits[fruits.length-1] ); // Plum

Luckily, there’s a shorter syntax: fruits.at(-1):

let fruits = ["Apple", "Orange", "Plum"];
// same as fruits[fruits.length-1]
alert( fruits.at(-1) ); // Plum

In other words, arr.at(i):
is exactly the same as arr[i], if i >= 0.
for negative values of i, it steps back from the end of the array.

# Methods pop/push, shift/unshift
A queue is one of the most common uses of an array. In computer science, this means an ordered collection of elements which supports two operations:
push appends an element to the end.
shift get an element from the beginning, advancing the queue, so that the 2nd element becomes the 1st.
Arrays support both operations.
In practice we need it very often. For example, a queue of messages that need to be shown on-screen.

There’s another use case for arrays – the data structure named stack.
It supports two operations:
push adds an element to the end.
pop takes an element from the end.
So new elements are added or taken always from the “end”.
A stack is usually illustrated as a pack of cards: new cards are added to the top or taken from the top:
For stacks, the latest pushed item is received first, that’s also called LIFO (Last-In-First-Out) principle. For queues, we have FIFO (First-In-First-Out).
Arrays in JavaScript can work both as a queue and as a stack. They allow you to add/remove elements, both to/from the beginning or the end.
In computer science, the data structure that allows this, is called deque.

# Methods that work with the end of the array:
pop:
Extracts the last element of the array and returns it:
let fruits = ["Apple", "Orange", "Pear"];
alert( fruits.pop() ); // remove "Pear" and alert it
alert( fruits ); // Apple, Orange
Both fruits.pop() and fruits.at(-1) return the last element of the array, but fruits.pop() also modifies the array by removing it.

# push
Append the element to the end of the array:
let fruits = ["Apple", "Orange"];
fruits.push("Pear");
alert( fruits ); // Apple, Orange, Pear
The call fruits.push(...) is equal to fruits[fruits.length] = ...

# Methods that work with the beginning of the array:
shift
Extracts the first element of the array and returns it:
let fruits = ["Apple", "Orange", "Pear"];
alert( fruits.shift() ); // remove Apple and alert it
alert( fruits ); // Orange, Pear

# unshift
Add the element to the beginning of the array:
let fruits = ["Orange", "Pear"];
fruits.unshift('Apple');
alert( fruits ); // Apple, Orange, Pear

# Methods push and unshift can add multiple elements at once:
let fruits = ["Apple"];
fruits.push("Orange", "Peach");
fruits.unshift("Pineapple", "Lemon");
// ["Pineapple", "Lemon", "Apple", "Orange", "Peach"]
alert( fruits );

# Performance
Methods push/pop run fast, while shift/unshift are slow.

Why is it faster to work with the end of an array than with its beginning? Let’s see what happens during the execution:
fruits.shift(); // take 1 element from the start
It’s not enough to take and remove the element with the index 0. Other elements need to be renumbered as well.

The shift operation must do 3 things:
- Remove the element with the index 0.
- Move all elements to the left, renumber them from the index 1 to 0, from 2 to 1 and so on.
- Update the length property.
The more elements in the array, the more time to move them, more in-memory operations.

The similar thing happens with unshift: to add an element to the beginning of the array, we need first to move existing elements to the right, increasing their indexes.
And what’s with push/pop? They do not need to move anything. To extract an element from the end, the pop method cleans the index and shortens length.

# Loops
One of the oldest ways to cycle array items is the for loop over indexes:
let arr = ["Apple", "Orange", "Pear"];
for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}

# The simplest way to clear the array is: arr.length = 0;

# new Array()
There is one more syntax to create an array:
let arr = new Array("Apple", "Pear", "etc");

If new Array is called with a single argument which is a number, then it creates an array without items, but with the given length.

# Multidimensional arrays
Arrays can have items that are also arrays. We can use it for multidimensional arrays, for example to store matrices:

# toString
Arrays have their own implementation of toString method that returns a comma-separated list of elements.
let arr = [1, 2, 3];
alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true

# Arrays do not have Symbol.toPrimitive, neither a viable valueOf, they implement only toString conversion, so here [] becomes an empty string, [1] becomes "1" and [1,2] becomes "1,2".
When the binary plus "+" operator adds something to a string, it converts it to a string as well.

# Don’t compare arrays with ==
Arrays in JavaScript, unlike some other programming languages, shouldn’t be compared with operator ==.
This operator has no special treatment for arrays, it works with them as with any objects.

- Two objects are equal == only if they’re references to the same object.
- If one of the arguments of == is an object, and the other one is a primitive, then the object gets converted to primitive, as explained in the chapter Object to primitive conversion.
- …With an exception of null and undefined that equal == each other and nothing else.

# So, if we compare arrays with ==, they are never the same, unless we compare two variables that reference exactly the same array.

For example:
alert( [] == [] ); // false
alert( [0] == [0] ); // false
These arrays are technically different objects. So they aren’t equal. The == operator doesn’t do item-by-item comparison.

Comparison with primitives may give seemingly strange results as well:
alert( 0 == [] ); // true
alert('0' == [] ); // false

# Summary
Array is a special kind of object, suited to storing and managing ordered data items.

The declaration:
// square brackets (usual)
let arr = [item1, item2...];
// new Array (exceptionally rare)
let arr = new Array(item1, item2...);

The call to new Array(number) creates an array with the given length, but without elements.
The length property is the array length or, to be precise, its last numeric index plus one. It is auto-adjusted by array methods.
If we shorten length manually, the array is truncated.

Getting the elements:
we can get element by its index, like arr[0]
also we can use at(i) method that allows negative indexes. For negative values of i, it steps back from the end of the array. If i >= 0, it works same as arr[i].

We can use an array as a deque with the following operations:
push(...items) adds items to the end.
pop() removes the element from the end and returns it.
shift() removes the element from the beginning and returns it.
unshift(...items) adds items to the beginning.

To loop over the elements of the array:
for (let i=0; i<arr.length; i++) – works fastest, old-browser-compatible.
for (let item of arr) – the modern syntax for items only,
for (let i in arr) – never use.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Array methods:

-> Add/remove items
We already know methods that add and remove items from the beginning or the end:
arr.push(...items) – adds items to the end,
arr.pop() – extracts an item from the end,
arr.shift() – extracts an item from the beginning,
arr.unshift(...items) – adds items to the beginning.

# The arrays are objects, so we can try to use delete:
let arr = ["I", "go", "home"];
delete arr[1]; // remove "go"
alert( arr[1] ); // undefined
// now arr = ["I",  , "home"];
alert( arr.length ); // 3
The element was removed, but the array still has 3 elements, we can see that arr.length == 3.
That’s natural, because delete obj.key removes a value by the key. It’s all it does.

1. splice:
The arr.splice method is a swiss army knife for arrays. It can do everything: insert, remove and replace elements.

The syntax is:
arr.splice(start[, deleteCount, elem1, ..., elemN])
It modifies arr starting from the index start: removes deleteCount elements and then inserts elem1, ..., elemN at their place. Returns the array of removed elements.

The splice method is also able to insert the elements without any removals. For that we need to set deleteCount to 0

# Negative indexes allowed
Here and in other array methods, negative indexes are allowed. They specify the position from the end of the array, like here:

let arr = [1, 2, 5];
// from index -1 (one step from the end)
// delete 0 elements,
// then insert 3 and 4
arr.splice(-1, 0, 3, 4);
alert( arr ); // 1,2,3,4,5

2. slice
The method arr.slice is much simpler than similar-looking arr.splice.
The syntax is:
arr.slice([start], [end])
It returns a new array copying to it all items from index start to end (not including end). Both start and end can be negative, in that case position from array end is assumed.
It’s similar to a string method str.slice, but instead of substrings it makes subarrays.

let arr = ["t", "e", "s", "t"];
alert( arr.slice(1, 3) ); // e,s (copy from 1 to 3)
alert( arr.slice(-2) ); // s,t (copy from -2 till the end)

3. concat
The method arr.concat creates a new array that includes values from other arrays and additional items.
The syntax is:
arr.concat(arg1, arg2...)
It accepts any number of arguments – either arrays or values.
The result is a new array containing items from arr, then arg1, arg2 etc.
If an argument argN is an array, then all its elements are copied. Otherwise, the argument itself is copied.

# Iterate: forEach
The arr.forEach method allows to run a function for every element of the array.

The syntax:
arr.forEach(function(item, index, array) {
  // ... do something with item
});

# Searching in array
Now let’s cover methods that search in an array.

-> indexOf/lastIndexOf and includes
- arr.indexOf(item, from) – looks for item starting from index from, and returns the index where it was found, otherwise -1.
- arr.includes(item, from) – looks for item starting from index from, returns true if found.
Usually these methods are used with only one argument: the item to search. By default, the search is from the beginning.

let arr = [1, 0, false];
alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1
alert( arr.includes(1) ); // true

Please note that indexOf uses the strict equality === for comparison. So, if we look for false, it finds exactly false and not the zero.
If we want to check if item exists in the array, and don’t need the exact index, then arr.includes is preferred.
The method arr.lastIndexOf is the same as indexOf, but looks for from right to left.

# The includes method handles NaN correctly
A minor, but noteworthy feature of includes is that it correctly handles NaN, unlike indexOf:
const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (wrong, should be 0)
alert( arr.includes(NaN) );// true (correct)

# find and findIndex/findLastIndex:
The syntax is:
let result = arr.find(function(item, index, array) {
  // if true is returned, item is returned and iteration is stopped
  // for falsy scenario returns undefined
});

The function is called for elements of the array, one after another:
item is the element.
index is its index.
array is the array itself.
If it returns true, the search is stopped, the item is returned. If nothing found, undefined is returned.

The arr.findIndex method has the same syntax, but returns the index where the element was found instead of the element itself. The value of -1 is returned if nothing is found.
The arr.findLastIndex method is like findIndex, but searches from right to left, similar to lastIndexOf.

# filter
The find method looks for a single (first) element that makes the function return true.
If there may be many, we can use arr.filter(fn).

The syntax is similar to find, but filter returns an array of all matching elements:
let results = arr.filter(function(item, index, array) {
  // if true item is pushed to results and the iteration continues
  // returns empty array if nothing found
});

# Transform an array
Let’s move on to methods that transform and reorder an array.

-> map:
The arr.map method is one of the most useful and often used.
It calls the function for each element of the array and returns the array of results.

The syntax is:
let result = arr.map(function(item, index, array) {
  // returns the new value instead of item
});
For instance, here we transform each element into its length:
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6

-> sort(fn)
The call to arr.sort() sorts the array in place, changing its element order.
It also returns the sorted array, but the returned value is usually ignored, as arr itself is modified.
To use our own sorting order, we need to supply a function as the argument of arr.sort().

# Use localeCompare for strings
Remember strings comparison algorithm? It compares letters by their codes by default.
For many alphabets, it’s better to use str.localeCompare method to correctly sort letters, such as Ö.

-> reverse
The method arr.reverse reverses the order of elements in arr.

For instance:
let arr = [1, 2, 3, 4, 5];
arr.reverse();
alert( arr ); // 5,4,3,2,1
It also returns the array arr after the reversal.

# split and join:
The str.split(delim) method does exactly that. It splits the string into an array by the given delimiter delim.

Split into letters
The call to split(s) with an empty s would split the string into an array of letters:
let str = "test";
alert( str.split('') ); // t,e,s,t

The call arr.join(glue) does the reverse to split. It creates a string of arr items joined by glue between them.

For instance:
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];
let str = arr.join(';'); // glue the array into a string using ;
alert( str ); // Bilbo;Gandalf;Nazgul

-> reduce/reduceRight
When we need to iterate over an array – we can use forEach, for or for..of.
When we need to iterate and return the data for each element – we can use map.
The methods arr.reduce and arr.reduceRight also belong to that breed, but are a little bit more intricate. They are used to calculate a single value based on the array.

The syntax is:
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
The function is applied to all array elements one after another and “carries on” its result to the next call.

Arguments:
accumulator – is the result of the previous function call, equals initial the first time (if initial is provided).
item – is the current array item.
index – is its position.
array – is the array.
As function is applied, the result of the previous function call is passed to the next one as the first argument.
So, the first argument is essentially the accumulator that stores the combined result of all previous executions. And at the end it becomes the result of reduce.

# Array.isArray
Arrays do not form a separate language type. They are based on objects.
So typeof does not help to distinguish a plain object from an array:
alert(typeof {}); // object
alert(typeof []); // object (same)
…But arrays are used so often that there’s a special method for that: Array.isArray(value). It returns true if the value is an array, and false otherwise.
alert(Array.isArray({})); // false
alert(Array.isArray([])); // true

# Most methods support “thisArg”
Almost all array methods that call functions – like find, filter, map, with a notable exception of sort, accept an optional additional parameter thisArg.
Syntax:
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg is the optional last argument
The value of thisArg parameter becomes this for func.

Summary
A cheat sheet of array methods:

To add/remove elements:
push(...items) – adds items to the end,
pop() – extracts an item from the end,
shift() – extracts an item from the beginning,
unshift(...items) – adds items to the beginning.
splice(pos, deleteCount, ...items) – at index pos deletes deleteCount elements and inserts items.
slice(start, end) – creates a new array, copies elements from index start till end (not inclusive) into it.
concat(...items) – returns a new array: copies all members of the current one and adds items to it. If any of items is an array, then its elements are taken.

To search among elements:
indexOf/lastIndexOf(item, pos) – look for item starting from position pos, return the index or -1 if not found.
includes(value) – returns true if the array has value, otherwise false.
find/filter(func) – filter elements through the function, return first/all values that make it return true.
findIndex is like find, but returns the index instead of a value.

To iterate over elements:
forEach(func) – calls func for every element, does not return anything.

To transform the array:
map(func) – creates a new array from results of calling func for every element.
sort(func) – sorts the array in-place, then returns it.
reverse() – reverses the array in-place, then returns it.
split/join – convert a string to array and back.
reduce/reduceRight(func, initial) – calculate a single value over the array by calling func for each element and passing an intermediate result between the calls.

Additionally:
Array.isArray(value) checks value for being an array, if so returns true, otherwise false.
Please note that methods sort, reverse and splice modify the array itself.
These methods are the most used ones, they cover 99% of use cases. But there are few others:
arr.some(fn)/arr.every(fn) check the array.
The function fn is called on each element of the array similar to map. If any/all results are true, returns true, otherwise false.
These methods behave sort of like || and && operators: if fn returns a truthy value, arr.some() immediately returns true and stops iterating over the rest of items; if fn returns a falsy value, arr.every() immediately returns false and stops iterating over the rest of items as well.

We can use every to compare arrays:
function arraysEqual(arr1, arr2) {
  return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);
}
alert( arraysEqual([1, 2], [1, 2])); // true
arr.fill(value, start, end) – fills the array with repeating value from index start to end.
arr.copyWithin(target, start, end) – copies its elements from position start till position end into itself, at position target (overwrites existing).
arr.flat(depth)/arr.flatMap(fn) create a new flat array from a multidimensional array.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Date and time:
Let’s meet a new built-in object: Date. It stores the date, time and provides methods for date/time management.
For instance, we can use it to store creation/modification times, to measure time, or just to print out the current date.

Creation
To create a new Date object call new Date() with one of the following arguments:
new Date()
Without arguments – create a Date object for the current date and time.

# new Date(milliseconds)
Create a Date object with the time equal to number of milliseconds (1/1000 of a second) passed after the Jan 1st of 1970 UTC+0.

An integer number representing the number of milliseconds that has passed since the beginning of 1970 is called a timestamp.
It’s a lightweight numeric representation of a date. We can always create a date from a timestamp using new Date(timestamp) and convert the existing Date object to a timestamp using the date.getTime() method (see below).

# new Date(datestring)
If there is a single argument, and it’s a string, then it is parsed automatically. The algorithm is the same as Date.parse uses

# Access date components
There are methods to access the year, month and so on from the Date object:

getFullYear()
-Get the year (4 digits)
-
getMonth()
Get the month, from 0 to 11.

-getDate()
Get the day of month, from 1 to 31, the name of the method does look a little bit strange.
getHours(), getMinutes(), getSeconds(), getMilliseconds()
Get the corresponding time components.
Not getYear(), but getFullYear()
Many JavaScript engines implement a non-standard method getYear(). This method is deprecated. It returns 2-digit year sometimes. Please never use it. There is getFullYear() for the year.

Additionally, we can get a day of week:
-getDay()
Get the day of week, from 0 (Sunday) to 6 (Saturday). The first day is always Sunday, in some countries that’s not so, but can’t be changed.
All the methods above return the components relative to the local time zone.

Besides the given methods, there are two special ones that do not have a UTC-variant:
-getTime()
Returns the timestamp for the date – a number of milliseconds passed from the January 1st of 1970 UTC+0.

-getTimezoneOffset()
Returns the difference between UTC and the local time zone, in minutes:

# Setting date components
The following methods allow to set date/time components:
setFullYear(year, [month], [date])
setMonth(month, [date])
setDate(date)
setHours(hour, [min], [sec], [ms])
setMinutes(min, [sec], [ms])
setSeconds(sec, [ms])
setMilliseconds(ms)
setTime(milliseconds) (sets the whole date by milliseconds since 01.01.1970 UTC)

Every one of them except setTime() has a UTC-variant, for instance: setUTCHours()
let today = new Date();
today.setHours(0);
alert(today); // still today, but the hour is changed to 0
today.setHours(0, 0, 0, 0);
alert(today); // still today, now 00:00:00 sharp.

# Autocorrection
The autocorrection is a very handy feature of Date objects. We can set out-of-range values, and it will auto-adjust itself.

For instance:
let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ...is 1st Feb 2013!

# Date to number, date diff
When a Date object is converted to number, it becomes the timestamp same as date.getTime():
let date = new Date();
alert(+date); // the number of milliseconds, same as date.getTime()
The important side effect: dates can be subtracted, the result is their difference in ms.

# Date.now()
If we only want to measure time, we don’t need the Date oject.
There’s a special method Date.now() that returns the current timestamp.

# Benchmarking:
For instance, let’s measure two functions that calculate the difference between two dates: which one is faster?
Such performance measurements are often called “benchmarks”.

# Date.parse from a string
The method Date.parse(str) can read a date from a string.

The string format should be: YYYY-MM-DDTHH:mm:ss.sssZ, where:
YYYY-MM-DD – is the date: year-month-day.
The character "T" is used as the delimiter.
HH:mm:ss.sss – is the time: hours, minutes, seconds and milliseconds.
The optional 'Z' part denotes the time zone in the format +-hh:mm. A single letter Z would mean UTC+0.
Shorter variants are also possible, like YYYY-MM-DD or YYYY-MM or even YYYY.
The call to Date.parse(str) parses the string in the given format and returns the timestamp (number of milliseconds from 1 Jan 1970 UTC+0). If the format is invalid, returns NaN.

Date and time in JavaScript are represented with the Date object. We can’t create “only date” or “only time”: Date objects always carry both.
Months are counted from zero (yes, January is a zero month).
Days of week in getDay() are also counted from zero (that’s Sunday).
Date auto-corrects itself when out-of-range components are set. Good for adding/subtracting days/months/hours.
Dates can be subtracted, giving their difference in milliseconds. That’s because a Date becomes the timestamp when converted to a number.
Use Date.now() to get the current timestamp fast.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# JSON methods, toJSON:

-> JSON.stringify:
-JSON.stringify to convert objects into JSON.
-JSON.parse to convert JSON back into an object.

The method JSON.stringify(student) takes the object and converts it into a string.

JSON.stringify can be applied to primitives as well.
JSON supports following data types:
Objects { ... }
Arrays [ ... ]
Primitives:
strings,
numbers,
boolean values true/false,
null.

# Excluding and transforming: replacer
The full syntax of JSON.stringify is:
let json = JSON.stringify(value[, replacer, space])
value
A value to encode.
replacer
Array of properties to encode or a mapping function function(key, value).
space
Amount of space to use for formatting
Most of the time, JSON.stringify is used with the first argument only. But if we need to fine-tune the replacement process, like to filter out circular references, we can use the second argument of JSON.stringify.
If we pass an array of properties to it, only these properties will be encoded.

# Formatting spaces:
The third argument of JSON.stringify(value, replacer, space) is the number of spaces to use for pretty formatting.
Previously, all stringified objects had no indents and extra spaces.

# Custom “toJSON”:
Like toString for string conversion, an object may provide method toJSON for to-JSON conversion. JSON.stringify automatically calls it if available

# JSON.parse
To decode a JSON-string, we need another method named JSON.parse.

The syntax:
let value = JSON.parse(str, [reviver]);
str
JSON-string to parse.
reviver
Optional function(key,value) that will be called for each (key, value) pair and can transform the value.

JSON is a data format that has its own independent standard and libraries for most programming languages.
JSON supports plain objects, arrays, strings, numbers, booleans, and null.
JavaScript provides methods JSON.stringify to serialize into JSON and JSON.parse to read from JSON.
Both methods support transformer functions for smart reading/writing.
If an object has toJSON, then it is called by JSON.stringify.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Scheduling: setTimeout and setInterval:
There are two methods for it:

- setTimeout allows us to run a function once after the interval of time.
- setInterval allows us to run a function repeatedly, starting after the interval of time, then repeating continuously at that interval.

1. setTimeout
The syntax:
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)

Parameters:
func|code

Function or a string of code to execute. Usually, that’s a function. For historical reasons, a string of code can be passed, but that’s not recommended.

delay
The delay before run, in milliseconds (1000 ms = 1 second), by default 0.

arg1, arg2…
Arguments for the function (not supported in IE9-)

For instance, this code calls sayHi() after one second:
function sayHi() {
  alert('Hello');
}

setTimeout(sayHi, 1000);

# Canceling with clearTimeout
A call to setTimeout returns a “timer identifier” timerId that we can use to cancel the execution.

The syntax to cancel:
let timerId = setTimeout(...);
clearTimeout(timerId);

# setInterval
The setInterval method has the same syntax as setTimeout:
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)

All arguments have the same meaning. But unlike setTimeout it runs the function not only once, but regularly after the given interval of time.
To stop further calls, we should call clearInterval(timerId).

The following example will show the message every 2 seconds. After 5 seconds, the output is stopped:
// repeat with the interval of 2 seconds
let timerId = setInterval(() => alert('tick'), 2000);
// after 5 seconds stop
setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);

Note: Nested setTimeout allows to set the delay between the executions more precisely than setInterval.

# Zero delay setTimeout:
This schedules the execution of func as soon as possible. But the scheduler will invoke it only after the currently executing script is complete.
So the function is scheduled to run “right after” the current script.

For instance, this outputs “Hello”, then immediately “World”:
setTimeout(() => alert("World"));
alert("Hello");

- Methods setTimeout(func, delay, ...args) and setInterval(func, delay, ...args) allow us to run the func once/regularly after delay milliseconds.
- To cancel the execution, we should call clearTimeout/clearInterval with the value returned by setTimeout/setInterval.
- Nested setTimeout calls are a more flexible alternative to setInterval, allowing us to set the time between executions more precisely.
- Zero delay scheduling with setTimeout(func, 0) (the same as setTimeout(func)) is used to schedule the call “as soon as possible, but after the current script is complete”.
- The browser limits the minimal delay for five or more nested calls of setTimeout or for setInterval (after 5th call) to 4ms. That’s for historical reasons.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Property flags and descriptors:

# Property flags
Object properties, besides a value, have three special attributes (so-called “flags”):
writable – if true, the value can be changed, otherwise it’s read-only.
enumerable – if true, then listed in loops, otherwise not listed.
configurable – if true, the property can be deleted and these attributes can be modified, otherwise not.

The method Object.getOwnPropertyDescriptor allows to query the full information about a property.

The syntax is:
let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
obj
The object to get information from.
propertyName
The name of the property.
The returned value is a so-called “property descriptor” object: it contains the value and all the flags.

let user = {
  name: "John"
};
let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
alert( JSON.stringify(descriptor, null, 2 ) );

-> To change the flags, we can use Object.defineProperty.

The syntax is:
Object.defineProperty(obj, propertyName, descriptor)
obj, propertyName
The object and its property to apply the descriptor.
descriptor
Property descriptor object to apply.
If the property exists, defineProperty updates its flags. Otherwise, it creates the property with the given value and flags; in that case, if a flag is not supplied, it is assumed false.

For instance, here a property name is created with all falsy flags:
let user = {};
Object.defineProperty(user, "name", {
  value: "John"
});
let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
alert( JSON.stringify(descriptor, null, 2 ) );
/*
{
  "value": "John",
  "writable": false,
  "enumerable": false,
  "configurable": false
}
 */
 
 # Non-writable
Let’s make user.name non-writable (can’t be reassigned) by changing writable flag:
let user = {
  name: "John"
};
Object.defineProperty(user, "name", {
  writable: false
});
user.name = "Pete"; // Error: Cannot assign to read only property 'name'
Now no one can change the name of our user, unless they apply their own defineProperty to override ours.

# Object.defineProperties
There’s a method Object.defineProperties(obj, descriptors) that allows to define many properties at once.

The syntax is:
Object.defineProperties(obj, {
  prop1: descriptor1,
  prop2: descriptor2
  // ...
});

For instance:
Object.defineProperties(user, {
  name: { value: "John", writable: false },
  surname: { value: "Smith", writable: false },
  // ...
});


# Sealing an object globally
Property descriptors work at the level of individual properties.

There are also methods that limit access to the whole object:
-> Object.preventExtensions(obj)
Forbids the addition of new properties to the object.

-> Object.seal(obj)
Forbids adding/removing of properties. Sets configurable: false for all existing properties.

-> Object.freeze(obj)
Forbids adding/removing/changing of properties. Sets configurable: false, writable: false for all existing properties.
And also there are tests for them:

-> Object.isExtensible(obj)
Returns false if adding properties is forbidden, otherwise true.

-> Object.isSealed(obj)
Returns true if adding/removing properties is forbidden, and all existing properties have configurable: false.

-> Object.isFrozen(obj)
Returns true if adding/removing/changing properties is forbidden, and all current properties are configurable: false, writable: false.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Property getters and setters:

There are two kinds of object properties.
The first kind is data properties. We already know how to work with them. All properties that we’ve been using until now were data properties.
The second type of property is something new. It’s an accessor property. They are essentially functions that execute on getting and setting a value, but look like regular properties to an external code.

# Getters and setters
Accessor properties are represented by “getter” and “setter” methods. In an object literal they are denoted by get and set:

let obj = {
  get propName() {
    // getter, the code executed on getting obj.propName
  },

  set propName(value) {
    // setter, the code executed on setting obj.propName = value
  }
};
The getter works when obj.propName is read, the setter – when it is assigned.

# Accessor descriptors:
Descriptors for accessor properties are different from those for data properties.
For accessor properties, there is no value or writable, but instead there are get and set functions.

That is, an accessor descriptor may have:
get – a function without arguments, that works when a property is read,
set – a function with one argument, that is called when the property is set,
enumerable – same as for data properties,
configurable – same as for data properties.
For instance, to create an accessor fullName with defineProperty, we can pass a descriptor with get and set.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

