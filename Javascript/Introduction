# JAVASCRIPT:

JavaScript was initially created to “make web pages alive”.
The programs in this language are called scripts. They can be written right in a web page’s HTML and run automatically as the page loads.
Today, JavaScript can execute not only in the browser, but also on the server, or actually on any device that has a special program called the JavaScript engine.
The browser has an embedded engine sometimes called a “JavaScript virtual machine”.

Scripts are provided and executed as plain text. They don’t need special preparation or compilation to ru
JavaScript is an object-based scripting language which is lightweight and cross-platform.
JavaScript is not a compiled language, but it is a translated language. 
The JavaScript Translator (embedded in the browser) is responsible for translating the JavaScript code for the web browser.

JavaScript (js) is a light-weight object-oriented programming language which is used by several websites for scripting the webpages. 
It is an interpreted, full-fledged programming language that enables dynamic interactivity on websites when applied to an HTML document.

# There are following features of JavaScript:
All popular web browsers support JavaScript as they provide built-in execution environments.
JavaScript follows the syntax and structure of the C programming language. Thus, it is a structured programming language.
JavaScript is a weakly typed language, where certain types are implicitly cast (depending on the operation).
JavaScript is an object-oriented programming language that uses prototypes rather than using classes for inheritance.
It is a light-weighted and interpreted language.
It is a case-sensitive language.
JavaScript is supportable in several operating systems including, Windows, macOS, etc.
It provides good control to the users over the web browsers.

# JavaScript’s capabilities greatly depend on the environment it’s running in. For instance, Node.js supports functions that allow JavaScript to read/write arbitrary files, perform network requests, etc.
In-browser JavaScript can do everything related to webpage manipulation, interaction with the user, and the webserver.

For instance, in-browser JavaScript is able to:
Add new HTML to the page, change the existing content, modify styles.
React to user actions, run on mouse clicks, pointer movements, key presses.
Send requests over the network to remote servers, download and upload files (so-called AJAX and COMET technologies).
Get and set cookies, ask questions to the visitor, show messages.
Remember the data on the client-side (“local storage”).

# What CAN’T in-browser JavaScript do?
JavaScript on a webpage may not read/write arbitrary files on the hard disk, copy them or execute programs. It has no direct access to OS functions.
Different tabs/windows generally do not know about each other. Sometimes they do, for example when one window uses JavaScript to open the other one. 
But even in this case, JavaScript from one page may not access the other if they come from different sites (from a different domain, protocol or port).
This is called the “Same Origin Policy”. To work around that, both pages must agree for data exchange and contain a special JavaScript code that handles it.
Such limits do not exist if JavaScript is used outside of the browser, for example on a server. Modern browsers also allow plugin/extensions which may ask for extended permissions.

# What makes JavaScript unique?
There are at least three great things about JavaScript:

Full integration with HTML/CSS.
Simple things are done simply.
Supported by all major browsers and enabled by default.

JavaScript is the only browser technology that combines these three things.
JavaScript provides 3 places to put the JavaScript code: within body tag, within head tag and external JavaScript file.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Code editors:

A source-code editor is a text editor program designed specifically for editing source code of computer programs. 
It may be a standalone application or it may be built into an integrated development environment (IDE) or web browser
A code editor is the place where programmers spend most of their time.

There are two main types of code editors: 
IDEs and 
lightweight editors. 
Many people use one tool of each type.

# IDE:
An integrated development environment (IDE) is a software suite that consolidates basic tools required to write and test software.
An IDE typically contains a code editor, a compiler or interpreter, and a debugger, accessed through a single graphical user interface (GUI). 
The user writes and edits source code in the code editor. The compiler translates the source code into a readable language that is executable for a computer. And the debugger tests the software to solve any issues or bugs.
The term IDE (Integrated Development Environment) refers to a powerful editor with many features that usually operates on a “whole project.” 
As the name suggests, it’s not just an editor, but a full-scale “development environment.”

An IDE loads the project (which can be many files), allows navigation between files, provides autocompletion based on the whole project (not just the open file), and integrates with a version management system (like git), a testing environment, and other “project-level” stuff.

If you haven’t selected an IDE yet, consider the following options:
Visual Studio Code (cross-platform, free).
WebStorm (cross-platform, paid).
Netbeans

# Lightweight editors:
“Lightweight editors” are not as powerful as IDEs, but they’re fast, elegant and simple.
They are mainly used to open and edit a file instantly.
The main difference between a “lightweight editor” and an “IDE” is that an IDE works on a project-level, so it loads much more data on start, analyzes the project structure if needed and so on. A lightweight editor is much faster if we need only one file.
In practice, lightweight editors may have a lot of plugins including directory-level syntax analyzers and autocompleters, so there’s no strict border between a lightweight editor and an IDE.

The following options deserve your attention:
Sublime Text (cross-platform, shareware).
Notepad++ (Windows, free).
Vim and Emacs are also cool if you know how to use them.
Pycharm
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# The “script” tag:
JavaScript programs can be inserted almost anywhere into an HTML document using the <script> tag.
The <script> tag contains JavaScript code which is automatically executed when the browser processes the tag.

The <script> tag has a few attributes that are rarely used nowadays but can still be found in old code:
-The type attribute: <script type=…>
The old HTML standard, HTML4, required a script to have a type. Usually it was type="text/javascript". It’s not required anymore.

-The language attribute: <script language=…>
This attribute was meant to show the language of the script. This attribute no longer makes sense because JavaScript is the default language. There is no need to use it.

# External scripts
If we have a lot of JavaScript code, we can put it into a separate file.

Script files are attached to HTML with the src attribute:
<script src="/path/to/script.js"></script>
Here, /path/to/script.js is an absolute path to the script from the site root. One can also provide a relative path from the current page. 
For instance, src="script.js", just like src="./script.js", would mean a file "script.js" in the current folder.

Note: If src is set, the script content is ignored.
A single <script> tag can’t have both the src attribute and code inside.
We must choose either an external <script src="…"> or a regular <script> with code.

The example above can be split into two scripts to work:

<script src="file.js"></script>
<script>
  alert(1);
</script>

We can use a <script> tag to add JavaScript code to a page.
The type and language attributes are not required.
A script in an external file can be inserted with <script src="path/to/script.js"></script>.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Code structure:
The first thing we’ll study is the building blocks of code.

# Statements
Statements are syntax constructs and commands that perform actions.
We’ve already seen a statement, alert('Hello, world!'), which shows the message “Hello, world!”.
We can have as many statements in our code as we want. Statements can be separated with a semicolon.

Usually, statements are written on separate lines to make the code more readable:
alert('Hello');
alert('World');

# Semicolons
A semicolon may be omitted in most cases when a line break exists.

This would also work:
alert('Hello')
alert('World')

Here, JavaScript interprets the line break as an “implicit” semicolon. This is called an automatic semicolon insertion.

In most cases, a newline implies a semicolon. But “in most cases” does not mean “always”!

There are cases when a newline does not mean a semicolon. For example:

alert(3 +
1
+ 2);
The code outputs 6 because JavaScript does not insert semicolons here.

# But there are situations where JavaScript “fails” to assume a semicolon where it is really needed.
alert("Hello");
[1, 2].forEach(alert);
No need to think about the meaning of the brackets [] and forEach yet. We’ll study them later. For now, just remember the result of running the code: it shows Hello, then 1, then 2.

Now let’s remove the semicolon after the alert:
alert("Hello")
[1, 2].forEach(alert);
The difference compared to the code above is only one character: the semicolon at the end of the first line is gone.
If we run this code, only the first Hello shows (and there’s an error, you may need to open the console to see it). There are no numbers any more.
That’s because JavaScript does not assume a semicolon before square brackets [...]. So, the code in the last example is treated as a single statement.

Here’s how the engine sees it:
alert("Hello")[1, 2].forEach(alert);

# Comments:
Comments can be put into any place of a script. They don’t affect its execution because the engine simply ignores them.

-One-line comments start with two forward slash characters //.
The rest of the line is a comment. It may occupy a full line of its own or follow a statement.

-Multiline comments start with a forward slash and an asterisk /* and end with an asterisk and a forward slash */.
Like this:
/* An example with two messages.
This is a multiline comment.
*/
alert('Hello');
alert('World');

Note: The content of comments is ignored, so if we put code inside /* … */, it won’t execute.

Note: Nested comments are not supported!
There may not be /*...*/ inside another /*...*/.

Such code will die with an error:

/*
  /* nested comment ?!? */
*/
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# "use strict":
The purpose of "use strict" is to indicate that the code should be executed in "strict mode".
With strict mode, you can not, for example, use undeclared variables.

You can use strict mode in all your programs. It helps you to write cleaner code, like preventing you from using undeclared variables.
"use strict" is just a string, so IE 9 will not throw an error even if it does not understand it.

# Declaring Strict Mode
Strict mode is declared by adding "use strict"; to the beginning of a script or a function.
Declared at the beginning of a script, it has global scope (all code in the script will execute in strict mode):

Ex- "use strict";
x = 3.14;       // This will cause an error because x is not declared

Declared inside a function, it has local scope (only the code inside the function is in strict mode):
x = 3.14;       // This will not cause an error.
myFunction();

function myFunction() {
  "use strict";
  y = 3.14;   // This will cause an error
}

# Why Strict Mode?
Strict mode makes it easier to write "secure" JavaScript.
Strict mode changes previously accepted "bad syntax" into real errors.
As an example, in normal JavaScript, mistyping a variable name creates a new global variable. In strict mode, this will throw an error, making it impossible to accidentally create a global variable.
In normal JavaScript, a developer will not receive any error feedback assigning values to non-writable properties.
In strict mode, any assignment to a non-writable property, a getter-only property, a non-existing property, a non-existing variable, or a non-existing object, will throw an error.

# Things not Allowed in Strict Mode:
1.Using a variable, without declaring it, is not allowed:
"use strict";
x = 3.14;                // This will cause an error

2.Objects are variables too.
Using an object, without declaring it, is not allowed:

"use strict";
x = {p1:10, p2:20};      // This will cause an error

3.Deleting a variable (or object) is not allowed.

"use strict";
let x = 3.14;
delete x;                // This will cause an error

4.Deleting a function is not allowed.

"use strict";
function x(p1, p2) {};
delete x;                // This will cause an error 

5.Duplicating a parameter name is not allowed:

"use strict";
function x(p1, p1) {};   // This will cause an error

6.Octal numeric literals are not allowed:

"use strict";
let x = 010;             // This will cause an error

7.Octal escape characters are not allowed:

"use strict";
let x = "\010";            // This will cause an error

8.Writing to a read-only property is not allowed:
The readOnly property sets or returns whether a text field is read-only, or not
"use strict";
const obj = {};
Object.defineProperty(obj, "x", {value:0, writable:false});

obj.x = 3.14;            // This will cause an error

Note: Ensure that “use strict” is at the top
Please make sure that "use strict" is at the top of your scripts, otherwise strict mode may not be enabled.
There’s no way to cancel use strict

There is no directive like "no use strict" that reverts the engine to old behavior.
Once we enter strict mode, there’s no going back.

Modern JavaScript supports “classes” and “modules.So we don’t need to add the "use strict" directive, if we use them.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Variables:
Variables are used to store this information.
A variable is a “named storage” for data. We can use variables to store goodies, visitors, and other data.
To create a variable in JavaScript, use the let keyword.

# 4 Ways to Declare a JavaScript Variable:
Using var
Using let
Using const
Using nothing

The statement below creates (in other words: declares) a variable with the name “message”:
let message;

Now, we can put some data into it by using the assignment operator =:
let message;
message = 'Hello'; // store the string 'Hello' in the variable named message

We can also declare multiple variables in one line:
let user = 'John', age = 25, message = 'Hello';

Some people also define multiple variables in this multiline style:
let user = 'John',
  age = 25,
  message = 'Hello';

Or even in the “comma-first” style:
let user = 'John'
  , age = 25
  , message = 'Hello';
  
When the value is changed, the old data is removed from the variable:
let message;
message = 'Hello!';
message = 'World!'; // value changed
alert(message);

We can also declare two variables and copy data from one into the other.

Note: Declaring twice triggers an error
A variable should be declared only once.
A repeated declaration of the same variable is an error

# Variable naming
There are two limitations on variable names in JavaScript:
-The name must contain only letters, digits, or the symbols $ and _.
-The first character must not be a digit.

Examples of valid names:
let userName;
let test123;

Note: the dollar sign '$' and the underscore '_' can also be used in names. They are regular symbols, just like letters, without any special meaning.
let $ = 1; // declared a variable with the name "$"
let _ = 2; // and now a variable with the name "_"
alert($ + _); // 3

# Examples of incorrect variable names:
let 1a; // cannot start with a digit
let my-name; // hyphens '-' aren't allowed in the name

# Case matters
Variables named apple and APPLE are two different variables.

# Non-Latin letters are allowed, but not recommended
It is possible to use any language, including cyrillic letters or even hieroglyphs, like this:
let имя = '...';
let 我 = '...';

# Reserved names
There is a list of reserved words, which cannot be used as variable names because they are used by the language itself.
For example: let, class, return, and function are reserved.

The code below gives a syntax error:
let let = 5; // can't name a variable "let", error!
let return = 5; // also can't name it "return", error!

# An assignment without use strict.
// note: no "use strict" in this example
num = 5; // the variable "num" is created if it didn't exist
alert(num); // 5

This is a bad practice and would cause an error in strict mode:
"use strict";
num = 5; // error: num is not defined

# Constants
To declare a constant (unchanging) variable, use const instead of let:
const myBirthday = '18.04.1982';

Variables declared using const are called “constants”. They cannot be reassigned. An attempt to do so would cause an error:
const myBirthday = '18.04.1982';
myBirthday = '01.01.2001'; // error, can't reassign the constant!

When a programmer is sure that a variable will never change, they can declare it with const to guarantee and clearly communicate that fact to everyone.

Use const when you declare:
A new Array
A new Object
A new Function
A new RegExp

const – is like let, but the value of the variable can’t be changed.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Data types
A value in JavaScript is always of a certain type. For example, a string or a number.
There are eight basic data types in JavaScript. 

There are eight basic data types in JavaScript. They are:

Data Types	 Description	                                          Example
String	       represents textual data	                     'hello', "hello world!" etc
Number	     an integer or a floating-point number	              3, 3.234, 3e-2 etc.
BigInt	     an integer with arbitrary precision	              900719925124740999n , 1n etc.
Boolean      Any of two values: true or false	                      true and false
undefined    a data type whose variable is not initialized	       let a;
null	     denotes a null value	                              let a = null;
Symbol	     data type whose instances are unique and immutable      let value = Symbol('hello');
Object	     key-value pairs of collection of data	               let student = { };


# JavaScript String:
String is used to store text. In JavaScript, strings are surrounded by quotes:

Single quotes: 'Hello'
Double quotes: "Hello"
Backticks: `Hello`

Example:
//strings example
const name = 'ram';
const name1 = "hari";
const result = `The names are ${name} and ${name1}`;
Single quotes and double quotes are practically the same and you can use either of them.

Backticks are generally used when you need to include variables or expressions into a string. This is done by wrapping variables or expressions with ${variable or expression}

# JavaScript Number
Number represents integer and floating numbers (decimals and exponentials). For example,

const number1 = 3;
const number2 = 3.433;
const number3 = 3e5 // 3 * 10^5
A number type can also be +Infinity, -Infinity, and NaN (not a number). For example,

const number1 = 3/0;
console.log(number1); // Infinity

const number2 = -3/0;
console.log(number2); // -Infinity

// strings can't be divided by numbers
const number3 = "abc"/3; 
console.log(number3);  // NaN

# JavaScript BigInt
In JavaScript, Number type can only represent numbers less than (253 - 1) and more than -(253 - 1). However, if you need to use a larger number than that, you can use the BigInt data type.

A BigInt number is created by appending n to the end of an integer. For example,

// BigInt value
const value1 = 900719925124740998n;

// Adding two big integers
const result1 = value1 + 1n;
console.log(result1); // "900719925124740999n"

const value2 = 900719925124740998n;

// Error! BitInt and number cannot be added
const result2 = value2 + 1; 
console.log(result2); 
Output:
900719925124740999n
Uncaught TypeError: Cannot mix BigInt and other types

# JavaScript Boolean
This data type represents logical entities. Boolean represents one of two values: true or false. It is easier to think of it as a yes/no switch. For example,
const dataChecked = true;
const valueCounted = false;

# JavaScript undefined
The undefined data type represents value that is not assigned. If a variable is declared but the value is not assigned, then the value of that variable will be undefined. For example,

let name;
console.log(name); // undefined
Run Code
It is also possible to explicitly assign a variable value undefined. For example,

let name = undefined;
console.log(name); // undefined

Note: It is recommended not to explicitly assign undefined to a variable. Usually, null is used to assign 'unknown' or 'empty' value to a variable.

# JavaScript null
In JavaScript, null is a special value that represents empty or unknown value. For example,

const number = null;
The code above suggests that the number variable is empty.

Note: null is not the same as NULL or Null.

# JavaScript Symbol
This data type was introduced in a newer version of JavaScript (from ES2015).

A value having the data type Symbol can be referred to as a symbol value. Symbol is an immutable primitive value that is unique. For example,

// two symbols with the same description

const value1 = Symbol('hello');
const value2 = Symbol('hello');
Though value1 and value2 both contain 'hello', they are different as they are of the Symbol type.

# JavaScript Object
An object is a complex data type that allows us to store collections of data. For example,

const student = {
    firstName: 'ram',
    lastName: null,
    class: 10
};

# JavaScript Type
JavaScript is a dynamically typed (loosely typed) language. JavaScript automatically determines the variables' data type for you.
It also means that a variable can be of one data type and later it can be changed to another data type. For example,

// data is of undefined type
let data;

// data is of integer type
data = 5;

// data is of string type
data = "JavaScript Programming";

# JavaScript typeof
To find the type of a variable, you can use the typeof operator. For example,

const name = 'ram';
typeof(name); // returns "string"

const number = 4;
typeof(number); //returns "number"

const valueChecked = true;
typeof(valueChecked); //returns "boolean"

const a = null;
typeof(a); // returns "object"
Notice that typeof returned "object" for the null type.


There are 8 basic data types in JavaScript.
Seven primitive data types:
number for numbers of any kind: integer or floating-point, integers are limited by ±(253-1).
bigint for integer numbers of arbitrary length.
string for strings. A string may have zero or more characters, there’s no separate single-character type.
boolean for true/false.
null for unknown values – a standalone type that has a single value null.
undefined for unassigned values – a standalone type that has a single value undefined.
symbol for unique identifiers.
And one non-primitive data type:
object for more complex data structures.
The typeof operator allows us to see which type is stored in a variable.

Usually used as typeof x, but typeof(x) is also possible.
Returns a string with the name of the type, like "string".
For null returns "object" – this is an error in the language, it’s not actually an object.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Interaction: alert, prompt, confirm:
As we’ll be using the browser as our demo environment, let’s see a couple of functions to interact with the user: alert, prompt and confirm.

# alert
This one we’ve seen already. It shows a message and waits for the user to press “OK”.

For example:
alert("Hello");

The mini-window with the message is called a modal window. The word “modal” means that the visitor can’t interact with the rest of the page, press other buttons, etc, until they have dealt with the window. In this case – until they press “OK”.

# prompt
The function prompt accepts two arguments:
result = prompt(title, [default]);

It shows a modal window with a text message, an input field for the visitor, and the buttons OK/Cancel.

-title
The text to show the visitor.

-default
An optional second parameter, the initial value for the input field.

The square brackets in syntax [...]
The square brackets around default in the syntax above denote that the parameter is optional, not required.
The visitor can type something in the prompt input field and press OK. Then we get that text in the result. Or they can cancel the input by pressing Cancel or hitting the Esc key, then we get null as the result.

The call to prompt returns the text from the input field or null if the input was canceled.
For instance:
let age = prompt('How old are you?', 100);
alert(`You are ${age} years old!`); // You are 100 years old!

# confirm
The syntax:

result = confirm(question);
The function confirm shows a modal window with a question and two buttons: OK and Cancel.
The result is true if OK is pressed and false otherwise.

For example:
let isBoss = confirm("Are you the boss?");
alert( isBoss ); // true if OK is pressed

We covered 3 browser-specific functions to interact with visitors:
1. alert
shows a message.

2. prompt
shows a message asking the user to input text. It returns the text or, if Cancel button or Esc is clicked, null.

3. confirm
shows a message and waits for the user to press “OK” or “Cancel”. It returns true for OK and false for Cancel/Esc.

All these methods are modal: they pause script execution and don’t allow the visitor to interact with the rest of the page until the window has been dismissed.

There are two limitations shared by all the methods above:
The exact location of the modal window is determined by the browser. Usually, it’s in the center.
The exact look of the window also depends on the browser. We can’t modify it.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Type Conversions:

The three most widely used type conversions are to string, to number, and to boolean.

1.String Conversion – Occurs when we output something. Can be performed with String(value). The conversion to string is usually obvious for primitive values.
value = String(value); // now value is a string "true"
alert(typeof value); // string

2.Numeric Conversion – Occurs in math operations. Can be performed with Number(value).

The conversion follows the rules:
let str = "123";
alert(typeof str); // string
let num = Number(str); // becomes a number 123
alert(typeof num); // number

Value	                               Becomes…
undefined	                         NaN
null	                                  0
true / false	                        1 / 0
string	                               The string is read “as is”, whitespaces from both sides are ignored. An empty string becomes 0. An error gives NaN.

3.Boolean Conversion –Occurs in logical operations. Can be performed with Boolean(value).
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("hello") ); // true
alert( Boolean("") ); // false

Follows the rules:
Value
0, null, undefined, NaN, ""
any other value	

Most of these rules are easy to understand and memorize. The notable exceptions where people usually make mistakes are:
-undefined is NaN as a number, not 0.
-"0" and space-only strings like " " are true as a boolean.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Basic operators, maths:
An operand – is what operators are applied to. For instance, in the multiplication of 5 * 2 there are two operands: the left operand is 5 and the right operand is 2. Sometimes, people call these “arguments” instead of “operands”.

An operator is unary if it has a single operand. For example, the unary negation - reverses the sign of a number:
let x = 1;

x = -x;
alert( x ); // -1, unary negation was applied
An operator is binary if it has two operands. The same minus exists in binary form as well:

let x = 1, y = 3;
alert( y - x ); // 2, binary minus subtracts values
Formally, in the examples above we have two different operators that share the same symbol: the negation operator, a unary operator that reverses the sign, and the subtraction operator, a binary operator that subtracts one number from another.

# Maths
The following math operations are supported:
Addition +,
Subtraction -,
Multiplication *,
Division /,
Remainder %,
Exponentiation **

1. Remainder %
The remainder operator %, despite its appearance, is not related to percents.
The result of a % b is the remainder of the integer division of a by b.
For instance:
alert( 5 % 2 ); // 1, a remainder of 5 divided by 2
alert( 8 % 3 ); // 2, a remainder of 8 divided by 3

2. Exponentiation **
The exponentiation operator a ** b raises a to the power of b.
For instance:
alert( 2 ** 2 ); // 2² = 4
alert( 2 ** 3 ); // 2³ = 8
alert( 2 ** 4 ); // 2⁴ = 16
Just like in maths, the exponentiation operator is defined for non-integer numbers as well.

For example, a square root is an exponentiation by ½:
alert( 4 ** (1/2) ); // 2 (power of 1/2 is the same as a square root)
alert( 8 ** (1/3) ); // 2 (power of 1/3 is the same as a cubic root)

3. String concatenation with binary +
But, if the binary + is applied to strings, it merges (concatenates) them:

let s = "my" + "string";
alert(s); // mystring
Note that if any of the operands is a string, then the other one is converted to a string too.

For example:
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
See, it doesn’t matter whether the first operand is a string or the second one.

Here’s a more complex example:
alert(2 + 2 + '1' ); // "41" and not "221"

Here, operators work one after another. The first + sums two numbers, so it returns 4, then the next + adds the string 1 to it, so it’s like 4 + '1' = '41'.
alert('1' + 2 + 2); // "122" and not "14"
Here, the first operand is a string, the compiler treats the other two operands as strings too. The 2 gets concatenated to '1', so it’s like '1' + 2 = "12" and "12" + 2 = "122".
The binary + is the only operator that supports strings in such a way. Other arithmetic operators work only with numbers and always convert their operands to numbers.

Here’s the demo for subtraction and division:
alert( 6 - '2' ); // 4, converts '2' to a number
alert( '6' / '2' ); // 3, converts both operands to numbers

4. Numeric conversion, unary +
The plus + exists in two forms: the binary form that we used above and the unary form.
The unary plus or, in other words, the plus operator + applied to a single value, doesn’t do anything to numbers. But if the operand is not a number, the unary plus converts it into a number.

For example:
// No effect on numbers
let x = 1;
alert( +x ); // 1
let y = -2;
alert( +y ); // -2
// Converts non-numbers
alert( +true ); // 1
alert( +"" );   // 0

The need to convert strings to numbers arises very often. For example, if we are getting values from HTML form fields, they are usually strings. What if we want to sum them?

The binary plus would add them as strings:
let apples = "2";
let oranges = "3";
alert( apples + oranges ); // "23", the binary plus concatenates strings
If we want to treat them as numbers, we need to convert and then sum them:

let apples = "2";
let oranges = "3";
// both values converted to numbers before the binary plus
alert( +apples + +oranges ); // 5


# Operator precedence
If an expression has more than one operator, the execution order is defined by their precedence, or, in other words, the default priority order of operators.
Precedence	Name	      Sign
…	         …	        …
15	     unary plus	+
15	     unary negation	-
14	    exponentiation	**
13	    multiplication	*
13	    division	        /
12	    addition	        +
12	   subtraction	        -
…	      …	        … 
2	   assignment	        =
…	…	…
As we can see, the “unary plus” has a priority of 15 which is higher than the 12 of “addition” (binary plus). That’s why, in the expression "+apples + +oranges", unary pluses work before the addition.

5. Assignment
Let’s note that an assignment = is also an operator. It is listed in the precedence table with the very low priority of 2.
That’s why, when we assign a variable, like x = 2 * 2 + 1, the calculations are done first and then the = is evaluated, storing the result in x.
let x = 2 * 2 + 1;
alert( x ); // 5

Assignment = returns a value
All operators in JavaScript return a value. That’s obvious for + and -, but also true for =.
The call x = value writes the value into x and then returns it.

let a = 1;
let b = 2;
let c = 3 - (a = b + 1);
alert( a ); // 3
alert( c ); // 0
In the example above, the result of expression (a = b + 1) is the value which was assigned to a (that is 3).

-Chaining assignments:
let a, b, c;
a = b = c = 2 + 2;
alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
Chained assignments evaluate from right to left. First, the rightmost expression 2 + 2 is evaluated and then assigned to the variables on the left: c, b and a. At the end, all the variables share a single value.

# Modify-in-place
We often need to apply an operator to a variable and store the new result in that same variable.
let n = 2;
n = n + 5;
n = n * 2;
This notation can be shortened using the operators += and *=:
let n = 2;
n += 5; // now n = 7 (same as n = n + 5)
n *= 2; // now n = 14 (same as n = n * 2)
alert( n ); // 14

6. Increment/decrement
Increasing or decreasing a number by one is among the most common numerical operations.
So, there are special operators for it:

Increment ++ increases a variable by 1:
let counter = 2;
counter++;        // works the same as counter = counter + 1, but is shorter
alert( counter ); // 3

Decrement -- decreases a variable by 1:
let counter = 2;
counter--;        // works the same as counter = counter - 1, but is shorter
alert( counter ); // 1

Important:
Increment/decrement can only be applied to variables. Trying to use it on a value like 5++ will give an error.
The operators ++ and -- can be placed either before or after a variable.
When the operator goes after the variable, it is in “postfix form”: counter++.
The “prefix form” is when the operator goes before the variable: ++counter.
Both of these statements do the same thing: increase counter by 1.


Increment/decrement among other operators
The operators ++/-- can be used inside expressions as well. Their precedence is higher than most other arithmetical operations.

For instance:
let counter = 1;
alert( 2 * ++counter ); // 4
Compare with:
let counter = 1;
alert( 2 * counter++ ); // 2, because counter++ returns the "old" value.

7. Bitwise operators
Bitwise operators treat arguments as 32-bit integer numbers and work on the level of their binary representation.
These operators are not JavaScript-specific. They are supported in most programming languages.

The list of operators:
AND ( & )
OR ( | )
XOR ( ^ )
NOT ( ~ )
LEFT SHIFT ( << )
RIGHT SHIFT ( >> )
ZERO-FILL RIGHT SHIFT ( >>> )

Comma
The comma operator , is one of the rarest and most unusual operators.
For example:
let a = (1 + 2, 3 + 4);
alert( a ); // 7 (the result of 3 + 4)
Here, the first expression 1 + 2 is evaluated and its result is thrown away. Then, 3 + 4 is evaluated and returned as the result.

Comma has a very low precedence
Please note that the comma operator has very low precedence, lower than =, so parentheses are important in the example above.
Without them: a = 1 + 2, 3 + 4 evaluates + first, summing the numbers into a = 3, 7, then the assignment operator = assigns a = 3, and the rest is ignored. It’s like (a = 1 + 2), 3 + 4.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Comparisons:
We know many comparison operators from maths.
In JavaScript they are written like this:
Greater/less than: a > b, a < b.
Greater/less than or equals: a >= b, a <= b.
Equals: a == b, please note the double equality sign == means the equality test, while a single one a = b means an assignment.
Not equals: In maths the notation is ≠, but in JavaScript it’s written as a != b.

Boolean is the result
All comparison operators return a boolean value:
true – means “yes”, “correct” or “the truth”.
false – means “no”, “wrong” or “not the truth”.

For example:
alert( 2 > 1 );  // true (correct)
alert( 2 == 1 ); // false (wrong)
alert( 2 != 1 ); // true (correct)

A comparison result can be assigned to a variable, just like any value:
let result = 5 > 4; // assign the result of the comparison
alert( result ); // true

# String comparison:
To see whether a string is greater than another, JavaScript uses the so-called “dictionary” or “lexicographical” order.
In other words, strings are compared letter-by-letter.

The algorithm to compare two strings is simple:
1.Compare the first character of both strings.
2.If the first character from the first string is greater (or less) than the other string’s, then the first string is greater (or less) than the second. We’re done.
3.Otherwise, if both strings’ first characters are the same, compare the second characters the same way.
4.Repeat until the end of either string.
5.If both strings end at the same length, then they are equal. Otherwise, the longer string is greater.

alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
In the first example above, the comparison 'Z' > 'A' gets to a result at the first step.
The second comparison 'Glow' and 'Glee' needs more steps as strings are compared character-by-character:
G is the same as G.
l is the same as l.
o is greater than e. Stop here. The first string is greater.

# Comparison of different types
When comparing values of different types, JavaScript converts the values to numbers.

For example:
alert( '2' > 1 ); // true, string '2' becomes a number 2
alert( '01' == 1 ); // true, string '01' becomes a number 1
For boolean values, true becomes 1 and false becomes 0.

For example:
alert( true == 1 ); // true
alert( false == 0 ); // true

Note: It is possible that at the same time:

Two values are equal.
One of them is true as a boolean and the other one is false as a boolean.
For example:
let a = 0;
alert( Boolean(a) ); // false
let b = "0";
alert( Boolean(b) ); // true
alert(a == b); // true!

From JavaScript’s standpoint, this result is quite normal. An equality check converts values using the numeric conversion (hence "0" becomes 0), while the explicit Boolean conversion uses another set of rules.

# Strict equality
A regular equality check == has a problem. It cannot differentiate 0 from false:
alert( 0 == false ); // true
The same thing happens with an empty string:
alert( '' == false ); // true
This happens because operands of different types are converted to numbers by the equality operator ==. An empty string, just like false, becomes a zero.

A strict equality operator === checks the equality without type conversion.
In other words, if a and b are of different types, then a === b immediately returns false without an attempt to convert them.

# Comparison with null and undefined
For a strict equality check ===
These values are different, because each of them is a different type.
alert( null === undefined ); // false

For a non-strict check ==
There’s a special rule. These two are a “sweet couple”: they equal each other (in the sense of ==), but not any other value.
alert( null == undefined ); // true
For maths and other comparisons < > <= >=
null/undefined are converted to numbers: null becomes 0, while undefined becomes NaN.

# Strange result: null vs 0:
alert( null > 0 );  // (1) false
The reason is that an equality check == and comparisons > < >= <= work differently. 
Comparisons convert null to a number, treating it as 0. That’s why (3) null >= 0 is true and (1) null > 0 is false.
On the other hand, the equality check == for undefined and null is defined such that, without any conversions, they equal each other and don’t equal anything else. That’s why (2) null == 0 is false.

# An incomparable undefined
The value undefined shouldn’t be compared to other values:
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
We get these results because:
Comparisons (1) and (2) return false because undefined gets converted to NaN and NaN is a special numeric value which returns false for all comparisons.
The equality check (3) returns false because undefined only equals null, undefined, and no other value.

-Comparison operators return a boolean value.
-Strings are compared letter-by-letter in the “dictionary” order.
-When values of different types are compared, they get converted to numbers (with the exclusion of a strict equality check).
-The values null and undefined equal == each other and do not equal any other value.
-Be careful when using comparisons like > or < with variables that can occasionally be null/undefined. Checking for null/undefined separately is a good idea.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Conditional branching: if, '?'
Sometimes, we need to perform different actions based on different conditions.
To do that, we can use the if statement and the conditional operator ?, that’s also called a “question mark” operator.

# The “if” statement
The if(...) statement evaluates a condition in parentheses and, if the result is true, executes a block of code.

For example:
let year = prompt('In which year was ECMAScript-2015 specification published?', '');
if (year == 2015) alert( 'You are right!' );
In the example above, the condition is a simple equality check (year == 2015), but it can be much more complex.

If we want to execute more than one statement, we have to wrap our code block inside curly braces:
if (year == 2015) {
  alert( "That's correct!" );
  alert( "You're so smart!" );
}
We recommend wrapping your code block with curly braces {} every time you use an if statement, even if there is only one statement to execute.

# Boolean conversion
The if (…) statement evaluates the expression in its parentheses and converts the result to a boolean.
Let’s recall the conversion rules from the chapter Type Conversions:
A number 0, an empty string "", null, undefined, and NaN all become false. Because of that they are called “falsy” values.
Other values become true, so they are called “truthy”.

# The “else” clause
The if statement may contain an optional “else” block. It executes when the condition is falsy.

# Several conditions: “else if”
Sometimes, we’d like to test several variants of a condition. The else if clause lets us do that.

# Conditional operator ‘?’
Sometimes, we need to assign a variable depending on a condition.

The operator is represented by a question mark ?. Sometimes it’s called “ternary”, because the operator has three operands. It is actually the one and only operator in JavaScript which has that many.

The syntax is:
let result = condition ? value1 : value2;

The condition is evaluated: if it’s truthy then value1 is returned, otherwise – value2.
For example:
let accessAllowed = (age > 18) ? true : false;

# Multiple ‘?’
A sequence of question mark operators ? can return a value that depends on more than one condition.

# Non-traditional use of ‘?’
Sometimes the question mark ? is used as a replacement for if:

let company = prompt('Which company created JavaScript?', '');

(company == 'Netscape') ?
   alert('Right!') : alert('Wrong.');

The purpose of the question mark operator ? is to return one value or another depending on its condition. Please use it for exactly that. Use if when you need to execute different branches of code.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Logical operators:

There are four logical operators in JavaScript: 
|| (OR) 
&& (AND) 
! (NOT), 
?? (Nullish Coalescing)

Although they are called “logical”, they can be applied to values of any type, not only boolean. Their result can also be of any type.

1. || (OR)
The “OR” operator is represented with two vertical line symbols:
result = a || b;

There are four possible logical combinations:
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false

As we can see, the result is always true except for the case when both operands are false.
If an operand is not a boolean, it’s converted to a boolean for the evaluation.

For instance, the number 1 is treated as true, the number 0 as false:
if (1 || 0) { // works just like if( true || false )
  alert( 'truthy!' );
}

Most of the time, OR || is used in an if statement to test if any of the given conditions is true.
For example:
let hour = 9;
if (hour < 10 || hour > 18) {
  alert( 'The office is closed.' );
}

# The OR || operator does the following:
Evaluates operands from left to right.
For each operand, converts it to boolean. If the result is true, stops and returns the original value of that operand.
If all operands have been evaluated (i.e. all were false), returns the last operand.
A value is returned in its original form, without the conversion.

# Short-circuit evaluation:
Another feature of OR || operator is the so-called “short-circuit” evaluation.
It means that || processes its arguments until the first truthy value is reached, and then the value is returned immediately, without even touching the other argument.

2. && (AND)
The AND operator is represented with two ampersands &&:
result = a && b;

In classical programming, AND returns true if both operands are truthy and false otherwise:
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false

# The AND && operator does the following:
Evaluates operands from left to right.
For each operand, converts it to a boolean. If the result is false, stops and returns the original value of that operand.
If all operands have been evaluated (i.e. all were truthy), returns the last operand.
In other words, AND returns the first falsy value or the last value if none were found.

Note: Precedence of AND && is higher than OR ||
The precedence of AND && operator is higher than OR ||.
Don’t replace if with || or &&


3. ! (NOT)
The boolean NOT operator is represented with an exclamation sign !.
The syntax is pretty simple:
result = !value;

The operator accepts a single argument and does the following:
Converts the operand to boolean type: true/false.
Returns the inverse value.

A double NOT !! is sometimes used for converting a value to boolean type:

Note: The precedence of NOT ! is the highest of all logical operators, so it always executes first, before && or ||.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Nullish coalescing operator '??':
The nullish coalescing operator is written as two question marks ??.
As it treats null and undefined similarly, we’ll use a special term here, in this article. For brevity, we’ll say that a value is “defined” when it’s neither null nor undefined.

The result of a ?? b is:
if a is defined, then a,
if a isn’t defined, then b.

In other words, ?? returns the first argument if it’s not null/undefined. Otherwise, the second one.

We can rewrite result = a ?? b using the operators that we already know, like this:
result = (a !== null && a !== undefined) ? a : b;

For example, here we show user if its value isn’t null/undefined, otherwise Anonymous:
let user;
alert(user ?? "Anonymous"); // Anonymous (user not defined)


Here’s the example with user assigned to a name:
let user = "John";
alert(user ?? "Anonymous"); // John (user defined)

# Comparison with ||(or) and ?? :
The important difference between them is that:
|| returns the first truthy value.
?? returns the first defined value.

let height = 0;
alert(height || 100); // 100
alert(height ?? 100); // 0

The height || 100 checks height for being a falsy value, and it’s 0, falsy indeed.
so the result of || is the second argument, 100.
The height ?? 100 checks height for being null/undefined, and it’s not,
so the result is height “as is”, that is 0.

Note: The precedence of the ?? operator is the same as ||


# Using ?? with && or ||:
let x = 1 && 2 ?? 3; // Syntax error

Use explicit parentheses to work around it:
let x = (1 && 2) ?? 3; // Works
alert(x); // 2

Important:
The nullish coalescing operator ?? provides a short way to choose the first “defined” value from a list.
It’s used to assign default values to variables:
// set height=100, if height is null or undefined
height = height ?? 100;
The operator ?? has a very low precedence, only a bit higher than ? and =, so consider adding parentheses when using it in an expression.
It’s forbidden to use it with || or && without explicit parentheses.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Loops: while and for:

-> While:
The while loop has the following syntax:
while (condition) {
  // code
  // so-called "loop body"
}

While the condition is truthy, the code from the loop body is executed.
Curly braces are not required for a single-line body
If the loop body has a single statement, we can omit the curly braces {…}:
let i = 3;
while (i) alert(i--);

-> The “do…while” loop
The condition check can be moved below the loop body using the do..while syntax:

do {
  // loop body
} while (condition);
The loop will first execute the body, then check the condition, and, while it’s truthy, execute it again and again.

-> The “for” loop
It looks like this:
for (begin; condition; step) {
  // ... loop body ...
}

for (let i = 0; i < 3; i++) { // shows 0, then 1, then 2
  alert(i);
}

Let’s examine the for statement part-by-part:
part		
begin	let i = 0	Executes once upon entering the loop.
condition	i < 3	Checked before every loop iteration. If false, the loop stops.
body	alert(i)	Runs again and again while the condition is truthy.
step	i++	Executes after the body on each iteration.
The general loop algorithm works like this:

Run begin
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ ...
That is, begin executes once, and then it iterates: after each condition test, body and step are executed.


# Inline variable declaration:
Here, the “counter” variable i is declared right in the loop. This is called an “inline” variable declaration. Such variables are visible only inside the loop.
for (let i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // error, no such variable


# Skipping parts
Any part of for can be skipped.

For example, we can omit begin if we don’t need to do anything at the loop start.

Like here:
let i = 0; // we have i already declared and assigned
for (; i < 3; i++) { // no need for "begin"
  alert( i ); // 0, 1, 2
}
We can also remove the step part:
let i = 0;

for (; i < 3;) {
  alert( i++ );
}
This makes the loop identical to while (i < 3).

We can actually remove everything, creating an infinite loop:
for (;;) {
  // repeats without limits
}

Please note that the two for semicolons ; must be present. Otherwise, there would be a syntax error.

# Breaking the loop
Normally, a loop exits when its condition becomes falsy.
But we can force the exit at any time using the special break directive.

The break directive is activated at the line (*) if the user enters an empty line or cancels the input. It stops the loop immediately, passing control to the first line after the loop. Namely, alert.
The combination “infinite loop + break as needed” is great for situations when a loop’s condition must be checked not in the beginning or end of the loop, but in the middle or even in several places of its body.


# Continue to the next iteration
The continue directive is a “lighter version” of break. It doesn’t stop the whole loop. Instead, it stops the current iteration and forces the loop to start a new one (if the condition allows).
We can use it if we’re done with the current iteration and would like to move on to the next one.

The loop below uses continue to output only odd values:
for (let i = 0; i < 10; i++) {

  // if true, skip the remaining part of the body
  if (i % 2 == 0) continue;

  alert(i); // 1, then 3, 5, 7, 9
}

For even values of i, the continue directive stops executing the body and passes control to the next iteration of for (with the next number). So the alert is only called for odd values.

Note:
No break/continue to the right side of ‘?’
Please note that syntax constructs that are not expressions cannot be used with the ternary operator ?. In particular, directives such as break/continue aren’t allowed there.


# Labels for break/continue
Sometimes we need to break out from multiple nested loops at once.

A label is an identifier with a colon before a loop:
labelName: for (...) {
  ...
}

The break <labelName> statement in the loop below breaks out to the label:
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`Value at coords (${i},${j})`, '');
    // if an empty string or canceled, then break out of both loops
    if (!input) break outer; // (*)
    // do something with the value...
  }
}

alert('Done!');

In the code above, break outer looks upwards for the label named outer and breaks out of that loop.
So the control goes straight from (*) to alert('Done!').
We can also move the label onto a separate line:
outer:
for (let i = 0; i < 3; i++) { ... }

Note:
The continue directive can also be used with a label. In this case, code execution jumps to the next iteration of the labeled loop.
Labels do not allow to “jump” anywhere
Labels do not allow us to jump into an arbitrary place in the code.

For example, it is impossible to do this:
break label; // jump to the label below (doesn't work)
label: for (...)

A break directive must be inside a code block. Technically, any labelled code block will do, e.g.:
label: {
  // ...
  break label; // works
  // ...
}

We covered 3 types of loops:
while – The condition is checked before each iteration.
do..while – The condition is checked after each iteration.
for (;;) – The condition is checked before each iteration, additional settings available.

To make an “infinite” loop, usually the while(true) construct is used. Such a loop, just like any other, can be stopped with the break directive.
If we don’t want to do anything in the current iteration and would like to forward to the next one, we can use the continue directive.
break/continue support labels before the loop. A label is the only way for break/continue to escape a nested loop to go to an outer one.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# The "switch" statement:
A switch statement can replace multiple if checks.
It gives a more descriptive way to compare a value with multiple variants.

The syntax:
The switch has one or more case blocks and an optional default.

It looks like this:
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}

The value of x is checked for a strict equality to the value from the first case (that is, value1) then to the second (value2) and so on.
If the equality is found, switch starts to execute the code starting from the corresponding case, until the nearest break (or until the end of switch).
If no case is matched then the default code is executed (if it exists).

An example of switch (the executed code is highlighted):
let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Too small' );
    break;
  case 4:
    alert( 'Exactly!' );
    break;
  case 5:
    alert( 'Too big' );
    break;
  default:
    alert( "I don't know such values" );
}

Here the switch starts to compare a from the first case variant that is 3. The match fails.
Then 4. That’s a match, so the execution starts from case 4 until the nearest break.
If there is no break then the execution continues with the next case without any checks.

# If there is no break then the execution continues with the next case without any checks.
An example without break:
let a = 2 + 2;
switch (a) {
  case 3:
    alert( 'Too small' );
  case 4:
    alert( 'Exactly!' );
  case 5:
    alert( 'Too big' );
  default:
    alert( "I don't know such values" );
}
In the example above we’ll see sequential execution of three alerts:

alert( 'Exactly!' );
alert( 'Too big' );
alert( "I don't know such values" );

# Grouping of “case”:
Several variants of case which share the same code can be grouped.

For example, if we want the same code to run for case 3 and case 5:
let a = 3;
switch (a) {
  case 4:
    alert('Right!');
    break;

  case 3: // (*) grouped two cases
  case 5:
    alert('Wrong!');
    alert("Why don't you take a math class?");
    break;

  default:
    alert('The result is strange. Really.');
}
Now both 3 and 5 show the same message.
The ability to “group” cases is a side effect of how switch/case works without break. Here the execution of case 3 starts from the line (*) and goes through case 5, because there’s no break.

# Type matters
Let’s emphasize that the equality check is always strict. The values must be of the same type to match.

For example, let’s consider the code:
let arg = prompt("Enter a value?");
switch (arg) {
  case '0':
  case '1':
    alert( 'One or zero' );
    break;

  case '2':
    alert( 'Two' );
    break;

  case 3:
    alert( 'Never executes!' );
    break;
  default:
    alert( 'An unknown value' );
}
For 0, 1, the first alert runs.
For 2 the second alert runs.
But for 3, the result of the prompt is a string "3", which is not strictly equal === to the number 3. So we’ve got a dead code in case 3! The default variant will execute.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Functions:
Functions are the main “building blocks” of the program. 
They allow the code to be called many times without repetition.
We’ve already seen examples of built-in functions, like alert(message), prompt(message, default) and confirm(question). But we can create functions of our own as well.

# Function Declaration
To create a function we can use a function declaration.
function showMessage() {
  alert( 'Hello everyone!' );
}

The function keyword goes first, then goes the name of the function, then a list of parameters between the parentheses (comma-separated, empty in the example above, we’ll see examples later) and finally the code of the function, also named “the function body”, between curly braces.

function name(parameter1, parameter2, ... parameterN) {
  ...body...
}

Our new function can be called by its name: showMessage().
For instance:
function showMessage() {
  alert( 'Hello everyone!' );
}
showMessage();
showMessage();

The call showMessage() executes the code of the function. Here we will see the message two times.
This example clearly demonstrates one of the main purposes of functions: to avoid code duplication.
If we ever need to change the message or the way it is shown, it’s enough to modify the code in one place: the function which outputs it.

# Local variables
A variable declared inside a function is only visible inside that function.

# Outer variables:
A function can access an outer variable as well, for example:

let userName = 'John';
function showMessage() {
  let message = 'Hello, ' + userName;
  alert(message);
}
showMessage(); // Hello, John

The outer variable is only used if there’s no local one.
If a same-named variable is declared inside the function then it shadows the outer one.

# Global variables
Variables declared outside of any function, such as the outer userName in the code above, are called global.
Global variables are visible from any function (unless shadowed by locals).

Parameters
We can pass arbitrary data to functions using parameters.
In the example below, the function has two parameters: from and text.

function showMessage(from, text) { // parameters: from, text
  alert(from + ': ' + text);
}
showMessage('Ann', 'Hello!'); // Ann: Hello! (*)
showMessage('Ann', "What's up?"); // Ann: What's up? (**)
When the function is called in lines (*) and (**), the given values are copied to local variables from and text. Then the function uses them.

A parameter is the variable listed inside the parentheses in the function declaration (it’s a declaration time term).
An argument is the value that is passed to the function when it is called (it’s a call time term).
We declare functions listing their parameters, then call them passing arguments.

# Default values
If a function is called, but an argument is not provided, then the corresponding value becomes undefined.
For instance, the aforementioned function showMessage(from, text) can be called with a single argument:
showMessage("Ann");
That’s not an error. Such a call would output "*Ann*: undefined". As the value for text isn’t passed, it becomes undefined.
We can specify the so-called “default” (to use if omitted) value for a parameter in the function declaration, using =:

# Returning a value
A function can return a value back into the calling code as the result.
The simplest example would be a function that sums two values.
function sum(a, b) {
  return a + b;
}
let result = sum(1, 2);
alert( result ); // 3

The directive return can be in any place of the function. When the execution reaches it, the function stops, and the value is returned to the calling code (assigned to result above).

Note: A function with an empty return or without it returns undefined
If a function does not return a value, it is the same as if it returns undefined:
An empty return is also the same as return undefined.
Never add a newline between return and the value

# Naming a function
Functions are actions. So their name is usually a verb. It should be brief, as accurate as possible and describe what the function does, so that someone reading the code gets an indication of what the function does.

Function starting with…

"get…" – return a value,
"calc…" – calculate something,
"create…" – create something,
"check…" – check something and return a boolean, etc.
Examples of such names:

showMessage(..)     // shows a message
getAge(..)          // returns the age (gets it somehow)
calcSum(..)         // calculates a sum and returns the result
createForm(..)      // creates a form (and usually returns it)
checkPermission(..) // checks a permission, returns true/false

One function – one action
getAge – would be bad if it shows an alert with the age (should only get).

Summary:
A function declaration looks like this:
function name(parameters, delimited, by, comma) {
  /* code */
}

Values passed to a function as parameters are copied to its local variables.
A function may access outer variables. But it works only from inside out. The code outside of the function doesn’t see its local variables.
A function can return a value. If it doesn’t, then its result is undefined.
To make the code clean and easy to understand, it’s recommended to use mainly local variables and parameters in the function, not outer variables.
It is always easier to understand a function which gets parameters, works with them and returns a result than a function which gets no parameters, but modifies outer variables as a side effect.

Function naming:
A name should clearly describe what the function does. When we see a function call in the code, a good name instantly gives us an understanding what it does and returns.
A function is an action, so function names are usually verbal.
There exist many well-known function prefixes like create…, show…, get…, check… and so on. Use them to hint what a function does.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Coding Style:
1. Syntax:
- No space between the function name and parentheses between the parentheses and the parameter
-Indentation 2 spaces
- A space after for/if/while…
} else { without a line break
- Spaces around a nested call
- An empty line between logical blocks
- Lines are not very long
- A semicolon ; is mandatory
- Spaces around operators
- Curly brace { on the same line, after a space
- A space between arguments
- A space between parameters

2. Curly Braces
In most JavaScript projects curly braces are written in “Egyptian” style with the opening brace on the same line as the corresponding keyword – not on a new line. There should also be a space before the opening bracket, like this:
if (condition) {
  // do this
  // ...and that
  // ...and that
}

The best variant:
if (n < 0) {
  alert(`Power ${n} is not supported`);
}

3. Line Length
No one likes to read a long horizontal line of code. It’s best practice to split them.

For example:
// backtick quotes ` allow to split the string into multiple lines
let str = `
  ECMA International's TC39 is a group of JavaScript developers,
  implementers, academics, and more, collaborating with the community
  to maintain and evolve the definition of JavaScript.
`;

4. Indents
There are two types of indents:
Horizontal indents: 2 or 4 spaces.
A horizontal indentation is made using either 2 or 4 spaces or the horizontal tab symbol (key Tab). Which one to choose is an old holy war. Spaces are more common nowadays.
One advantage of spaces over tabs is that spaces allow more flexible configurations of indents than the tab symbol.

Vertical indents: empty lines for splitting code into logical blocks.
Even a single function can often be divided into logical blocks. In the example below, the initialization of variables, the main loop and returning the result are split vertically
function pow(x, n) {
  let result = 1;
  //              <--
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  //              <--
  return result;
}

5. Semicolons
A semicolon should be present after each statement, even if it could possibly be skipped.

6. Nesting Levels
Try to avoid nesting code too many levels deep.
For example, in the loop, it’s sometimes a good idea to use the continue directive to avoid extra nesting.

7. Function Placement
If you are writing several “helper” functions and the code that uses them, there are three ways to organize the functions.
Declare the functions above the code that uses them:

// function declarations
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}

// the code which uses them
let elem = createElement();
setHandler(elem);
walkAround();
Code first, then functions

// the code which uses the functions
let elem = createElement();
setHandler(elem);
walkAround();

// --- helper functions ---
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}

Mixed: a function is declared where it’s first used.
Most of time, the second variant is preferred.
That’s because when reading code, we first want to know what it does. If the code goes first, then it becomes clear from the start. 

# Style Guides
A style guide contains general rules about “how to write” code, e.g. which quotes to use, how many spaces to indent, the maximal line length, etc. A lot of minor things.
When all members of a team use the same style guide, the code looks uniform, regardless of which team member wrote it.

# Automated Linters
Linters are tools that can automatically check the style of your code and make improving suggestions.
The great thing about them is that style-checking can also find some bugs, like typos in variable or function names.

Here are some well-known linting tools:

JSLint – one of the first linters.
JSHint – more settings than JSLint.
ESLint – probably the newest one.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Automated testing with Mocha:
Mocha is an open source test framework that is used to run your automated tests in Node. It comes with a wide range of features that allow you to create descriptive automated tests, robust reports and even execute your automated tests every time a file is changed locally.
Mocha.js provides functions that execute in a specific order and logs the results in the terminal window. 
It also cleans the state of the software being tested to ensure that test cases run independently of each other.

Automated testing will be used in further tasks, and it’s also widely used in real projects.
Automated testing means that tests are written separately, in addition to the code. They run our functions in various ways and compare results with the expected.
When we write a function, we can usually imagine what it should do: which parameters give which results.
During development, we can check the function by running it and comparing the outcome with the expected one. For instance, we can do it in the console.
If something is wrong – then we fix the code, run again, check the result – and so on till it works.

# A spec has three main building blocks that you can see above:
describe("title", function() { ... })
What functionality we’re describing? In our case we’re describing the function pow. Used to group “workers” – the it blocks.
it("use case description", function() { ... })
In the title of it we in a human-readable way describe the particular use case, and the second argument is a function that tests it.
assert.equal(value1, value2)
The code inside it block, if the implementation is correct, should execute without errors.
Functions assert.* are used to check whether pow works as expecte

# The development flow
The flow of development usually looks like this:
-An initial spec is written, with tests for the most basic functionality.
-An initial implementation is created.
-To check whether it works, we run the testing framework Mocha (more details soon) that runs the spec. While the functionality is not complete, errors are displayed. We make corrections until everything works.
-Now we have a working initial implementation with tests.
-We add more use cases to the spec, probably not yet supported by the implementations. Tests start to fail.
-Go to 3, update the implementation till tests give no errors.
-Repeat steps 3-6 till the functionality is ready.
-So, the development is iterative. We write the spec, implement it, make sure tests pass, then write more tests, make sure they work etc. At the end we have both a working implementation and tests for it.

# The spec in action:
-Mocha – the core framework: it provides common testing functions including describe and it and the main function that runs tests.
-Chai – the library with many assertions. It allows to use a lot of different assertions, for now we need only assert.equal.
-Sinon – a library to spy over functions, emulate built-in functions and more, we’ll need it much later.
These libraries are suitable for both in-browser and server-side testing.

# Other assertions
Please note the assertion assert.isNaN: it checks for NaN.
There are other assertions in Chai as well, for instance:
assert.equal(value1, value2) – checks the equality value1 == value2.
assert.strictEqual(value1, value2) – checks the strict equality value1 === value2.
assert.notEqual, assert.notStrictEqual – inverse checks to the ones above.
assert.isTrue(value) – checks that value === true
assert.isFalse(value) – checks that value === false
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Polyfills and transpilers:
A transpiler will convert a new syntax to an older syntax.
A transpiler is a special piece of software that translates source code to another source code. 
It can parse (“read and understand”) modern code and rewrite it using older syntax constructs, so that it’ll also work in outdated engines.

A transpiler would analyze our code and rewrite height ?? 100 into (height !== undefined && height !== null) ? height : 100.
// before running the transpiler
height = height ?? 100;
// after running the transpiler
height = (height !== undefined && height !== null) ? height : 100;

Usually, a developer runs the transpiler on their own computer, and then deploys the transpiled code to the server.
Speaking of names, Babel is one of the most prominent transpilers out there.

# Polyfills
Polyfills are useful when the issue is related to a missing API rather than some new syntax.
For example, Math.trunc(n) is a function that “cuts off” the decimal part of a number, e.g Math.trunc(1.23) returns 1.
A script that updates/adds new functions is called “polyfill”. It “fills in” the gap and adds missing implementations.

Two interesting polyfill libraries are:
-core js that supports a lot, allows to include only needed features.
-polyfill.io service that provides a script with polyfills, depending on the features and user’s browser.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Objects:
Objects are used to store keyed collections of various data and more complex entities.
An object can be created with figure brackets {…} with an optional list of properties. 
A property is a “key: value” pair, where key is a string (also called a “property name”), and value can be anything.

An empty object (“empty cabinet”) can be created using one of two syntaxes:
let user = new Object(); // "object constructor" syntax
let user = {};  // "object literal" syntax

Usually, the figure brackets {...} are used. That declaration is called an object literal.

# Literals and properties:
We can immediately put some properties into {...} as “key: value” pairs:
let user = {     // an object
  name: "John",  // by key "name" store value "John"
  age: 30        // by key "age" store value 30
};

A property has a key (also known as “name” or “identifier”) before the colon ":" and a value to the right of it.
In the user object, there are two properties:
The first property has the name "name" and the value "John".
The second one has the name "age" and the value 30.

Property values are accessible using the dot notation:
// get property values of the object:
alert( user.name ); // John
alert( user.age ); // 30

The value can be of any type. Let’s add a boolean one:
user.isAdmin = true;

To remove a property, we can use the delete operator:
delete user.age;

# Computed properties
We can use square brackets in an object literal, when creating an object. That’s called computed properties.
let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};

# Property names limitations
As we already know, a variable cannot have a name equal to one of the language-reserved words like “for”, “let”, “return” etc.
But for an object property, there’s no such restriction

Reading a non-existing property just returns undefined. So we can easily test whether the property exists:
There’s also a special operator "in" for that.

The syntax is:
"key" in object

For instance:
let user = { name: "John", age: 30 };
alert( "age" in user ); // true, user.age exists
alert( "blabla" in user ); // false, user.blabla doesn't exist

# The "for..in" loop:
The syntax:

for (key in object) {
  // executes the body for each key among object properties
}

-Objects are associative arrays with several special features.
-They store properties (key-value pairs), where:
-Property keys must be strings or symbols (usually strings).
-Values can be of any type.
-To access a property, we can use:
-The dot notation: obj.property.
-Square brackets notation obj["property"]. Square brackets allow taking the key from a variable, like obj[varWithKey].

Additional operators:
-To delete a property: delete obj.prop.
-To check if a property with the given key exists: "key" in obj.
-To iterate over an object: for (let key in obj) loop.

There are many other kinds of objects in JavaScript:
Array to store ordered data collections,
Date to store the information about the date and time,
Error to store the information about an error.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Garbage collection:
Garbage collection (GC) is a form of automatic memory management. The garbage collector, or just collector, attempts to reclaim garbage, or memory occupied by objects that are no longer in use by the program. 
The majority of memory management issues occur when we try to release the allocated memory. The main concern that arises is the determination of unused memory resources. 
In case of the low-level languages where the developer has to manually decide when the memory is no longer needed, high-level languages such as JavaScript use an automated form of memory management known as Garbage Collection(GC).
The general problem of automatically finding whether some memory "is not needed anymore" is undecidable.
The main concept of the algorithms designed for garbage collection is the concept of reference. 

Here’s the simplest example:

// user has a reference to the object
let user = {
  name: "John"
};
Here the arrow depicts an object reference. The global variable "user" references the object {name: "John"}
If the value of user is overwritten, the reference is lost:
i.e user = null;
Now John becomes unreachable. There’s no way to access it, no references to it. Garbage collector will junk the data and free the memory.

# Two references:
Now let’s imagine we copied the reference from user to admin:

// user has a reference to the object
let user = {
  name: "John"
};
let admin = user;

Now if we do the same:
user = null;
Then the object is still reachable via admin global variable, so it must stay in memory. If we overwrite admin too, then it can be removed.

# Internal algorithms
The basic garbage collection algorithm is called “mark-and-sweep”.
The following “garbage collection” steps are regularly performed:
The garbage collector takes roots and “marks” (remembers) them.
Then it visits and “marks” all references from them.
Then it visits marked objects and marks their references. All visited objects are remembered, so as not to visit the same object twice in the future.
…And so on until every reachable (from the roots) references are visited.
All objects except marked ones are removed.

The main things to know:
Garbage collection is performed automatically. We cannot force or prevent it.
Objects are retained in memory while they are reachable.
Being referenced is not the same as being reachable (from a root): a pack of interlinked objects can become unreachable as a whole, as we’ve seen in the example above.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# “this” in methods:

It’s common that an object method needs to access the information stored in the object to do its job.
For instance, the code inside user.sayHi() may need the name of the user.
To access the object, a method can use the this keyword.
The value of this is the object “before dot”, the one used to call the method.

# “this” is not bound
In JavaScript, keyword this behaves unlike most other programming languages. It can be used in any function, even if it’s not a method of an object.

There’s no syntax error in the following example:
function sayHi() {
  alert( this.name );
}
The value of this is evaluated during the run-time, depending on the context. 
Calling without an object: this == undefined
We can even call the function without an object at all:

function sayHi() {
  alert(this);
}
sayHi(); // undefined

In this case this is undefined in strict mode. If we try to access this.name, there will be an error.

The consequences of unbound this
If you come from another programming language, then you are probably used to the idea of a "bound this", where methods defined in an object always have this referencing that object.
In JavaScript this is “free”, its value is evaluated at call-time and does not depend on where the method was declared, but rather on what object is “before the dot”.

# Arrow functions have no “this”
Arrow functions are special: they don’t have their “own” this. If we reference this from such a function, it’s taken from the outer “normal” function.

For instance, here arrow() uses this from the outer user.sayHi() method:

let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};
user.sayHi(); // Ilya

Functions that are stored in object properties are called “methods”.
Methods allow objects to “act” like object.doSomething().
Methods can reference the object as this.
The value of this is defined at run-time.
When a function is declared, it may use this, but that this has no value until the function is called.
A function can be copied between objects.
When a function is called in the “method” syntax: object.method(), the value of this during the call is object.
Please note that arrow functions are special: they have no this. When this is accessed inside an arrow function, it is taken from outside.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Constructor, operator "new":
The regular {...} syntax allows us to create one object. But often we need to create many similar objects, like multiple users or menu items and so on.
That can be done using constructor functions and the "new" operator.

# Constructor function
Constructor functions technically are regular functions. There are two conventions though:
-They are named with capital letter first.
-They should be executed only with "new" operator.

That’s the main purpose of constructors – to implement reusable object creation code.
# new function() { … }
If we have many lines of code all about creation of a single complex object, we can wrap them in an immediately called constructor function, like this:
// create a function and immediately call it with new
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...other code for user creation
  // maybe complex logic and statements
  // local variables etc
};
This constructor can’t be called again, because it is not saved anywhere, just created and called. So this trick aims to encapsulate the code that constructs the single object, without future reuse.

# Constructor mode test: new.target:
Inside a function, we can check whether it was called with new or without it, using a special new.target property.

# Return from constructors:
Usually, constructors do not have a return statement. Their task is to write all necessary stuff into this, and it automatically becomes the result.
But if there is a return statement, then the rule is simple:
If return is called with an object, then the object is returned instead of this.
If return is called with a primitive, it’s ignored.
In other words, return with an object returns that object, in all other cases this is returned.

# Omitting parentheses
By the way, we can omit parentheses after new, if it has no arguments:
let user = new User; // <-- no parentheses
// same as
let user = new User();
Omitting parentheses here is not considered a “good style”, but the syntax is permitted by specification.

# Methods in constructor
Using constructor functions to create objects gives a great deal of flexibility. The constructor function may have parameters that define how to construct the object, and what to put in it.
Of course, we can add to this not only properties, but methods as well.

Constructor functions or, briefly, constructors, are regular functions, but there’s a common agreement to name them with capital letter first.
Constructor functions should only be called using new. Such a call implies a creation of empty this at the start and returning the populated one at the end.
We can use constructor functions to make multiple similar objects.
JavaScript provides constructor functions for many built-in language objects: like Date for dates, Set for sets and others that we plan to study.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Symbol is a primitive type for unique identifiers.
Symbols are created with Symbol() call with an optional description (name).
Symbols are always different values, even if they have the same name. If we want same-named symbols to be equal, then we should use the global registry: 
Symbol.for(key) returns (creates if needed) a global symbol with key as the name. Multiple calls of Symbol.for with the same key return exactly the same symbol.

# System symbols:
There exist many “system” symbols that JavaScript uses internally, and we can use them to fine-tune various aspects of our objects.
They are listed in the specification in the Well-known symbols table:
Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.iterator
Symbol.toPrimitive
…and so on.
For instance, Symbol.toPrimitive allows us to describe object to primitive conversion.

# Symbols in an object literal
If we want to use a symbol in an object literal {...}, we need square brackets around it.

Like this:
let id = Symbol("id");
let user = {
  name: "John",
  [id]: 123 // not "id": 123
};
That’s because we need the value from the variable id as the key, not the string “id”

# Symbols are skipped by for…in
Symbolic properties do not participate in for..in loop.

# “Hidden” properties
Symbols allow us to create “hidden” properties of an object, that no other part of code can accidentally access or overwrite.
If another script or a library loops over our object, it won’t unexpectedly access a symbolic property.

# Global symbols
As we’ve seen, usually all symbols are different, even if they have the same name. But sometimes we want same-named symbols to be same entities. 
For instance, different parts of our application want to access symbol "id" meaning exactly the same property.
To achieve that, there exists a global symbol registry. We can create symbols in it and access them later, and it guarantees that repeated accesses by the same name return exactly the same symbol.
In order to read (create if absent) a symbol from the registry, use Symbol.for(key).
That call checks the global registry, and if there’s a symbol described as key, then returns it, otherwise creates a new symbol Symbol(key) and stores it in the registry by the given key.

# Symbol.keyFor
We have seen that for global symbols, Symbol.for(key) returns a symbol by name. To do the opposite – return a name by global symbol – we can use: Symbol.keyFor(sym):

Symbols have two main use cases:
-“Hidden” object properties.
If we want to add a property into an object that “belongs” to another script or a library, we can create a symbol and use it as a property key. A symbolic property does not appear in for..in, so it won’t be accidentally processed together with other properties. 
Also it won’t be accessed directly, because another script does not have our symbol. So the property will be protected from accidental use or overwrite.
So we can “covertly” hide something into objects that we need, but others should not see, using symbolic properties.
-There are many system symbols used by JavaScript which are accessible as Symbol.*. We can use them to alter some built-in behaviors. 
For instance, later in the tutorial we’ll use Symbol.iterator for iterables, Symbol.toPrimitive to setup object-to-primitive conversion and so on.
Technically, symbols are not 100% hidden. There is a built-in method Object.getOwnPropertySymbols(obj) that allows us to get all symbols. 
Also there is a method named Reflect.ownKeys(obj) that returns all keys of an object including symbolic ones. But most libraries, built-in functions and syntax constructs don’t use these methods.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Object to primitive conversion:
What happens when objects are added obj1 + obj2, subtracted obj1 - obj2 or printed using alert(obj)?
JavaScript doesn’t allow you to customize how operators work on objects. Unlike some other programming languages, such as Ruby or C++, we can’t implement a special object method to handle addition (or other operators).
In case of such operations, objects are auto-converted to primitives, and then the operation is carried out over these primitives and results in a primitive value.

# Conversion rules:
-There’s no conversion to boolean. All objects are true in a boolean context, as simple as that. There exist only numeric and string conversions.
-The numeric conversion happens when we subtract objects or apply mathematical functions. 
For instance, Date objects (to be covered in the chapter Date and time) can be subtracted, and the result of date1 - date2 is the time difference between two dates.
-As for the string conversion – it usually happens when we output an object with alert(obj) and in similar contexts.
-We can implement string and numeric conversion by ourselves, using special object methods.

# Hints:
There are three variants of type conversion, that happen in various situations. They’re called “hints”.

1. "string"
For an object-to-string conversion, when we’re doing an operation on an object that expects a string, like alert:
// output
alert(obj);
// using object as a property key
anotherObj[obj] = 123;

2. "number"
For an object-to-number conversion, like when we’re doing maths:
// explicit conversion
let num = Number(obj);
// maths (except binary plus)
let n = +obj; // unary plus
let delta = date1 - date2;
// less/greater comparison
let greater = user1 > user2;

3. "default"
Occurs in rare cases when the operator is “not sure” what type to expect.
For instance, binary plus + can work both with strings (concatenates them) and numbers (adds them). 
So if a binary plus gets an object as an argument, it uses the "default" hint to convert it.

The greater and less comparison operators, such as < >, can work with both strings and numbers too. Still, they use the "number" hint, not "default".

# To do the conversion, JavaScript tries to find and call three object methods:

-Call obj[Symbol.toPrimitive](hint) – the method with the symbolic key Symbol.toPrimitive (system symbol), if such method exists,
Otherwise if hint is "string"
-try calling obj.toString() or obj.valueOf(), whatever exists.
Otherwise if hint is "number" or "default"
-try calling obj.valueOf() or obj.toString(), whatever exists.

# Symbol.toPrimitive
Let’s start from the first method. There’s a built-in symbol named Symbol.toPrimitive that should be used to name the conversion method.
Syntax:
obj[Symbol.toPrimitive] = function(hint) {
  // here goes the code to convert this object to a primitive
  // it must return a primitive value
  // hint = one of "string", "number", "default"
};

# toString/valueOf
If there’s no Symbol.toPrimitive then JavaScript tries to find methods toString and valueOf:
For the "string" hint: call toString method, and if it doesn’t exist, then valueOf (so toString has the priority for string conversions).
For other hints: valueOf, and if it doesn’t exist, then toString (so valueOf has the priority for maths).

By default, a plain object has following toString and valueOf methods:

The toString method returns a string "[object Object]".
The valueOf method returns the object itself.

# Further conversions
As we know already, many operators and functions perform type conversions, e.g. multiplication * converts operands to numbers.
If we pass an object as an argument, then there are two stages of calculations:
The object is converted to a primitive (using the rules described above).
If the necessary for further calculations, the resulting primitive is also converted.
1. The multiplication obj * 2 first converts the object to primitive (that’s a string "2").
2.Then "2" * 2 becomes 2 * 2 (the string is converted to number).

The object-to-primitive conversion is called automatically by many built-in functions and operators that expect a primitive as a value.

There are 3 types (hints) of it:
"string" (for alert and other operations that need a string)
"number" (for maths)
"default" (few operators, usually objects implement it the same way as "number")
The specification describes explicitly which operator uses which hint.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Methods of primitives
JavaScript allows us to work with primitives (strings, numbers, etc.) as if they were objects. They also provide methods to call as such.

Let’s look at the key distinctions between primitives and objects.
A primitive
Is a value of a primitive type.
There are 7 primitive types: string, number, bigint, boolean, symbol, null and undefined.

An object
Is capable of storing multiple values as properties.
Can be created with {}, for instance: {name: "John", age: 30}. There are other kinds of objects in JavaScript: functions

# A primitive as an object:
The language allows access to methods and properties of strings, numbers, booleans and symbols.

The “object wrappers” are different for each primitive type and are called: String, Number, Boolean, Symbol and BigInt. Thus, they provide different sets of methods.
For instance, there exists a string method str.toUpperCase() that returns a capitalized str.
let str = "Hello";

alert( str.toUpperCase() ); // HELLO
Simple, right? Here’s what actually happens in str.toUpperCase():
The string str is a primitive. So in the moment of accessing its property, a special object is created that knows the value of the string, and has useful methods, like toUpperCase().
That method runs and returns a new string (shown by alert).
The special object is destroyed, leaving the primitive str alone.

A number has methods of its own, for instance, toFixed(n) rounds the number to the given precision:
Constructors String/Number/Boolean are for internal use only
Some languages like Java allow us to explicitly create “wrapper objects” for primitives using a syntax like new Number(1) or new Boolean(false)
ex- alert( typeof 0 ); // "number"
alert( typeof new Number(0) ); // "object"!

Objects are always truthy in if, so here the alert will show up:
let zero = new Number(0);
if (zero) { // zero is true, because it's an object
  alert( "zero is truthy!?!" );
}

On the other hand, using the same functions String/Number/Boolean without new is totally fine and useful thing. They convert a value to the corresponding type: to a string, a number, or a boolean (primitive).
For example, this is entirely valid:
let num = Number("123"); // convert a string to number

null/undefined have no methods
The special primitives null and undefined are exceptions. They have no corresponding “wrapper objects” and provide no methods
alert(null.test); // error
Formally, these methods work via temporary objects, but JavaScript engines are well tuned to optimize that internally, so they are not expensive to call.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Numbers
In modern JavaScript, there are two types of numbers:
-Regular numbers in JavaScript are stored in 64-bit format IEEE-754, also known as “double precision floating point numbers”. These are numbers that we’re using most of the time, and we’ll talk about them in this chapter.
-BigInt numbers represent integers of arbitrary length. They are sometimes needed because a regular integer number can’t safely exceed (253-1) or be less than -(253-1), as we mentioned earlier in the chapter Data types. As bigints are used in few special areas, we devote them a special chapter BigInt.

# More ways to write a number:
Imagine we need to write 1 billion. The obvious way is:
let billion = 1000000000;
We also can use underscore _ as the separator:
let billion = 1_000_000_000;

Syntactic sugar is syntax within a programming language that is designed to make things easier to read or to express.
Here the underscore _ plays the role of the “syntactic sugar”, it makes the number more readable. The JavaScript engine simply ignores _ between digits, so it’s exactly the same one billion as above.

In JavaScript, we can shorten a number by appending the letter "e" to it and specifying the zeroes count:
let billion = 1e9;  // 1 billion, literally: 1 and 9 zeroes

In other words, e multiplies the number by 1 with the given zeroes count.
1e3 === 1 * 1000; // e3 means *1000

Now let’s write something very small. Say, 1 microsecond (one millionth of a second):
let mсs = 0.000001;
Just like before, using "e" can help. If we’d like to avoid writing the zeroes explicitly, we could write the same as:
let mcs = 1e-6; // five zeroes to the left from 1.
If we count the zeroes in 0.000001, there are 6 of them. So naturally it’s 1e-6.

In other words, a negative number after "e" means a division by 1 with the given number of zeroes:

// -3 divides by 1 with 3 zeroes
1e-3 === 1 / 1000; // 0.001
// -6 divides by 1 with 6 zeroes
1.23e-6 === 1.23 / 1000000; // 0.00000123
// an example with a bigger number
1234e-2 === 1234 / 100; // 12.34, decimal point moves 2 times

# Hex, binary and octal numbers
Hexadecimal numbers are widely used in JavaScript to represent colors, encode characters, and for many other things. So naturally, there exists a shorter way to write them: 0x and then the number.
alert( 0xff ); // 255

# Binary and octal numeral systems are rarely used, but also supported using the 0b and 0o prefixes:
let a = 0b11111111; // binary form of 255
let b = 0o377; // octal form of 255
alert( a == b ); // true, the same number 255 at both sides

# toString(base)
The method num.toString(base) returns a string representation of num in the numeral system with the given base.
For example:
let num = 255;
alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
The base can vary from 2 to 36. By default it’s 10.

Common use cases for this are:
base=16 is used for hex colors, character encodings etc, digits can be 0..9 or A..F.

base=2 is mostly for debugging bitwise operations, digits can be 0 or 1.

base=36 is the maximum, digits can be 0..9 or A..Z. The whole latin alphabet is used to represent a number. A funny, but useful case for 36 is when we need to turn a long numeric identifier into something shorter, for example to make a short url. Can simply represent it in the numeral system with base 36:
alert( 123456..toString(36) ); // 2n9c

# Two dots to call a method
Please note that two dots in 123456..toString(36) is not a typo. If we want to call a method directly on a number, like toString in the example above, then we need to place two dots .. after it.
If we placed a single dot: 123456.toString(36), then there would be an error, because JavaScript syntax implies the decimal part after the first dot. And if we place one more dot, then JavaScript knows that the decimal part is empty and now goes the method.
Also could write (123456).toString(36).

# Rounding
One of the most used operations when working with numbers is rounding.

There are several built-in functions for rounding:
1. Math.floor
Rounds down: 3.1 becomes 3, and -1.1 becomes -2.
2. Math.ceil
Rounds up: 3.1 becomes 4, and -1.1 becomes -1.
3. Math.round
Rounds to the nearest integer: 3.1 becomes 3, 3.6 becomes 4, the middle case: 3.5 rounds up to 4 too.
4. Math.trunc (not supported by Internet Explorer)
Removes anything after the decimal point without rounding: 3.1 becomes 3, -1.1 becomes -1.

Here’s the table to summarize the differences between them:

       Math.floor	Math.ceil	Math.round	Math.trunc
3.1	   3	           4	            3	           3
3.6	   3	           4	            4	           3
-1.1	  -2	          -1	           -1	          -1
-1.6	  -2	          -1	           -2	          -1

# But what if we’d like to round the number to n-th digit after the decimal?
For instance, we have 1.2345 and want to round it to 2 digits, getting only 1.23.
There are two ways to do so:

1. Multiply-and-divide.
For example, to round the number to the 2nd digit after the decimal, we can multiply the number by 100, call the rounding function and then divide it back.
let num = 1.23456;
alert( Math.round(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23

2. The method toFixed(n) rounds the number to n digits after the point and returns a string representation of the result.
let num = 12.34;
alert( num.toFixed(1) ); // "12.3"

This rounds up or down to the nearest value, similar to Math.round:

let num = 12.36;
alert( num.toFixed(1) ); // "12.4"
Please note that the result of toFixed is a string. If the decimal part is shorter than required, zeroes are appended to the end:

let num = 12.34;
alert( num.toFixed(5) ); // "12.34000", added zeroes to make exactly 5 digits
We can convert it to a number using the unary plus or a Number() call, e.g write +num.toFixed(5).


# Imprecise calculations
Internally, a number is represented in 64-bit format IEEE-754, so there are exactly 64 bits to store a number: 52 of them are used to store the digits, 11 of them store the position of the decimal point, and 1 bit is for the sign.

If a number is really huge, it may overflow the 64-bit storage and become a special numeric value Infinity:
alert( 1e500 ); // Infinity

The most reliable method is to round the result with the help of a method toFixed(n):
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // "0.30"
Please note that toFixed always returns a string. It ensures that it has 2 digits after the decimal point. 

# We also can temporarily multiply the numbers by 100 (or a bigger number) to turn them into integers, do the maths, and then divide back. Then, as we’re doing maths with integers, the error somewhat decreases, but we still get it on division:
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
So, multiply/divide approach reduces the error, but doesn’t remove it totally.

# Two zeroes
Another funny consequence of the internal representation of numbers is the existence of two zeroes: 0 and -0.
That’s because a sign is represented by a single bit, so it can be set or not set for any number including a zero.
In most cases the distinction is unnoticeable, because operators are suited to treat them as the same.

# Tests: isFinite and isNaN
Remember these two special numeric values?
-Infinity (and -Infinity) is a special numeric value that is greater (less) than anything.
-NaN represents an error.

They belong to the type number, but are not “normal” numbers, so there are special functions to check for them:
1. isNaN(value) converts its argument to a number and then tests it for being NaN:
alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true

The value NaN is unique in that it does not equal anything, including itself:
alert( NaN === NaN ); // false

2. isFinite(value) converts its argument to a number and returns true if it’s a regular number, not NaN/Infinity/-Infinity:
alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, because a special value: NaN
alert( isFinite(Infinity) ); // false, because a special value: Infinity

Sometimes isFinite is used to validate whether a string value is a regular number:
Note: Please note that an empty or a space-only string is treated as 0 in all numeric functions including isFinite.

Compare with Object.is:
There is a special built-in method Object.is that compares values like ===, but is more reliable for two edge cases:
It works with NaN: Object.is(NaN, NaN) === true, that’s a good thing.
Values 0 and -0 are different: Object.is(0, -0) === false, technically that’s true, because internally the number has a sign bit that may be different even if all other bits are zeroes.
In all other cases, Object.is(a, b) is the same as a === b.
This way of comparison is often used in JavaScript specification. When an internal algorithm needs to compare two values for being exactly the same, it uses Object.is (internally called SameValue).

# parseInt and parseFloat
Numeric conversion using a plus + or Number() is strict. If a value is not exactly a number, it fails:
alert( +"100px" ); // NaN

They “read” a number from a string until they can’t. In case of an error, the gathered number is returned. 
The function parseInt returns an integer, while parseFloat will return a floating-point number.

There are situations when parseInt/parseFloat will return NaN. It happens when no digits could be read:
alert( parseInt('a123') ); // NaN, the first symbol stops the process

# The second argument of parseInt(str, radix)
The parseInt() function has an optional second parameter. It specifies the base of the numeral system, so parseInt can also parse strings of hex numbers, binary numbers and so on:
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, without 0x also works
alert( parseInt('2n9c', 36) ); // 123456

# Other math functions
JavaScript has a built-in Math object which contains a small library of mathematical functions and constants.
1. Math.random()
Returns a random number from 0 to 1 (not including 1).
alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (any random numbers)

2. Math.max(a, b, c...) and Math.min(a, b, c...)
Returns the greatest and smallest from the arbitrary number of arguments.
alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1

3. Math.pow(n, power)
Returns n raised to the given power.
alert( Math.pow(2, 10) ); // 2 in power 10 = 1024
There are more functions and constants in Math object, including trigonometry, which you can find in the docs for the Math object.

Summary:
-To write numbers with many zeroes:
Append "e" with the zeroes count to the number. Like: 123e6 is the same as 123 with 6 zeroes 123000000.
A negative number after "e" causes the number to be divided by 1 with given zeroes. E.g. 123e-6 means 0.000123 (123 millionths).

-For different numeral systems:
Can write numbers directly in hex (0x), octal (0o) and binary (0b) systems.
parseInt(str, base) parses the string str into an integer in numeral system with given base, 2 ≤ base ≤ 36.
num.toString(base) converts a number to a string in the numeral system with the given base.

-For regular number tests:
isNaN(value) converts its argument to a number and then tests it for being NaN
isFinite(value) converts its argument to a number and returns true if it’s a regular number, not NaN/Infinity/-Infinity

-For converting values like 12pt and 100px to a number:
Use parseInt/parseFloat for the “soft” conversion, which reads a number from a string and then returns the value they could read before the error.

-For fractions:
Round using Math.floor, Math.ceil, Math.trunc, Math.round or num.toFixed(precision).
Make sure to remember there’s a loss of precision when working with fractions.

-More mathematical functions:
See the Math object when you need them. The library is very small, but can cover basic needs.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
