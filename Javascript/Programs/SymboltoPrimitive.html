<script>
  let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// conversions demo:
  alert(user); // hint: string -> {name: "John"}
  alert(+user); // hint: number -> 1000
  alert(user + 500); // hint: default -> 1500
</script>

<!-- toString/valueOf -->
<script>
  let user = {
  name: "John",
  money: 1000,

  // for hint="string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // for hint="number" or "default"
  valueOf() {
    return this.money;
  }

};

  alert(user); // toString -> {name: "John"}
  alert(+user); // valueOf -> 1000
  alert(user + 500); // valueOf -> 1500
</script>

<!-- Further conversions -->
<script>
  let obj = {
  // toString handles all conversions in the absence of other methods
  toString() {
    return "2";
  }
};

alert(obj * 2); // 4, object converted to primitive "2", then multiplication made it a number
</script>

<!-- Primitive as object -->
<script>
  let str = "Hello";
  alert( str.toUpperCase() ); // HELLO
</script>

<!-- A number has methods of its own, for instance, toFixed(n) rounds the number to the given precision: -->
<script>
  let n = 1.23456;
  alert( n.toFixed(2) ); // 1.23
</script>