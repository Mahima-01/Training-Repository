What is PostgreSQL?
PostgreSQL (pronounced as post-gress-Q-L) is an open source relational database management system (DBMS) developed by a worldwide team of volunteers. 

Key Features of PostgreSQL
PostgreSQL runs on all major operating systems, including Linux, UNIX (AIX, BSD, HP-UX, SGI IRIX, Mac OS X, Solaris, Tru64), and Windows. 
It supports text, images, sounds, and video, and includes programming interfaces for C / C++, Java, Perl, Python, Ruby, Tcl and Open Database Connectivity (ODBC).

Importance of PostgreSQL:
Stores data securely.
Supports best practices,
Allows retrieving the data when the request is processed.
Is cross-platform and can run on many operating systems including Linux, FreeBSD, OS X, Solaris, and Microsoft Windows.
 
PostgreSQL supports a large part of the SQL standard and offers many modern features including the following −
Complex SQL queries
SQL Sub-selects
Foreign keys
Trigger
Views
Transactions
Multiversion concurrency control (MVCC)
Streaming Replication (as of 9.0)
Hot Standby (as of 9.0)

#Show Databases

\l
                                         List of databases
   Name    |  Owner   | Encoding |      Collate       |       Ctype        |   Access privileges
-----------+----------+----------+--------------------+--------------------+-----------------------
 postgres  | postgres | UTF8     | English_India.1252 | English_India.1252 |
 template0 | postgres | UTF8     | English_India.1252 | English_India.1252 | =c/postgres          +
           |          |          |                    |                    | postgres=CTc/postgres
 template1 | postgres | UTF8     | English_India.1252 | English_India.1252 | =c/postgres          +
           |          |          |                    |                    | postgres=CTc/postgres
(3 rows)

postgres=# CREATE DATABASE TEST;
CREATE DATABASE

test-#
Here # shows I am Super User
test=>
" => " have rights to the database

# To see current date
SELECT current_date;
 current_date
--------------
 2022-03-31
(1 row)

# Running Arithmatic Commands
SELECT 2 + 2;
 ?column?
----------
        4
(1 row)
# \h for help
# \q to quit

# Postgre uses the SQL language
# "-- " to write comments in SQL

Syntax
The basic syntax of CREATE DATABASE statement is as follows −

CREATE DATABASE dbname;
where dbname is the name of a database to create.
# Creating the tables in the databse

test1=# CREATE TABLE weather (
test1(#     city            varchar(80),
test1(#     temp_lo         int,           -- low temperature
test1(#     temp_hi         int,           -- high temperature
test1(#     prcp            real,          -- precipitation
test1(#     date            date
test1(# );
CREATE TABLE
test1=# CREATE TABLE cities (
test1(#     name            varchar(80),
test1(#     location        point
test1(# );
CREATE TABLE

# Deleteing the whole table  
test1=# DROP TABLE cities;
DROP TABLE

Basic syntax of INSERT INTO statement is as follows −

INSERT INTO TABLE_NAME (column1, column2, column3,...columnN)
VALUES (value1, value2, value3,...valueN);
#inserting data in the tables
est1=# INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');
INSERT 0 1
test1=# INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');
INSERT 0 1
test1=# INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
test1-#     VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');
INSERT 0 1
test1=# INSERT INTO weather (date, city, temp_hi, temp_lo)
test1-#     VALUES ('1994-11-29', 'Hayward', 54, 37);
INSERT 0 1

# Quering the data from the to see data 
test1=# SELECT * FROM weather;
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      43 |      57 |    0 | 1994-11-29
 Hayward       |      37 |      54 |      | 1994-11-29
(3 rows)

# Quesring data using Orerators to manipulate data 
test1=# SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;
     city      | temp_avg |    date
---------------+----------+------------
 San Francisco |       48 | 1994-11-27
 San Francisco |       50 | 1994-11-29
 Hayward       |       45 | 1994-11-29
(3 rows)

# Quering data with where clause to seespecific data

test1=# SELECT * FROM weather
test1-#     WHERE city = 'San Francisco' AND prcp > 0.0;
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
(1 row)

# using orderby to arrandata while query it
test1=# SELECT * FROM weather
test1-#     ORDER BY city;
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 Hayward       |      37 |      54 |      | 1994-11-29
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      43 |      57 |    0 | 1994-11-29
(3 rows)

#query uniques data from the table 
test1=# SELECT DISTINCT city
test1-#     FROM weather;
     city
---------------
 Hayward
 San Francisco
(2 rows)

#Using Aggregate Functions MAX
test1=# SELECT max(temp_lo) FROM weather;
 max
-----
  46
(1 row)

test1=# SELECT city, max(temp_lo)
test1-#     FROM weather
test1-#     GROUP BY city;
     city      | max
---------------+-----
 Hayward       |  37
 San Francisco |  46
(2 rows)


test1=# UPDATE weather
test1-#     SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
test1-#     WHERE date > '1994-11-28';
UPDATE 2

#Manupulating the tables

#Deleting the specific data from the table

test1=# DELETE FROM weather WHERE city = 'Hayward';
DELETE 1

# updating the data in the table
test1=# UPDATE weather
test1-#     SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
test1-#     WHERE date > '1994-11-28';
UPDATE 2
test1=# SELECT * FROM weather;
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      41 |      55 |    0 | 1994-11-29
(2 rows)

# Views in SQL are kind of virtual tables. A view also has rows and columns as they are in a real table in the database.

test1=# CREATE VIEW myview AS
test1-#     SELECT name, temp_lo, temp_hi, prcp, date, location
test1-#         FROM weather, cities
test1-#         WHERE city = name;
CREATE VIEW
test1=# SELECT * FROM myview;
     name      | temp_lo | temp_hi | prcp |    date    | location
---------------+---------+---------+------+------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | (-194,53)
 San Francisco |      41 |      55 |    0 | 1994-11-29 | (-194,53)
(2 rows)

FOREIGN KEY Constraint
A foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. 
We say this maintains the referential integrity between two related tables. 
They are called foreign keys because the constraints are foreign; that is, outside the table. 
Foreign keys are sometimes called a referencing key.
For Eg in above table if no data should be added in weather if there is no matching data in cities here we use foriegn keys so Postgresql can do this it self and mintain refrential integrity.
#create table cities with mane as primary key
 create table cities(
 name varchar(80) primary key,
 location point
 );
 ERROR:  relation "cities" already exists
 
 # and make refrence / foreign key of ctiries name column in weather table
 create table weather(
 city varchar(80) references cities(name),
 temp_lo int,
 temp_hi int,
 prcp real,
 date date
 );
 ERROR:  relation "weather" already exists
 # to describe table name
 \d tablename
 test1=# \d cities
                       Table "public.cities"
  Column  |         Type          | Collation | Nullable | Default
----------+-----------------------+-----------+----------+---------
 name     | character varying(80) |           |          |
 location | point                 |           |          |

# adding constrain to existing column in table
alter table cities add constraint cities_pk primary key(name);
ALTER TABLE
test1=# \d cities
                       Table "public.cities"
  Column  |         Type          | Collation | Nullable | Default
----------+-----------------------+-----------+----------+---------
 name     | character varying(80) |           | not null |
 location | point                 |           |          |
Indexes:
    "cities_pk" PRIMARY KEY, btree (name)
	
# Alter table to add foreign key constraints
alter table weather add constraint weather_pk foreign key (city) references cities(name);
ALTER TABLE

                      Table "public.weather"
 Column  |         Type          | Collation | Nullable | Default
---------+-----------------------+-----------+----------+---------
 city    | character varying(80) |           |          |
 temp_lo | integer               |           |          |
 temp_hi | integer               |           |          |
 prcp    | real                  |           |          |
 date    | date                  |           |          |
Foreign-key constraints:
    "weather_pk" FOREIGN KEY (city) REFERENCES cities(name)

#insert error due to Berkley not present in cities table
test1=# INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');
ERROR:  insert or update on table "weather" violates foreign key constraint "weather_pk"
DETAIL:  Key (city)=(Berkeley) is not present in table "cities".

Joins:
oins clause is used to combine records from two or more tables in a database. 
A JOIN is a means for combining fields from two tables by using values common to each.
1.The CROSS JOIN
A CROSS JOIN matches every row of the first table with every row of the second table.
If the input tables have x and y columns, respectively, the resulting table will have x+y columns.
2.A INNER JOIN 
creates a new result table by combining column values of two tables (table1 and table2) based upon the join-predicate.
An INNER JOIN is the most common type of join and is the default type of join.
3.The LEFT OUTER JOIN
The OUTER JOIN is an extension of the INNER JOIN. SQL standard defines three types of OUTER JOINs: LEFT, RIGHT, and FULL and PostgreSQL supports all of these.
LEFT (OUTER) JOIN: Returns all records from the left table, and the matched records from the right table
RIGHT (OUTER) JOIN: Returns all records from the right table, and the matched records from the left table

SELECT * FROM weather JOIN cities ON city = name;
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(2 rows)


test1=# SELECT weather.city, weather.temp_lo, weather.temp_hi,
test1-#        weather.prcp, weather.date, cities.location
test1-#     FROM weather JOIN cities ON weather.city = cities.name;
     city      | temp_lo | temp_hi | prcp |    date    | location
---------------+---------+---------+------+------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | (-194,53)
(2 rows)


test1=# SELECT *
test1-#     FROM weather LEFT OUTER JOIN cities ON weather.city = cities.name;
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
 Hayward       |      37 |      54 |      | 1994-11-29 |               |
(3 rows)


test1=# SELECT w1.city, w1.temp_lo AS low, w1.temp_hi AS high,
test1-#        w2.city, w2.temp_lo AS low, w2.temp_hi AS high
test1-#     FROM weather w1 JOIN weather w2
test1-#         ON w1.temp_lo < w2.temp_lo AND w1.temp_hi > w2.temp_hi;
     city      | low | high |     city      | low | high
---------------+-----+------+---------------+-----+------
 San Francisco |  43 |   57 | San Francisco |  46 |   50
 Hayward       |  37 |   54 | San Francisco |  46 |   50
 
 test1=# SELECT *
test1-#     FROM weather w JOIN cities c ON w.city = c.name;
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(2 rows)


Transaction
A transaction is a unit of work that is performed against a database. 
Transactions are units or sequences of work accomplished in a logical order, whether in a manual fashion by a user or automatically by some sort of a database program.
A transaction is the propagation of one or more changes to the database. 
For example, if you are creating a record, updating a record, or deleting a record from the table, then you are performing transaction on the table. 
It is important to control transactions to ensure data integrity and to handle database errors.
The following commands are used to control transactions −
BEGIN TRANSACTION − To start a transaction.
Transactions can be started using BEGIN TRANSACTION or simply BEGIN command.
COMMIT − To save the changes, alternatively you can use END TRANSACTION command.
ROLLBACK − To rollback the changes.

Inheritance
Inheritance in PostgreSQL allows you to create a child table based on another table, and the child table will include all of the columns in the parent table.
test1=# CREATE TABLE city (
test1(#  name text,
test1(#  population real,
test1(#  elevation int -- (in ft)
test1(# );
CREATE TABLE
test1=# CREATE TABLE capitals (
test1(#  state char(2) UNIQUE NOT NULL
test1(# ) INHERITS (city);
CREATE TABLE
test1=# \d capitals
                  Table "public.capitals"
   Column   |     Type     | Collation | Nullable | Default
------------+--------------+-----------+----------+---------
 name       | text         |           |          |
 population | real         |           |          |
 elevation  | integer      |           |          |
 state      | character(2) |           | not null |
Indexes:
    "capitals_state_key" UNIQUE CONSTRAINT, btree (state)
Inherits: city
test1=# insert into capitals values('chandigarh',1234,11,'HA');
INSERT 0 1
test1=# insert into city values('faridabad',1224,112);
INSERT 0 1
test1=# select * from city;
    name    | population | elevation
------------+------------+-----------
 faridabad  |       1224 |       112
 chandigarh |       1234 |        11
(2 rows)

# only to get data from only city
test1=# select * from only city;
   name    | population | elevation
-----------+------------+-----------
 faridabad |       1224 |       112
(1 row)


test1=# select * from  capitals;
    name    | population | elevation | state
------------+------------+-----------+-------
 chandigarh |       1234 |        11 | HA
(1 row)

PostgreSQL - UNIONS Clause
The PostgreSQL UNION clause/operator is used to combine the results of two or more SELECT statements without returning any duplicate rows.
To use UNION, each SELECT must have the same number of columns selected, 
the same number of column expressions, the same data type, and have them in the same order but they do not have to be the same length.

The basic syntax of UNION is as follows −
SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]
UNION
SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]

The UNION ALL Clause
The UNION ALL operator is used to combine the results of two SELECT statements including duplicate rows. 
The same rules that apply to UNION apply to the UNION ALL operator as well.
SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]

UNION ALL
SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]

#SQL syntax
#Lexical Structure
sequenceof tokens terminated by ;
Tokens can be hayward , identifier, constants or literal or special symbol
#Identifier
They identify name of tables columns or other db objects called names
starts with [9-2) followed by any alphabet, digit unserscore or $
They are case insensitive
convention  is to write key words in upper case and names in lower case
#then there is : the delimited identifier or quoted identifier
It is token in quotes whiuch is never treated as keyword
Then can contain ny character except 0
they are case sensitive

# Constants
Three kinds of implicitly-typed constants in PostgreSQL: 
>strings-  A string constant in SQL is an arbitrary sequence of characters bounded by single quotes ('), for example 'This is a string'
,> bit strings, - 
 and >numbers -
Constants can also be specified with explicit types, which can enable more accurate representation and
more efficient handling by the system
Backslash Escape Sequenceand its  Interpretation
\b - backspace
\f - form feed
\n - newline
\r - carriage return
\t - tab
\o, \oo, \ooo (o = 0–7) - octal byte value
\xh, \xhh (h = 0–9, A–F) - hexadecimal byte value
\uxxxx, \Uxxxxxxxx (x = 0–9, A–F) 16 or 32-bit - hexadecimal Unicode character
value
*Dollar-Quoted String Constants to revisit???

#Bit-String Constants
Bit-string constants look like regular string constants with a B (upper or lower case) immediately before the opening quote (no intervening whitespace),
e.g., B'1001'. The only characters allowed within bit-string constants are 0 and 1 and for hexadecimal b is replaced with x eg x'12ABF'

#Numeric Constants
Numeric constants are accepted in these general forms:
digits
digits.[digits][e[+-]digits]    --exponent marker (e)
[digits].digits[e[+-]digits]
digitse[+-]digits

Typecasting REAL '1.23' numeric treated as Real(float64)


PostgreSQL built-in functions also Aggregate Function.

# Count the number rows in the query
test1=# SELECT COUNT(*) FROM city ;
 count
-------
     2
(1 row)

test1=# SELECT * FROM city where name = 'faridabad';
   name    | population | elevation
-----------+------------+-----------
 faridabad |       1224 |       112
(1 row)


test1=# SELECT count(*) FROM city where name = 'faridabad';
 count
-------
     1
(1 row)

#MAX show the maximum value of the column selected
 test1=# select  max(elevation) from city;
 max
-----
 112
(1 row)

#MIN show the minimum value of the column selected
test1=# select  min(elevation) from city;
 min
-----
  11
(1 row)

# Can see max and min in same time
test1=# select  min(elevation) ,max(elevation) from city;
 min | max
-----+-----
  11 | 112
(1 row)

# Group by in MAX or MIN will show each min / max of group.
test1=# select * from city;
    name    |  population  | elevation
------------+--------------+-----------
 faridabad  |         1224 |       112
 faridabad  | 1.212121e+06 |     12121
 chandigarh |         1234 |        11
(3 rows)


test1=# select name, max(elevation) from city group by name;
    name    |  max
------------+-------
 chandigarh |    11
 faridabad  | 12121
(2 rows)

# AVG - shows the average of the selected column
test1=# select avg(elevation) from city;
          avg
-----------------------
 4081.3333333333333333
(1 row)

test1=# select avg(elevation) from city group by name;
          avg
-----------------------
   11.0000000000000000
 6116.5000000000000000
(2 rows)

# Sum - JUst Like avg it sums up all the rows of the selected column
test1=# select sum(elevation) from city;
  sum
-------
 12244
(1 row)


test1=# select sum(elevation) from city group by name;
  sum
-------
    11
 12233
(2 rows)


#Array_agg concatenate the values into array
test1=# select array_agg(elevation) from city;
   array_agg
----------------
 {112,12121,11}
(1 row)


test1=# select array_agg(name) from city;
            array_agg
----------------------------------
 {faridabad,faridabad,chandigarh}
(1 row)



Numeric Functions

The ABS() function returns the absolute value of X.
test1=# SELECT ABS(-2);
 abs
-----
   2
(1 row)

ACOS(X) -  returns the arccosine of X. The value of X must range between -1 and 1 or NULL will be returned

test1=# SELECT ACOS(1);
 acos
------
    0
(1 row)


test1=# SELECT ACOS(-11);
ERROR:  input is out of range
test1=# SELECT ACOS(-1);
       acos
-------------------
 3.141592653589793
(1 row)

ASIN(X)- like acos() The ASIN() function returns the arcsine of X range[-1,1]
test1=# SELECT ASIN(1);
        asin
--------------------
 1.5707963267948966
(1 row)


test1=# SELECT ASIN(0);
 asin
------
    0
(1 row)

ATAN(X) - This function returns the arctangent of X.

test1=# SELECT ATAN(0);
 atan
------
    0
(1 row)


test1=# SELECT ATAN(1);
        atan
--------------------
 0.7853981633974483
(1 row)

ATAN2(Y,X)
This function returns the arctangent of the two arguments: X and Y. It is similar to the arctangent of Y/X, except that the signs of both are used to find the quadrant of the result.--???????
test1=# SELECT ATAN2(3,6);
       atan2
--------------------
 0.4636476090008061
(1 row)

CEIL(X) / CEILING(X)  - Return the smaller integer value just bigger than arg
test1=# select ceil(3.232);
 ceil
------
    4
(1 row) 

test1=# select ceil(3.0);
 ceil
------
    3
(1 row)
test1=# select ceil(-3.123);
 ceil
------
   -3
(1 row)

Floor(x)-  Return the bigger integer value just smaller than arg
test1=# select floor (2.3343);
 floor
-------
     2
(1 row)

test1=# select floor (-2.3343);
 floor
-------
    -3
(1 row)

GREATEST(n1,n2,n3,..........)- Give the greates vlue from the no of parameters.
test1=# select greatest(121,323,423,31,445,224,25345,4,23,4234,234,32423);
 greatest
----------
    32423
(1 row)

LEAST(N1,N2,N3,N4,......) - gives the least values from the no of parameters.
test1=# select least(121,323,423,31,445,224,25345,4,23,4234,234,32423);
 least
-------
     4
(1 row)

COS(X) -This function returns the cosine of X (in degrees)
test1=# select cos(0);
 cos
-----
   1
(1 row)


test1=# select cos(90);
         cos
---------------------
 -0.4480736161291701
(1 row)

COT(X) -This function returns the cotangent of X --???
test1=# SELECT COT(1);
        cot
--------------------
 0.6420926159343306
(1 row)

DEGREES(X)- This function returns the value of X converted from radians to degrees
test1=# SELECT DEGREES(PI());
 degrees
---------
     180
(1 row)


test1=# SELECT DEGREES(1);
      degrees
-------------------
 57.29577951308232
(1 row)

# pi() - returns the value of pi
test1=# select pi();
        pi
-------------------
 3.141592653589793
(1 row)

EXP(X) returns e^x.
test1=# SELECT EXP(3);
        exp
--------------------
 20.085536923187668
(1 row)

test1=# SELECT EXP(1);
        exp
-------------------
 2.718281828459045
(1 row)

LOG(X) / LOG(B,X) -  returns the value of log to natural base or base B
test1=# SELECT LOG(45);
        log
--------------------
 1.6532125137753437
(1 row)


test1=# SELECT LOG(1);
 log
-----
   0
(1 row)

test1=# SELECT LOG(2,65536);
        log
--------------------
 16.000000000000000
(1 row)

MOD(N,M) - retuns remainder n/m
test1=# SELECT mod(9,2);
 mod
-----
   1
(1 row)

POW(X,Y) / POWER(X,Y)-returns x^y
test1=# select pow(3,2);
 pow
-----
   9
(1 row)

RADIANS(X)-  converted from degrees to radians.
test1=# SELECT RADIANS(90);
      radians
--------------------
 1.5707963267948966
(1 row)

ROUND(X) / ROUND(X,D) - round to integer or nearest D decimal points
test1=# SELECT ROUND(5.693893);
 round
-------
     6
(1 row)


test1=# SELECT ROUND(5.693893,2);
 round
-------
  5.69
(1 row)

SIGN(X)- returns the sign of X (negative, zero, or positive) as -1, 0, or 1.
test1=# SELECT SIGN(0);
 sign
------
    0
(1 row)


test1=# SELECT SIGN(-0);
 sign
------
    0
(1 row)


test1=# SELECT SIGN(-1.2);
 sign
------
   -1
(1 row)


test1=# SELECT SIGN(1.2);
 sign
------
    1
(1 row)

SIN(X)- This function returns the sine of X
test1=# select sin(90);
        sin
--------------------
 0.8939966636005579
(1 row)
SQRT(X) -returns the non-negative square root of X.
test1=# select sqrt(9);
 sqrt
------
    3
(1 row)
