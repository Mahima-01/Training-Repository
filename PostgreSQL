What is PostgreSQL?
PostgreSQL (pronounced as post-gress-Q-L) is an open source relational database management system (DBMS) developed by a worldwide team of volunteers. 

Key Features of PostgreSQL
PostgreSQL runs on all major operating systems, including Linux, UNIX (AIX, BSD, HP-UX, SGI IRIX, Mac OS X, Solaris, Tru64), and Windows. 
It supports text, images, sounds, and video, and includes programming interfaces for C / C++, Java, Perl, Python, Ruby, Tcl and Open Database Connectivity (ODBC).

Importance of PostgreSQL:
Stores data securely.
Supports best practices,
Allows retrieving the data when the request is processed.
Is cross-platform and can run on many operating systems including Linux, FreeBSD, OS X, Solaris, and Microsoft Windows.
 
PostgreSQL supports a large part of the SQL standard and offers many modern features including the following −
Complex SQL queries
SQL Sub-selects
Foreign keys
Trigger
Views
Transactions
Multiversion concurrency control (MVCC)
Streaming Replication (as of 9.0)
Hot Standby (as of 9.0)

#Show Databases

\l
                                         List of databases
   Name    |  Owner   | Encoding |      Collate       |       Ctype        |   Access privileges
-----------+----------+----------+--------------------+--------------------+-----------------------
 postgres  | postgres | UTF8     | English_India.1252 | English_India.1252 |
 template0 | postgres | UTF8     | English_India.1252 | English_India.1252 | =c/postgres          +
           |          |          |                    |                    | postgres=CTc/postgres
 template1 | postgres | UTF8     | English_India.1252 | English_India.1252 | =c/postgres          +
           |          |          |                    |                    | postgres=CTc/postgres
(3 rows)

postgres=# CREATE DATABASE TEST;
CREATE DATABASE

test-#
Here # shows I am Super User
test=>
" => " have rights to the database

# To see current date
SELECT current_date;
 current_date
--------------
 2022-03-31
(1 row)

# Running Arithmatic Commands
SELECT 2 + 2;
 ?column?
----------
        4
(1 row)
# \h for help
# \q to quit

# Postgre uses the SQL language
# "-- " to write comments in SQL

Syntax
The basic syntax of CREATE DATABASE statement is as follows −

CREATE DATABASE dbname;
where dbname is the name of a database to create.
# Creating the tables in the databse

test1=# CREATE TABLE weather (
test1(#     city            varchar(80),
test1(#     temp_lo         int,           -- low temperature
test1(#     temp_hi         int,           -- high temperature
test1(#     prcp            real,          -- precipitation
test1(#     date            date
test1(# );
CREATE TABLE
test1=# CREATE TABLE cities (
test1(#     name            varchar(80),
test1(#     location        point
test1(# );
CREATE TABLE

# Deleteing the whole table  
test1=# DROP TABLE cities;
DROP TABLE

Basic syntax of INSERT INTO statement is as follows −

INSERT INTO TABLE_NAME (column1, column2, column3,...columnN)
VALUES (value1, value2, value3,...valueN);
#inserting data in the tables
est1=# INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');
INSERT 0 1
test1=# INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');
INSERT 0 1
test1=# INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
test1-#     VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');
INSERT 0 1
test1=# INSERT INTO weather (date, city, temp_hi, temp_lo)
test1-#     VALUES ('1994-11-29', 'Hayward', 54, 37);
INSERT 0 1

# Quering the data from the to see data 
test1=# SELECT * FROM weather;
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      43 |      57 |    0 | 1994-11-29
 Hayward       |      37 |      54 |      | 1994-11-29
(3 rows)

# Quesring data using Orerators to manipulate data 
test1=# SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;
     city      | temp_avg |    date
---------------+----------+------------
 San Francisco |       48 | 1994-11-27
 San Francisco |       50 | 1994-11-29
 Hayward       |       45 | 1994-11-29
(3 rows)

# Quering data with where clause to seespecific data

test1=# SELECT * FROM weather
test1-#     WHERE city = 'San Francisco' AND prcp > 0.0;
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
(1 row)

# using orderby to arrandata while query it
test1=# SELECT * FROM weather
test1-#     ORDER BY city;
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 Hayward       |      37 |      54 |      | 1994-11-29
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      43 |      57 |    0 | 1994-11-29
(3 rows)

#query uniques data from the table 
test1=# SELECT DISTINCT city
test1-#     FROM weather;
     city
---------------
 Hayward
 San Francisco
(2 rows)

#Using Aggregate Functions MAX
test1=# SELECT max(temp_lo) FROM weather;
 max
-----
  46
(1 row)

test1=# SELECT city, max(temp_lo)
test1-#     FROM weather
test1-#     GROUP BY city;
     city      | max
---------------+-----
 Hayward       |  37
 San Francisco |  46
(2 rows)


test1=# UPDATE weather
test1-#     SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
test1-#     WHERE date > '1994-11-28';
UPDATE 2

#Manupulating the tables

#Deleting the specific data from the table

test1=# DELETE FROM weather WHERE city = 'Hayward';
DELETE 1

# updating the data in the table
test1=# UPDATE weather
test1-#     SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
test1-#     WHERE date > '1994-11-28';
UPDATE 2
test1=# SELECT * FROM weather;
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      41 |      55 |    0 | 1994-11-29
(2 rows)

# Views in SQL are kind of virtual tables. A view also has rows and columns as they are in a real table in the database.

test1=# CREATE VIEW myview AS
test1-#     SELECT name, temp_lo, temp_hi, prcp, date, location
test1-#         FROM weather, cities
test1-#         WHERE city = name;
CREATE VIEW
test1=# SELECT * FROM myview;
     name      | temp_lo | temp_hi | prcp |    date    | location
---------------+---------+---------+------+------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | (-194,53)
 San Francisco |      41 |      55 |    0 | 1994-11-29 | (-194,53)
(2 rows)

FOREIGN KEY Constraint
A foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. 
We say this maintains the referential integrity between two related tables. 
They are called foreign keys because the constraints are foreign; that is, outside the table. 
Foreign keys are sometimes called a referencing key.
For Eg in above table if no data should be added in weather if there is no matching data in cities here we use foriegn keys so Postgresql can do this it self and mintain refrential integrity.
#create table cities with mane as primary key
 create table cities(
 name varchar(80) primary key,
 location point
 );
 ERROR:  relation "cities" already exists
 
 # and make refrence / foreign key of ctiries name column in weather table
 create table weather(
 city varchar(80) references cities(name),
 temp_lo int,
 temp_hi int,
 prcp real,
 date date
 );
 ERROR:  relation "weather" already exists
 # to describe table name
 \d tablename
 test1=# \d cities
                       Table "public.cities"
  Column  |         Type          | Collation | Nullable | Default
----------+-----------------------+-----------+----------+---------
 name     | character varying(80) |           |          |
 location | point                 |           |          |

# adding constrain to existing column in table
alter table cities add constraint cities_pk primary key(name);
ALTER TABLE
test1=# \d cities
                       Table "public.cities"
  Column  |         Type          | Collation | Nullable | Default
----------+-----------------------+-----------+----------+---------
 name     | character varying(80) |           | not null |
 location | point                 |           |          |
Indexes:
    "cities_pk" PRIMARY KEY, btree (name)
	
# Alter table to add foreign key constraints
alter table weather add constraint weather_pk foreign key (city) references cities(name);
ALTER TABLE

                      Table "public.weather"
 Column  |         Type          | Collation | Nullable | Default
---------+-----------------------+-----------+----------+---------
 city    | character varying(80) |           |          |
 temp_lo | integer               |           |          |
 temp_hi | integer               |           |          |
 prcp    | real                  |           |          |
 date    | date                  |           |          |
Foreign-key constraints:
    "weather_pk" FOREIGN KEY (city) REFERENCES cities(name)

#insert error due to Berkley not present in cities table
test1=# INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');
ERROR:  insert or update on table "weather" violates foreign key constraint "weather_pk"
DETAIL:  Key (city)=(Berkeley) is not present in table "cities".

Joins:
oins clause is used to combine records from two or more tables in a database. 
A JOIN is a means for combining fields from two tables by using values common to each.
1.The CROSS JOIN
A CROSS JOIN matches every row of the first table with every row of the second table.
If the input tables have x and y columns, respectively, the resulting table will have x+y columns.
2.A INNER JOIN 
creates a new result table by combining column values of two tables (table1 and table2) based upon the join-predicate.
An INNER JOIN is the most common type of join and is the default type of join.
3.The LEFT OUTER JOIN
The OUTER JOIN is an extension of the INNER JOIN. SQL standard defines three types of OUTER JOINs: LEFT, RIGHT, and FULL and PostgreSQL supports all of these.
LEFT (OUTER) JOIN: Returns all records from the left table, and the matched records from the right table
RIGHT (OUTER) JOIN: Returns all records from the right table, and the matched records from the left table

SELECT * FROM weather JOIN cities ON city = name;
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(2 rows)


test1=# SELECT weather.city, weather.temp_lo, weather.temp_hi,
test1-#        weather.prcp, weather.date, cities.location
test1-#     FROM weather JOIN cities ON weather.city = cities.name;
     city      | temp_lo | temp_hi | prcp |    date    | location
---------------+---------+---------+------+------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | (-194,53)
(2 rows)


test1=# SELECT *
test1-#     FROM weather LEFT OUTER JOIN cities ON weather.city = cities.name;
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
 Hayward       |      37 |      54 |      | 1994-11-29 |               |
(3 rows)


test1=# SELECT w1.city, w1.temp_lo AS low, w1.temp_hi AS high,
test1-#        w2.city, w2.temp_lo AS low, w2.temp_hi AS high
test1-#     FROM weather w1 JOIN weather w2
test1-#         ON w1.temp_lo < w2.temp_lo AND w1.temp_hi > w2.temp_hi;
     city      | low | high |     city      | low | high
---------------+-----+------+---------------+-----+------
 San Francisco |  43 |   57 | San Francisco |  46 |   50
 Hayward       |  37 |   54 | San Francisco |  46 |   50
 
 test1=# SELECT *
test1-#     FROM weather w JOIN cities c ON w.city = c.name;
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(2 rows)


Transaction
A transaction is a unit of work that is performed against a database. 
Transactions are units or sequences of work accomplished in a logical order, whether in a manual fashion by a user or automatically by some sort of a database program.
A transaction is the propagation of one or more changes to the database. 
For example, if you are creating a record, updating a record, or deleting a record from the table, then you are performing transaction on the table. 
It is important to control transactions to ensure data integrity and to handle database errors.
The following commands are used to control transactions −
BEGIN TRANSACTION − To start a transaction.
Transactions can be started using BEGIN TRANSACTION or simply BEGIN command.
COMMIT − To save the changes, alternatively you can use END TRANSACTION command.
ROLLBACK − To rollback the changes.

Inheritance
Inheritance in PostgreSQL allows you to create a child table based on another table, and the child table will include all of the columns in the parent table.
test1=# CREATE TABLE city (
test1(#  name text,
test1(#  population real,
test1(#  elevation int -- (in ft)
test1(# );
CREATE TABLE
test1=# CREATE TABLE capitals (
test1(#  state char(2) UNIQUE NOT NULL
test1(# ) INHERITS (city);
CREATE TABLE
test1=# \d capitals
                  Table "public.capitals"
   Column   |     Type     | Collation | Nullable | Default
------------+--------------+-----------+----------+---------
 name       | text         |           |          |
 population | real         |           |          |
 elevation  | integer      |           |          |
 state      | character(2) |           | not null |
Indexes:
    "capitals_state_key" UNIQUE CONSTRAINT, btree (state)
Inherits: city
test1=# insert into capitals values('chandigarh',1234,11,'HA');
INSERT 0 1
test1=# insert into city values('faridabad',1224,112);
INSERT 0 1
test1=# select * from city;
    name    | population | elevation
------------+------------+-----------
 faridabad  |       1224 |       112
 chandigarh |       1234 |        11
(2 rows)

# only to get data from only city
test1=# select * from only city;
   name    | population | elevation
-----------+------------+-----------
 faridabad |       1224 |       112
(1 row)


test1=# select * from  capitals;
    name    | population | elevation | state
------------+------------+-----------+-------
 chandigarh |       1234 |        11 | HA
(1 row)

PostgreSQL - UNIONS Clause
The PostgreSQL UNION clause/operator is used to combine the results of two or more SELECT statements without returning any duplicate rows.
To use UNION, each SELECT must have the same number of columns selected, 
the same number of column expressions, the same data type, and have them in the same order but they do not have to be the same length.

The basic syntax of UNION is as follows −
SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]
UNION
SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]

The UNION ALL Clause
The UNION ALL operator is used to combine the results of two SELECT statements including duplicate rows. 
The same rules that apply to UNION apply to the UNION ALL operator as well.
SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]

UNION ALL
SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]
