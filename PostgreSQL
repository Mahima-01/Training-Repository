What is PostgreSQL?
PostgreSQL (pronounced as post-gress-Q-L) is an open source relational database management system (DBMS) developed by a worldwide team of volunteers. 

Key Features of PostgreSQL
PostgreSQL runs on all major operating systems, including Linux, UNIX (AIX, BSD, HP-UX, SGI IRIX, Mac OS X, Solaris, Tru64), and Windows. 
It supports text, images, sounds, and video, and includes programming interfaces for C / C++, Java, Perl, Python, Ruby, Tcl and Open Database Connectivity (ODBC).

Importance of PostgreSQL:
Stores data securely.
Supports best practices,
Allows retrieving the data when the request is processed.
Is cross-platform and can run on many operating systems including Linux, FreeBSD, OS X, Solaris, and Microsoft Windows.
 
PostgreSQL supports a large part of the SQL standard and offers many modern features including the following −
Complex SQL queries
SQL Sub-selects
Foreign keys
Trigger
Views
Transactions
Multiversion concurrency control (MVCC)
Streaming Replication (as of 9.0)
Hot Standby (as of 9.0)

#Show Databases

\l
                                         List of databases
   Name    |  Owner   | Encoding |      Collate       |       Ctype        |   Access privileges
-----------+----------+----------+--------------------+--------------------+-----------------------
 postgres  | postgres | UTF8     | English_India.1252 | English_India.1252 |
 template0 | postgres | UTF8     | English_India.1252 | English_India.1252 | =c/postgres          +
           |          |          |                    |                    | postgres=CTc/postgres
 template1 | postgres | UTF8     | English_India.1252 | English_India.1252 | =c/postgres          +
           |          |          |                    |                    | postgres=CTc/postgres
(3 rows)

postgres=# CREATE DATABASE TEST;
CREATE DATABASE

test-#
Here # shows I am Super User
test=>
" => " have rights to the database

# To see current date
SELECT current_date;
 current_date
--------------
 2022-03-31
(1 row)

# Running Arithmatic Commands
SELECT 2 + 2;
 ?column?
----------
        4
(1 row)
# \h for help
# \q to quit

# Postgre uses the SQL language
# "-- " to write comments in SQL

Syntax
The basic syntax of CREATE DATABASE statement is as follows −

CREATE DATABASE dbname;
where dbname is the name of a database to create.
# Creating the tables in the databse

test1=# CREATE TABLE weather (
test1(#     city            varchar(80),
test1(#     temp_lo         int,           -- low temperature
test1(#     temp_hi         int,           -- high temperature
test1(#     prcp            real,          -- precipitation
test1(#     date            date
test1(# );
CREATE TABLE
test1=# CREATE TABLE cities (
test1(#     name            varchar(80),
test1(#     location        point
test1(# );
CREATE TABLE

# Deleteing the whole table  
test1=# DROP TABLE cities;
DROP TABLE

Basic syntax of INSERT INTO statement is as follows −

INSERT INTO TABLE_NAME (column1, column2, column3,...columnN)
VALUES (value1, value2, value3,...valueN);
#inserting data in the tables
est1=# INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');
INSERT 0 1
test1=# INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');
INSERT 0 1
test1=# INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
test1-#     VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');
INSERT 0 1
test1=# INSERT INTO weather (date, city, temp_hi, temp_lo)
test1-#     VALUES ('1994-11-29', 'Hayward', 54, 37);
INSERT 0 1

# Quering the data from the to see data 
test1=# SELECT * FROM weather;
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      43 |      57 |    0 | 1994-11-29
 Hayward       |      37 |      54 |      | 1994-11-29
(3 rows)

# Quesring data using Orerators to manipulate data 
test1=# SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;
     city      | temp_avg |    date
---------------+----------+------------
 San Francisco |       48 | 1994-11-27
 San Francisco |       50 | 1994-11-29
 Hayward       |       45 | 1994-11-29
(3 rows)

# Quering data with where clause to seespecific data

test1=# SELECT * FROM weather
test1-#     WHERE city = 'San Francisco' AND prcp > 0.0;
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
(1 row)

# using orderby to arrandata while query it
test1=# SELECT * FROM weather
test1-#     ORDER BY city;
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 Hayward       |      37 |      54 |      | 1994-11-29
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      43 |      57 |    0 | 1994-11-29
(3 rows)

#query uniques data from the table 
test1=# SELECT DISTINCT city
test1-#     FROM weather;
     city
---------------
 Hayward
 San Francisco
(2 rows)

#Using Aggregate Functions MAX
test1=# SELECT max(temp_lo) FROM weather;
 max
-----
  46
(1 row)

test1=# SELECT city, max(temp_lo)
test1-#     FROM weather
test1-#     GROUP BY city;
     city      | max
---------------+-----
 Hayward       |  37
 San Francisco |  46
(2 rows)


test1=# UPDATE weather
test1-#     SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
test1-#     WHERE date > '1994-11-28';
UPDATE 2

#Manupulating the tables

#Deleting the specific data from the table

test1=# DELETE FROM weather WHERE city = 'Hayward';
DELETE 1

# updating the data in the table
test1=# UPDATE weather
test1-#     SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
test1-#     WHERE date > '1994-11-28';
UPDATE 2
test1=# SELECT * FROM weather;
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      41 |      55 |    0 | 1994-11-29
(2 rows)

# Views in SQL are kind of virtual tables. A view also has rows and columns as they are in a real table in the database.

test1=# CREATE VIEW myview AS
test1-#     SELECT name, temp_lo, temp_hi, prcp, date, location
test1-#         FROM weather, cities
test1-#         WHERE city = name;
CREATE VIEW
test1=# SELECT * FROM myview;
     name      | temp_lo | temp_hi | prcp |    date    | location
---------------+---------+---------+------+------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | (-194,53)
 San Francisco |      41 |      55 |    0 | 1994-11-29 | (-194,53)
(2 rows)

FOREIGN KEY Constraint
A foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. 
We say this maintains the referential integrity between two related tables. 
They are called foreign keys because the constraints are foreign; that is, outside the table. 
Foreign keys are sometimes called a referencing key.
For Eg in above table if no data should be added in weather if there is no matching data in cities here we use foriegn keys so Postgresql can do this it self and mintain refrential integrity.
#create table cities with mane as primary key
 create table cities(
 name varchar(80) primary key,
 location point
 );
 ERROR:  relation "cities" already exists
 
 # and make refrence / foreign key of ctiries name column in weather table
 create table weather(
 city varchar(80) references cities(name),
 temp_lo int,
 temp_hi int,
 prcp real,
 date date
 );
 ERROR:  relation "weather" already exists
 # to describe table name
 \d tablename
 test1=# \d cities
                       Table "public.cities"
  Column  |         Type          | Collation | Nullable | Default
----------+-----------------------+-----------+----------+---------
 name     | character varying(80) |           |          |
 location | point                 |           |          |

# adding constrain to existing column in table
alter table cities add constraint cities_pk primary key(name);
ALTER TABLE
test1=# \d cities
                       Table "public.cities"
  Column  |         Type          | Collation | Nullable | Default
----------+-----------------------+-----------+----------+---------
 name     | character varying(80) |           | not null |
 location | point                 |           |          |
Indexes:
    "cities_pk" PRIMARY KEY, btree (name)
	
# Alter table to add foreign key constraints
alter table weather add constraint weather_pk foreign key (city) references cities(name);
ALTER TABLE

                      Table "public.weather"
 Column  |         Type          | Collation | Nullable | Default
---------+-----------------------+-----------+----------+---------
 city    | character varying(80) |           |          |
 temp_lo | integer               |           |          |
 temp_hi | integer               |           |          |
 prcp    | real                  |           |          |
 date    | date                  |           |          |
Foreign-key constraints:
    "weather_pk" FOREIGN KEY (city) REFERENCES cities(name)

#insert error due to Berkley not present in cities table
test1=# INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');
ERROR:  insert or update on table "weather" violates foreign key constraint "weather_pk"
DETAIL:  Key (city)=(Berkeley) is not present in table "cities".

Joins:
oins clause is used to combine records from two or more tables in a database. 
A JOIN is a means for combining fields from two tables by using values common to each.
1.The CROSS JOIN
A CROSS JOIN matches every row of the first table with every row of the second table.
If the input tables have x and y columns, respectively, the resulting table will have x+y columns.
2.A INNER JOIN 
creates a new result table by combining column values of two tables (table1 and table2) based upon the join-predicate.
An INNER JOIN is the most common type of join and is the default type of join.
3.The LEFT OUTER JOIN
The OUTER JOIN is an extension of the INNER JOIN. SQL standard defines three types of OUTER JOINs: LEFT, RIGHT, and FULL and PostgreSQL supports all of these.
LEFT (OUTER) JOIN: Returns all records from the left table, and the matched records from the right table
RIGHT (OUTER) JOIN: Returns all records from the right table, and the matched records from the left table

SELECT * FROM weather JOIN cities ON city = name;
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(2 rows)


test1=# SELECT weather.city, weather.temp_lo, weather.temp_hi,
test1-#        weather.prcp, weather.date, cities.location
test1-#     FROM weather JOIN cities ON weather.city = cities.name;
     city      | temp_lo | temp_hi | prcp |    date    | location
---------------+---------+---------+------+------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | (-194,53)
(2 rows)


test1=# SELECT *
test1-#     FROM weather LEFT OUTER JOIN cities ON weather.city = cities.name;
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
 Hayward       |      37 |      54 |      | 1994-11-29 |               |
(3 rows)


test1=# SELECT w1.city, w1.temp_lo AS low, w1.temp_hi AS high,
test1-#        w2.city, w2.temp_lo AS low, w2.temp_hi AS high
test1-#     FROM weather w1 JOIN weather w2
test1-#         ON w1.temp_lo < w2.temp_lo AND w1.temp_hi > w2.temp_hi;
     city      | low | high |     city      | low | high
---------------+-----+------+---------------+-----+------
 San Francisco |  43 |   57 | San Francisco |  46 |   50
 Hayward       |  37 |   54 | San Francisco |  46 |   50
 
 test1=# SELECT *
test1-#     FROM weather w JOIN cities c ON w.city = c.name;
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(2 rows)


Transaction
A transaction is a unit of work that is performed against a database. 
Transactions are units or sequences of work accomplished in a logical order, whether in a manual fashion by a user or automatically by some sort of a database program.
A transaction is the propagation of one or more changes to the database. 
For example, if you are creating a record, updating a record, or deleting a record from the table, then you are performing transaction on the table. 
It is important to control transactions to ensure data integrity and to handle database errors.
The following commands are used to control transactions −
BEGIN TRANSACTION − To start a transaction.
Transactions can be started using BEGIN TRANSACTION or simply BEGIN command.
COMMIT − To save the changes, alternatively you can use END TRANSACTION command.
ROLLBACK − To rollback the changes.

Inheritance
Inheritance in PostgreSQL allows you to create a child table based on another table, and the child table will include all of the columns in the parent table.
test1=# CREATE TABLE city (
test1(#  name text,
test1(#  population real,
test1(#  elevation int -- (in ft)
test1(# );
CREATE TABLE
test1=# CREATE TABLE capitals (
test1(#  state char(2) UNIQUE NOT NULL
test1(# ) INHERITS (city);
CREATE TABLE
test1=# \d capitals
                  Table "public.capitals"
   Column   |     Type     | Collation | Nullable | Default
------------+--------------+-----------+----------+---------
 name       | text         |           |          |
 population | real         |           |          |
 elevation  | integer      |           |          |
 state      | character(2) |           | not null |
Indexes:
    "capitals_state_key" UNIQUE CONSTRAINT, btree (state)
Inherits: city
test1=# insert into capitals values('chandigarh',1234,11,'HA');
INSERT 0 1
test1=# insert into city values('faridabad',1224,112);
INSERT 0 1
test1=# select * from city;
    name    | population | elevation
------------+------------+-----------
 faridabad  |       1224 |       112
 chandigarh |       1234 |        11
(2 rows)

# only to get data from only city
test1=# select * from only city;
   name    | population | elevation
-----------+------------+-----------
 faridabad |       1224 |       112
(1 row)


test1=# select * from  capitals;
    name    | population | elevation | state
------------+------------+-----------+-------
 chandigarh |       1234 |        11 | HA
(1 row)

PostgreSQL - UNIONS Clause
The PostgreSQL UNION clause/operator is used to combine the results of two or more SELECT statements without returning any duplicate rows.
To use UNION, each SELECT must have the same number of columns selected, 
the same number of column expressions, the same data type, and have them in the same order but they do not have to be the same length.

The basic syntax of UNION is as follows −
SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]
UNION
SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]
test1=# select name from city union select name from cities;
     name
---------------
 chandigarh
 San Francisco
 faridabad
(3 rows)

columns name of the seleted tabel should be same to be shown
test1=# select name from city union select location from cities;
ERROR:  UNION types text and point cannot be matched
LINE 1: select name from city union select location from cities;
                                           

The UNION ALL Clause
The UNION ALL operator is used to combine the results of two SELECT statements including duplicate rows. 
The same rules that apply to UNION apply to the UNION ALL operator as well.
SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]

UNION ALL
SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]
    name
---------------
 faridabad
 faridabad
 chandigarh
 San Francisco
(4 rows)

#SQL syntax
#Lexical Structure
sequenceof tokens terminated by ;
Tokens can be hayward , identifier, constants or literal or special symbol
#Identifier
They identify name of tables columns or other db objects called names
starts with [9-2) followed by any alphabet, digit unserscore or $
They are case insensitive
convention  is to write key words in upper case and names in lower case
#then there is : the delimited identifier or quoted identifier
It is token in quotes whiuch is never treated as keyword
Then can contain ny character except 0
they are case sensitive

# Constants
Three kinds of implicitly-typed constants in PostgreSQL: 
>strings-  A string constant in SQL is an arbitrary sequence of characters bounded by single quotes ('), for example 'This is a string'
,> bit strings, - 
 and >numbers -
Constants can also be specified with explicit types, which can enable more accurate representation and
more efficient handling by the system
Backslash Escape Sequenceand its  Interpretation
\b - backspace
\f - form feed
\n - newline
\r - carriage return
\t - tab
\o, \oo, \ooo (o = 0–7) - octal byte value
\xh, \xhh (h = 0–9, A–F) - hexadecimal byte value
\uxxxx, \Uxxxxxxxx (x = 0–9, A–F) 16 or 32-bit - hexadecimal Unicode character
value
*Dollar-Quoted String Constants to revisit???

#Bit-String Constants
Bit-string constants look like regular string constants with a B (upper or lower case) immediately before the opening quote (no intervening whitespace),
e.g., B'1001'. The only characters allowed within bit-string constants are 0 and 1 and for hexadecimal b is replaced with x eg x'12ABF'

#Numeric Constants
Numeric constants are accepted in these general forms:
digits
digits.[digits][e[+-]digits]    --exponent marker (e)
[digits].digits[e[+-]digits]
digitse[+-]digits

Typecasting REAL '1.23' numeric treated as Real(float64)


PostgreSQL built-in functions also Aggregate Function.

# Count the number rows in the query
test1=# SELECT COUNT(*) FROM city ;
 count
-------
     2
(1 row)

test1=# SELECT * FROM city where name = 'faridabad';
   name    | population | elevation
-----------+------------+-----------
 faridabad |       1224 |       112
(1 row)


test1=# SELECT count(*) FROM city where name = 'faridabad';
 count
-------
     1
(1 row)

#MAX show the maximum value of the column selected
 test1=# select  max(elevation) from city;
 max
-----
 112
(1 row)

#MIN show the minimum value of the column selected
test1=# select  min(elevation) from city;
 min
-----
  11
(1 row)

# Can see max and min in same time
test1=# select  min(elevation) ,max(elevation) from city;
 min | max
-----+-----
  11 | 112
(1 row)

# Group by in MAX or MIN will show each min / max of group.
test1=# select * from city;
    name    |  population  | elevation
------------+--------------+-----------
 faridabad  |         1224 |       112
 faridabad  | 1.212121e+06 |     12121
 chandigarh |         1234 |        11
(3 rows)


test1=# select name, max(elevation) from city group by name;
    name    |  max
------------+-------
 chandigarh |    11
 faridabad  | 12121
(2 rows)

# AVG - shows the average of the selected column
test1=# select avg(elevation) from city;
          avg
-----------------------
 4081.3333333333333333
(1 row)

test1=# select avg(elevation) from city group by name;
          avg
-----------------------
   11.0000000000000000
 6116.5000000000000000
(2 rows)

# Sum - JUst Like avg it sums up all the rows of the selected column
test1=# select sum(elevation) from city;
  sum
-------
 12244
(1 row)


test1=# select sum(elevation) from city group by name;
  sum
-------
    11
 12233
(2 rows)


#Array_agg concatenate the values into array
test1=# select array_agg(elevation) from city;
   array_agg
----------------
 {112,12121,11}
(1 row)


test1=# select array_agg(name) from city;
            array_agg
----------------------------------
 {faridabad,faridabad,chandigarh}
(1 row)



Numeric Functions

The ABS() function returns the absolute value of X.
test1=# SELECT ABS(-2);
 abs
-----
   2
(1 row)

ACOS(X) -  returns the arccosine of X. The value of X must range between -1 and 1 or NULL will be returned

test1=# SELECT ACOS(1);
 acos
------
    0
(1 row)


test1=# SELECT ACOS(-11);
ERROR:  input is out of range
test1=# SELECT ACOS(-1);
       acos
-------------------
 3.141592653589793
(1 row)

ASIN(X)- like acos() The ASIN() function returns the arcsine of X range[-1,1]
test1=# SELECT ASIN(1);
        asin
--------------------
 1.5707963267948966
(1 row)


test1=# SELECT ASIN(0);
 asin
------
    0
(1 row)

ATAN(X) - This function returns the arctangent of X.

test1=# SELECT ATAN(0);
 atan
------
    0
(1 row)


test1=# SELECT ATAN(1);
        atan
--------------------
 0.7853981633974483
(1 row)

ATAN2(Y,X)
This function returns the arctangent of the two arguments: X and Y. It is similar to the arctangent of Y/X, except that the signs of both are used to find the quadrant of the result.--???????
test1=# SELECT ATAN2(3,6);
       atan2
--------------------
 0.4636476090008061
(1 row)

CEIL(X) / CEILING(X)  - Return the smaller integer value just bigger than arg
test1=# select ceil(3.232);
 ceil
------
    4
(1 row) 

test1=# select ceil(3.0);
 ceil
------
    3
(1 row)
test1=# select ceil(-3.123);
 ceil
------
   -3
(1 row)

Floor(x)-  Return the bigger integer value just smaller than arg
test1=# select floor (2.3343);
 floor
-------
     2
(1 row)

test1=# select floor (-2.3343);
 floor
-------
    -3
(1 row)

GREATEST(n1,n2,n3,..........)- Give the greates vlue from the no of parameters.
test1=# select greatest(121,323,423,31,445,224,25345,4,23,4234,234,32423);
 greatest
----------
    32423
(1 row)

LEAST(N1,N2,N3,N4,......) - gives the least values from the no of parameters.
test1=# select least(121,323,423,31,445,224,25345,4,23,4234,234,32423);
 least
-------
     4
(1 row)

COS(X) -This function returns the cosine of X (in degrees)
test1=# select cos(0);
 cos
-----
   1
(1 row)


test1=# select cos(90);
         cos
---------------------
 -0.4480736161291701
(1 row)

COT(X) -This function returns the cotangent of X --???
test1=# SELECT COT(1);
        cot
--------------------
 0.6420926159343306
(1 row)

DEGREES(X)- This function returns the value of X converted from radians to degrees
test1=# SELECT DEGREES(PI());
 degrees
---------
     180
(1 row)


test1=# SELECT DEGREES(1);
      degrees
-------------------
 57.29577951308232
(1 row)

# pi() - returns the value of pi
test1=# select pi();
        pi
-------------------
 3.141592653589793
(1 row)

EXP(X) returns e^x.
test1=# SELECT EXP(3);
        exp
--------------------
 20.085536923187668
(1 row)

test1=# SELECT EXP(1);
        exp
-------------------
 2.718281828459045
(1 row)

LOG(X) / LOG(B,X) -  returns the value of log to natural base or base B
test1=# SELECT LOG(45);
        log
--------------------
 1.6532125137753437
(1 row)


test1=# SELECT LOG(1);
 log
-----
   0
(1 row)

test1=# SELECT LOG(2,65536);
        log
--------------------
 16.000000000000000
(1 row)

MOD(N,M) - retuns remainder n/m
test1=# SELECT mod(9,2);
 mod
-----
   1
(1 row)

POW(X,Y) / POWER(X,Y)-returns x^y
test1=# select pow(3,2);
 pow
-----
   9
(1 row)

RADIANS(X)-  converted from degrees to radians.
test1=# SELECT RADIANS(90);
      radians
--------------------
 1.5707963267948966
(1 row)

ROUND(X) / ROUND(X,D) - round to integer or nearest D decimal points
test1=# SELECT ROUND(5.693893);
 round
-------
     6
(1 row)


test1=# SELECT ROUND(5.693893,2);
 round
-------
  5.69
(1 row)

SIGN(X)- returns the sign of X (negative, zero, or positive) as -1, 0, or 1.
test1=# SELECT SIGN(0);
 sign
------
    0
(1 row)


test1=# SELECT SIGN(-0);
 sign
------
    0
(1 row)


test1=# SELECT SIGN(-1.2);
 sign
------
   -1
(1 row)


test1=# SELECT SIGN(1.2);
 sign
------
    1
(1 row)

SIN(X)- This function returns the sine of X
test1=# select sin(90);
        sin
--------------------
 0.8939966636005579
(1 row)
SQRT(X) -returns the non-negative square root of X.
test1=# select sqrt(9);
 sqrt
------
    3
(1 row)

#ASCII()-Returns numeric value of left-most character
                     ^
test1=# select ascii('a');
 ascii
-------
    97
(1 row)


test1=# select ascii('ax');
 ascii
-------
    97
(1 row)


#BIT_LENGTH()-Returns length of argument in bits
test1=# select bit_length('b');
 bit_length
------------
          8
(1 row)


test1=# select bit_length('@');
 bit_length
------------
          8
(1 row)


test1=# select bit_length('@sdafgfsdfsd');
 bit_length
------------
         96
(1 row)



#CHAR_LENGTH()-Returns number of characters in argument
test1=# select char_length('asad');
 char_length
-------------
           4
(1 row)


test1=# select char_length('asad13123');
 char_length
-------------
           9
(1 row)

#CHARACTER_LENGTH()-A synonym for CHAR_LENGTH()
test1=# select character_length('adaws233');
 character_length
------------------
                8
(1 row)

#CONCAT_WS() - Returns concatenate with separator,first argument is the separator for the rest of the arguments
test1=# select concat_ws('sdas','232','ase','1213','32312');
          concat_ws
-----------------------------
 232sdasasesdas1213sdas32312
(1 row)

#CONCAT()-Returns concatenated string
test1=# select concat('sdas','232','ase');
   concat
------------
 sdas232ase
(1 row)

#LCASE()-Synonym for LOWER()
test1=# select LCASE('CSACASDCAS');
ERROR:  function lcase(unknown) does not exist
LINE 1: select LCASE('CSACASDCAS');


#LEFT()- Returns the leftmost number of characters as specified
test1=# SELECT LEFT('adafesfewfdr3q2rwecsd',9);
   left
-----------
 adafesfew
(1 row)
 
#LENGTH()- Returns the length of a string in bytes (looks like char_length())

test1=# select length('14234afsdf!@!@#$');
 length
--------
     16
(1 row)


#LOWER()-Returns the argument in lowercase
test1=# select lower('SDSDD');
 lower
-------
 sdsdd
(1 row)


test1=# select lower('2132');
 lower
-------
 2132
(1 row)


11	LPAD()- Returns the string argument, left-padded with the specified string
test1=# select lpad('qw',4,'11');
 lpad
------
 11qw
(1 row)


test1=# select lpad('qw121',4,'11');
 lpad
------
 qw12
(1 row)

#LTRIM()-Removes leading spaces
test1=# SELECT LTRIM('  basa    ');
  ltrim
----------
 basa
(1 row)


13	MID()
Returns a substring starting from the specified position

#POSITION()-A synonym for LOCATE()
test1=# select position('2'IN'111122334');
 position
----------
        5
(1 row)

#QUOTE()-Escapes the argument for use in an SQL statement
SELECT QUOTE_IDENT('Foo bar');
 quote_ident
-------------
 "Foo bar"
(1 row)

SELECT QUOTE_LITERAL(E'O\'Reilly');
 quote_literal
---------------
 'O''Reilly'
(1 row)

test1=# SELECT QUOTE_LITERAL(42.5);
 quote_literal
---------------
 '42.5'
(1 row)

test1=# SELECT QUOTE_NULLABLE(42.5);
 quote_nullable
----------------
 '42.5'
(1 row)

16	REGEXP
Pattern matching using regular expressions
Regular Expression
RoadBlock


#REPEAT()-Repeats a string the specified number of times
REPEAT(str,count)
test1=# select repeat('my',3);
 repeat
--------
 mymymy
(1 row)

#REPLACE()- Replaces occurrences of a specified string
REPLACE(str,from_str,to_str)
test1=# select replace('12345678','2','3');
 replace
----------
 13345678
(1 row)


#REVERSE()-Reverse the characters in a string
test1=# select reverse('1232345');
 reverse
---------
 5432321
(1 row)

test1=# select reverse('abcdefgh');
 reverse
----------
 hgfedcba
(1 row)

#RIGHT()-Returns the specified rightmost number of characters
test1=# select right('adafdff',2);
 right
-------
 ff
(1 row)

test1=# select right('',2);
 right
-------

(1 row)

test1=# select right(NUll,2);
 right
-------

(1 row)

#RPAD()- Appends string the specified number of timesIf str is longer than len, the return value is shortened to len characters.
test1=# select rpad('qw',4,'#');
 rpad
------
 qw##
(1 row)


test1=# select rpad('qwssdas',4,'#');
 rpad
------
 qwss
(1 row)

RPAD(str,len,padstr)


#RTRIM()- Removes trailing spaces
test1=# select rtrim('asdasdasdea     ');
    rtrim
-------------
 asdasdasdea
(1 row)

#SUBSTRING(), SUBSTR()-Returns the substring as specified
SUBSTRING(str,pos), SUBSTRING(str FROM pos), SUBSTRING(str,pos,len), SUBSTRING(str FROM pos FOR len)
test1=# SELECT SUBSTRING('Quadratically',5);
 substring
-----------
 ratically
(1 row)

test1=# SELECT SUBSTRING('foobarbar' FROM 4);
 substring
-----------
 barbar
(1 row)

test1=# SELECT SUBSTRING('Quadratically',5,6);
 substring
-----------
 ratica
(1 row)

test1=# SELECT SUBSTRING('Quadratically',0,6);
 substring
-----------
 Quadr
(1 row)


TRIM()-Removes leading and trailing spaces
TRIM([{BOTH | LEADING | TRAILING} [remstr] FROM] str), TRIM([remstr FROM] str)
test1=# SELECT TRIM('  bar   ');
 btrim
-------
 bar
(1 row)

test1=# SELECT TRIM(LEADING 'x' FROM 'xxxbarxxx');
 ltrim
--------
 barxxx
(1 row)
test1=# SELECT TRIM('  bar   ');
 btrim
-------
 bar
(1 row)

test1=# SELECT TRIM(LEADING 'x' FROM 'xxxbarxxx');
 ltrim
--------
 barxxx
(1 row)

test1=# SELECT TRIM(BOTH 'x' FROM 'xxxbarxxx');
 btrim
-------
 bar
(1 row)


test1=# SELECT TRIM(TRAILING 'xyz' FROM 'barxxyz');
 rtrim
-------
 bar
(1 row)
test1=# SELECT TRIM(BOTH 'x' FROM 'xxxbarxxx');
 btrim
-------
 bar
(1 row)

test1=# SELECT TRIM(TRAILING 'xyz' FROM 'barxxyz');
 rtrim
-------
 bar
(1 row)

#UCASE()-Synonym for UPPER()
test1=# select UCASE('Dadasda');
ERROR:  function ucase(unknown) does not exist
LINE 1: select UCASE('Dadasda');
               ^
			   
#UPPER()- Converts to uppercase
test1=# select upper('Dadasda');
  upper
---------
 DADASDA
(1 row)

AUTO INCREMENT
data types smallserial, serial and bigserial; these are not true types, but merely a notational convenience for creating unique identifier columns
The type name serial creates an integer columns. The type name bigserial creates a bigint column. bigserial should be used if you anticipate the use of more than 231 identifiers over the lifetime of the table. The type name smallserial creates a smallint column.


test1=#  CREATE TABLE COMPANY(
test1(#    ID  SERIAL PRIMARY KEY,
test1(#    NAME           TEXT      NOT NULL,
test1(#    AGE            INT       NOT NULL,
test1(#    ADDRESS        CHAR(50),
test1(#    SALARY         REAL
test1(# );
CREATE TABLE
test1=# INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
test1-# VALUES ( 'Paul', 32, 'California', 20000.00 );
INSERT 0 1
test1=#
test1=# INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
test1-# VALUES ('Allen', 25, 'Texas', 15000.00 );
INSERT 0 1
test1=# INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
test1-# VALUES ('Teddy', 23, 'Norway', 20000.00 );
INSERT 0 1
test1=# INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
test1-# VALUES ( 'Mark', 25, 'Rich-Mond ', 65000.00 );
INSERT 0 1
test1=# INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
test1-# VALUES ( 'David', 27, 'Texas', 85000.00 );
INSERT 0 1
test1=# INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
test1-# VALUES ( 'Kim', 22, 'South-Hall', 45000.00 );
INSERT 0 1
test1=# INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
test1-# VALUES ( 'James', 24, 'Houston', 10000.00 );
INSERT 0 1
test1=# select * from company;
 id | name  | age |                      address                       | salary
----+-------+-----+----------------------------------------------------+--------
  1 | Paul  |  32 | California                                         |  20000
  2 | Allen |  25 | Texas                                              |  15000
  3 | Teddy |  23 | Norway                                             |  20000
  4 | Mark  |  25 | Rich-Mond                                          |  65000
  5 | David |  27 | Texas                                              |  85000
  6 | Kim   |  22 | South-Hall                                         |  45000
  7 | James |  24 | Houston                                            |  10000
(7 rows)

If want to alter table with auto increment colunmn after table is created???????

---------------------------------------------------------------------------------------------

Privileges
Creating User in DB
test1=# create user shubh with password'123';
CREATE ROLE

test1=# drop user shubh
test1-# ;
DROP ROLE


Different Priveleges commands command be given 
 privileges in PostgreSQL are −
SELECT,INSERT,UPDATE,DELETE,TRUNCATE,REFERENCES,TRIGGER,
CREATE,CONNECT,TEMPORAY,EXECUTE, and USAGE

Grant and Revoke are the commands to give privelege to the users
privilege − values could be: SELECT, INSERT, UPDATE, DELETE, RULE, ALL.

object − The name of an object(table, view, sequence) to which to grant/revoke access

PUBLIC − A short form representing all users.

GROUP group − A group to whom to grant privileges.

username − The name of a user to whom to grant privileges. PUBLIC is a short form representing all users.


GRANT privilege [, ...]
ON object [, ...]
TO { PUBLIC | GROUP group | username }

REVOKE privilege [, ...]
ON object [, ...]
FROM { PUBLIC | GROUP groupname | username }


test1=# GRANT ALL ON COMPANY TO shubh;
GRANT
test1=# revoke ALL ON COMPANY from shubh;
REVOKE

TRUNCATE TABLE command is used to delete complete data from an existing table and drop data to delete data with schema
test1=# TRUNCATE TABLE COMPANY;

Auto-increment: Auto-increment allows a unique number to be generated automatically when a new record is inserted into a table.
A sequence is often used as the primary key column in a table.
In Postgresql first, we need to create a table with some data in it. 
Then define auto increment using serial data type for a column that column acts as the primary key.
 CREATE TABLE COMPANY(
   ID  SERIAL PRIMARY KEY,
   NAME           TEXT      NOT NULL,
   AGE            INT       NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);

Now, insert the following records into table COMPANY −
INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
VALUES ( 'Paul', 32, 'California', 20000.00 );
INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
VALUES ('Allen', 25, 'Texas', 15000.00 );
INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
VALUES ('Teddy', 23, 'Norway', 20000.00 );
INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
VALUES ( 'Mark', 25, 'Rich-Mond ', 65000.00 );
INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
VALUES ( 'David', 27, 'Texas', 85000.00 );
INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
VALUES ( 'Kim', 22, 'South-Hall', 45000.00 );
INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
VALUES ( 'James', 24, 'Houston', 10000.00 );

This will insert seven tuples into the table COMPANY and COMPANY will have the following records −
 id | name  | age | address    | salary
----+-------+-----+------------+--------
  1 | Paul  |  32 | California |  20000
  2 | Allen |  25 | Texas      |  15000
  3 | Teddy |  23 | Norway     |  20000
  4 | Mark  |  25 | Rich-Mond  |  65000
  5 | David |  27 | Texas      |  85000
  6 | Kim   |  22 | South-Hall |  45000
  7 | James |  24 | Houston    |  10000
  
  #Indexes
Speacial lookup tables used by db search engine to speed up data retreival.It is like a pointer to data in the table
Speeds up select query with where clause but slows down insert and update query.
Create Indexes
test1=# create index abc on city(name,population);
CREATE INDEX

Types of index
Single-Column Indexes index created based on only one column in table.
test1=# create index abc on city(population);
CREATE INDEX

Multicolumn Indexes  index created based on multiple column in table.
test1=# create index abc on city(name,population);
CREATE INDEX

choice of column should be the which is frequently used in quesry where clause.

Unique index
used for data integrity as it does not allow any duplicated to be inserted into the table.
test1=# create unique index  uni on city(name);
ERROR:  could not create unique index "uni"
DETAIL:  Key (name)=(faridabad) is duplicated.

Partial index - index made over a subset of table it is defined by conditional expression and index contains rows whcih satisfy that condition.

Implicit Indexes
Implicit indexes are indexes that are automatically created by the database server when an object is created. Indexes are automatically created for primary key constraints and unique constraints.
test1=# \d city
                  Table "public.city"
   Column   |  Type   | Collation | Nullable | Default
------------+---------+-----------+----------+---------
 name       | text    |           |          |
 population | real    |           |          |
 elevation  | integer |           |          |
Indexes:
    "abc" btree (name, population)
Number of child tables: 1 (Use \d+ to list them.)

 Drop index - deletes the index
DROP INDEX abd;
DROP INDEX

Index should be avoided in case where-
Table is small
many update and insert operation is done
many null values in columns
  
Alter data type
test1=# Alter table city alter column  id type real;
ALTER TABLE
test1=# \d city
                    Table "public.city"
   Column   |     Type     | Collation | Nullable | Default
------------+--------------+-----------+----------+---------
 name       | text         |           |          |
 population | real         |           |          |
 elevation  | integer      |           |          |
 id         | real         |           |          |
 gender     | character(1) |           |          |
Number of child tables: 1 (Use \d+ to list them.)

#not null constraints
test1=# ALTER TABLE city alter column  id set  NOT NULL;
ERROR:  column "id" of relation "city" contains null values

test1=# ALTER TABLE city alter column  id set  NOT NULL;
ERROR:  column "id" of relation "city" contains null values
test1=# ALTER TABLE city alter column  name set  NOT NULL;
ALTER TABLE
test1=# \d city
                    Table "public.city"
   Column   |     Type     | Collation | Nullable | Default
------------+--------------+-----------+----------+---------
 name       | text         |           | not null |
 population | real         |           |          |
 elevation  | integer      |           |          |
 id         | real         |           |          |
 gender     | character(1) |           |          |
Number of child tables: 1 (Use \d+ to list them.)


ADD CHECK CONSTRAINT
What is check constraints
before any reocrd is inserted in the row query check in the constraints if the is fullfilled of not.
ALTER TABLE table_name
ADD CONSTRAINT MyUniqueConstraint CHECK (CONDITION);

DROP CONSTRAINT
test1=# Alter table weather drop constraint weather_pk;
ALTER TABLE
test1=# \d weather
                      Table "public.weather"
 Column  |         Type          | Collation | Nullable | Default
---------+-----------------------+-----------+----------+---------
 city    | character varying(80) |           |          |
 temp_lo | integer               |           |          |
 temp_hi | integer               |           |          |
 prcp    | real                  |           |          |
 date    | date                  |           |          |

# use \d+ to get extra data about table 
test1=# \d+ weather
                                                 Table "public.weather"
 Column  |         Type          | Collation | Nullable | Default | Storage  | Compression | Stats target | Description ---------+-----------------------+-----------+----------+---------+----------+-------------+--------------+------------- city    | character varying(80) |           |          |         | extended |             |              |
 temp_lo | integer               |           |          |         | plain    |             |              |
 temp_hi | integer               |           |          |         | plain    |             |              |
 prcp    | real                  |           |          |         | plain    |             |              |
 date    | date                  |           |          |         | plain    |             |              |
Access method: heap



DROP PRIMARY KEY
ALTER TABLE table_name
DROP CONSTRAINT MyPrimaryKey;

dROP COLUMN
ALTER TABLE table_name DROP PRIMARY KEY;
test1=# ALTER TABLE CITY DROP ID;
ALTER TABLE

Upsert
Allows dml statement to insert data in table if it already exists update the table

INSERT INTO table_name(column_list)  
VALUES(value_list)
ON CONFLICT target action;

Target action can be update statement or Do nothing

The target can be :
(column_name) – any column name.
ON CONSTRAINT constraint_name – where the constraint name could be the name of the UNIQUE constraint.
 WHERE predicate  – a WHERE clause with a boolean condition.
The action can be :
DO NOTHING – If the row already exists in the table, then do nothing.
DO UPDATE SET columnA = valueA, …. WHERE condition – update some fields in the table depending upon the condition

test1=# insert into cities (name) values('faridabad') on conflict(name) do nothing ;
INSERT 0 1
test1=# Select * from cities;
     name      | location
---------------+-----------
 San Francisco | (-194,53)
 faridabad     |
(2 rows)


test1=# insert into cities (name) values('faridabad') on conflict(name) do nothing ;
INSERT 0 0

test1=# insert into cities (name) values('faridabad') on conflict(name) do update set name='asd' ;
INSERT 0 1
test1=# Select * from cities;
     name      | location
---------------+-----------
 San Francisco | (-194,53)
 asd           |
(2 rows)

Fetch clause
Similair to limit used to get only portion of rows
Syntax:
OFFSET start { ROW | ROWS }
FETCH { FIRST | NEXT } [ row_count ] { ROW | ROWS } ONLY
test1=# Select * from city fetch next 1 row only;
   name    | population | elevation | gender
-----------+------------+-----------+--------
 faridabad |       1224 |       112 |
(1 row)

Show the second row

test1=# Select * from city offset 1 row fetch  next 1 row only;
   name    |  population  | elevation | gender
-----------+--------------+-----------+--------
 faridabad | 1.212121e+06 |     12121 |
(1 row)

show the 3rd highest city 
test1=# Select * from city order by elevation desc offset 2 row fetch  next 1 row only;
    name    | population | elevation | gender
------------+------------+-----------+--------
 chandigarh |       1234 |        11 |
(1 row)
