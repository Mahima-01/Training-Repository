What is PostgreSQL?
PostgreSQL (pronounced as post-gress-Q-L) is an open source relational database management system (DBMS) developed by a worldwide team of volunteers. 

Key Features of PostgreSQL
PostgreSQL runs on all major operating systems, including Linux, UNIX (AIX, BSD, HP-UX, SGI IRIX, Mac OS X, Solaris, Tru64), and Windows. 
It supports text, images, sounds, and video, and includes programming interfaces for C / C++, Java, Perl, Python, Ruby, Tcl and Open Database Connectivity (ODBC).
PostgreSQL supports a large part of the SQL standard and offers many modern features including the following −
Complex SQL queries
SQL Sub-selects
Foreign keys
Trigger
Views
Transactions
Multiversion concurrency control (MVCC)
Streaming Replication (as of 9.0)
Hot Standby (as of 9.0)

#Show Databases

\l
                                         List of databases
   Name    |  Owner   | Encoding |      Collate       |       Ctype        |   Access privileges
-----------+----------+----------+--------------------+--------------------+-----------------------
 postgres  | postgres | UTF8     | English_India.1252 | English_India.1252 |
 template0 | postgres | UTF8     | English_India.1252 | English_India.1252 | =c/postgres          +
           |          |          |                    |                    | postgres=CTc/postgres
 template1 | postgres | UTF8     | English_India.1252 | English_India.1252 | =c/postgres          +
           |          |          |                    |                    | postgres=CTc/postgres
(3 rows)

postgres=# CREATE DATABASE TEST;
CREATE DATABASE

test-#
Here # shows I am Super User
test=>
" => " have rights to the database

# To see current date
SELECT current_date;
 current_date
--------------
 2022-03-31
(1 row)

# Running Arithmatic Commands
SELECT 2 + 2;
 ?column?
----------
        4
(1 row)
# \h for help
# \q to quit

# Postgre uses the SQL language
# "-- " to write comments in SQL

Syntax
The basic syntax of CREATE DATABASE statement is as follows −

CREATE DATABASE dbname;
where dbname is the name of a database to create.
# Creating the tables in the databse

test1=# CREATE TABLE weather (
test1(#     city            varchar(80),
test1(#     temp_lo         int,           -- low temperature
test1(#     temp_hi         int,           -- high temperature
test1(#     prcp            real,          -- precipitation
test1(#     date            date
test1(# );
CREATE TABLE
test1=# CREATE TABLE cities (
test1(#     name            varchar(80),
test1(#     location        point
test1(# );
CREATE TABLE

# Deleteing the whole table  
test1=# DROP TABLE cities;
DROP TABLE

Basic syntax of INSERT INTO statement is as follows −

INSERT INTO TABLE_NAME (column1, column2, column3,...columnN)
VALUES (value1, value2, value3,...valueN);
#inserting data in the tables
est1=# INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');
INSERT 0 1
test1=# INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');
INSERT 0 1
test1=# INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
test1-#     VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');
INSERT 0 1
test1=# INSERT INTO weather (date, city, temp_hi, temp_lo)
test1-#     VALUES ('1994-11-29', 'Hayward', 54, 37);
INSERT 0 1

# Quering the data from the to see data 
test1=# SELECT * FROM weather;
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      43 |      57 |    0 | 1994-11-29
 Hayward       |      37 |      54 |      | 1994-11-29
(3 rows)

# Quesring data using Orerators to manipulate data 
test1=# SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;
     city      | temp_avg |    date
---------------+----------+------------
 San Francisco |       48 | 1994-11-27
 San Francisco |       50 | 1994-11-29
 Hayward       |       45 | 1994-11-29
(3 rows)

# Quering data with where clause to seespecific data

test1=# SELECT * FROM weather
test1-#     WHERE city = 'San Francisco' AND prcp > 0.0;
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
(1 row)

# using orderby to arrandata while query it
test1=# SELECT * FROM weather
test1-#     ORDER BY city;
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 Hayward       |      37 |      54 |      | 1994-11-29
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      43 |      57 |    0 | 1994-11-29
(3 rows)

#query uniques data from the table 
test1=# SELECT DISTINCT city
test1-#     FROM weather;
     city
---------------
 Hayward
 San Francisco
(2 rows)

#Using Aggregate Functions MAX
test1=# SELECT max(temp_lo) FROM weather;
 max
-----
  46
(1 row)

test1=# SELECT city, max(temp_lo)
test1-#     FROM weather
test1-#     GROUP BY city;
     city      | max
---------------+-----
 Hayward       |  37
 San Francisco |  46
(2 rows)


test1=# UPDATE weather
test1-#     SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
test1-#     WHERE date > '1994-11-28';
UPDATE 2

#Manupulating the tables

#Deleting the specific data from the table

test1=# DELETE FROM weather WHERE city = 'Hayward';
DELETE 1

# updating the data in the table
test1=# UPDATE weather
test1-#     SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
test1-#     WHERE date > '1994-11-28';
UPDATE 2
test1=# SELECT * FROM weather;
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      41 |      55 |    0 | 1994-11-29
(2 rows)

# Views in SQL are kind of virtual tables. A view also has rows and columns as they are in a real table in the database.

test1=# CREATE VIEW myview AS
test1-#     SELECT name, temp_lo, temp_hi, prcp, date, location
test1-#         FROM weather, cities
test1-#         WHERE city = name;
CREATE VIEW
test1=# SELECT * FROM myview;
     name      | temp_lo | temp_hi | prcp |    date    | location
---------------+---------+---------+------+------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | (-194,53)
 San Francisco |      41 |      55 |    0 | 1994-11-29 | (-194,53)
(2 rows)

FOREIGN KEY Constraint
A foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. 
We say this maintains the referential integrity between two related tables. 
They are called foreign keys because the constraints are foreign; that is, outside the table. 
Foreign keys are sometimes called a referencing key.
For Eg in above table if no data should be added in weather if there is no matching data in cities here we use foriegn keys so Postgresql can do this it self and mintain refrential integrity.
#create table cities with mane as primary key
 create table cities(
 name varchar(80) primary key,
 location point
 );
 ERROR:  relation "cities" already exists
 
 # and make refrence / foreign key of ctiries name column in weather table
 create table weather(
 city varchar(80) references cities(name),
 temp_lo int,
 temp_hi int,
 prcp real,
 date date
 );
 ERROR:  relation "weather" already exists
 # to describe table name
 \d tablename
 test1=# \d cities
                       Table "public.cities"
  Column  |         Type          | Collation | Nullable | Default
----------+-----------------------+-----------+----------+---------
 name     | character varying(80) |           |          |
 location | point                 |           |          |

# adding constrain to existing column in table
alter table cities add constraint cities_pk primary key(name);
ALTER TABLE
test1=# \d cities
                       Table "public.cities"
  Column  |         Type          | Collation | Nullable | Default
----------+-----------------------+-----------+----------+---------
 name     | character varying(80) |           | not null |
 location | point                 |           |          |
Indexes:
    "cities_pk" PRIMARY KEY, btree (name)
	
# Alter table to add foreign key constraints
alter table weather add constraint weather_pk foreign key (city) references cities(name);
ALTER TABLE

                      Table "public.weather"
 Column  |         Type          | Collation | Nullable | Default
---------+-----------------------+-----------+----------+---------
 city    | character varying(80) |           |          |
 temp_lo | integer               |           |          |
 temp_hi | integer               |           |          |
 prcp    | real                  |           |          |
 date    | date                  |           |          |
Foreign-key constraints:
    "weather_pk" FOREIGN KEY (city) REFERENCES cities(name)

#insert error due to Berkley not present in cities table
test1=# INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');
ERROR:  insert or update on table "weather" violates foreign key constraint "weather_pk"
DETAIL:  Key (city)=(Berkeley) is not present in table "cities".

A transaction is a unit of work that is performed against a database. 
Transactions are units or sequences of work accomplished in a logical order, whether in a manual fashion by a user or automatically by some sort of a database program.
A transaction is the propagation of one or more changes to the database. 
For example, if you are creating a record, updating a record, or deleting a record from the table, then you are performing transaction on the table. 
It is important to control transactions to ensure data integrity and to handle database errors.

The following commands are used to control transactions −
BEGIN TRANSACTION − To start a transaction.
Transactions can be started using BEGIN TRANSACTION or simply BEGIN command.
COMMIT − To save the changes, alternatively you can use END TRANSACTION command.
ROLLBACK − To rollback the changes.

