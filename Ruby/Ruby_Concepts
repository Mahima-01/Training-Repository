Ruby is a perfect Object Oriented Programming Language. The features of the object-oriented programming language include −
Data Encapsulation
Data Abstraction
Polymorphism
Inheritance

# Basic ruby code practice:
itsacheckmate@itsacheckmate:~$ irb
3.0.0 :001 > puts "Learning Ruby";
Learning Ruby
 => nil 
3.0.0 :002 > def Helloout = "Hello World"
3.0.0 :003 >   
 => :Helloout 
3.0.0 :004 > def hello
3.0.0 :005 >   out = "Hello World"
3.0.0 :006 >   puts out
3.0.0 :007 > end
 => :hello 
3.0.0 :008 > hello
Hello World
 => nil 
3.0.0 :009 > exit

itsacheckmate@itsacheckmate:~$ cd Training-Repository/
itsacheckmate@itsacheckmate:~/Training-Repository$ Rvm\ and\ Ruby/
Hello,started learning Rub
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Hello,started learning Ruby
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ irb
3.0.0 :001"> print <<EOF
3.0.0 :002"> This is the first way of creating
3.0.0 :003"> here document ie. multiple string.
3.0.0 :004"> EOF
3.0.0 :006"> This is the second way of creating
3.0.0 :007"> here document ie. multiple line string.
3.0.0 :008 > EOF
This is the second way of creating
here document ie. multiple line string.
 => nil 

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ irb
3.0.0 :001"> print <<"EOC";
3.0.0 :002"> echo hy
3.0.0 :003"> EOC
echo hy
 => nil 
3.0.0 :004`> print <<`EOC`;                      #SAME AS ABOVE
3.0.0 :005`> echo hy
3.0.0 :006`> echo there
3.0.0 :007 > EOC
hy
there
 => nil 
3.0.0 :008"> print <<"foo",<<"bar"
3.0.0 :009"> I said foo.
3.0.0 :010"> foo
3.0.0 :011"> I said bar.
3.0.0 :012 > bar
I said foo.
I said bar.
 => nil 

3.0.0 :013 > puts "This is main Ruby Program"
This is main Ruby Program
 => nil 

# Using BEGIN Statement:
--> First put block of code in a file then it will execute.
--> It will show the line which is entered in "begin" block firstly then other lines of the file.
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Initializing Ruby Program
Hello,started learning Ruby
This is main Ruby Program

# Using END Statement:
--> Declares code to be called at the end of the program.
puts "Hello,started learning Ruby";
puts "This is main Ruby Program"
BEGIN {
   puts "Initializing first Ruby Program"
}
END {
   puts "Terminating Ruby Program"
}
BEGIN {
   puts "Initializing second Ruby Program"
}
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Initializing first Ruby Program
Initializing second Ruby Program
Hello,started learning Ruby
This is main Ruby Program
Terminating Ruby Program

# Ruby Comments
-->A comment hides a line, part of a line, or several lines from the Ruby interpreter. You can use the hash character (#) at the beginning of a line −
# I am a comment. Just ignore me.
Or, a comment may be on the same line after a statement or expression −
name = "Maddy" # This is again comment
You can comment multiple lines as follows −
# This is a comment.
# This is a comment, too.
# This is a comment, too.
# I said that already.
Here is another form. This block comment conceals several lines from the interpreter with =begin/=end −
=begin
This is a comment.
This is a comment, too.
This is a comment, too.
I said that already.
=end (Will not display anything becoz it is a comment.)

# Defining a Class in Ruby:
A class in Ruby always starts with the keyword class followed by the name of the class. The name should always be in initial capitals. The class Customer can be displayed as −
Syntax:
class Customer
end
You terminate a class by using the keyword end.

# Variables:
Variables are the memory locations, which hold any data to be used by any program.
Unlike other programming languages, there is no need to declare a variable in Ruby. A prefix is needed to indicate it.
There are four types of variables in Ruby:

1.Local variables: A local variable name starts with a lowercase letter or underscore (_). It is only accessible or have its scope within the block of its initialization. Once the code block completes, variable has no scope.
When uninitialized local variables are called, they are interpreted as call to a method that has no arguments.
# Example of local variable:
color = "Red"
def method1 
color = 192
puts("Color Value in method1 : ",color)
end 
def method2
color = 255
puts("Color Value method2: ",color)
end
method1 
method2  
method1
puts("Color Value outside methods : "+color)

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Color Value in method1 : 
192
Color Value method2: 
255
Color Value in method1 : 
192
Color Value outside methods : Red

2.Class variables: A class variable name starts with @@ sign. They need to be initialized before use. A class variable belongs to the whole class and can be accessible from anywhere inside the class. If the value will be changed at one instance, it will be changed at every instance.
A class variable is shared by all the descendents of the class. An uninitialized class variable will result in an error.
# Example of class variable:
class Customer
# class variable
 @@no_of_customers = 0
 def initialize(id, name, addr)   
# An instance Variable
 @cust_id = id
 @cust_name = name
 @cust_addr = addr
 end
# displaying result 
 def display_details()
 puts "Customer id #@cust_id"
 puts "Customer name #@cust_name"
 puts "Customer address #@cust_addr"
 end 
 def total_no_of_customers()   
# class variable
 @@no_of_customers += 1
 puts "Total number of customers: #@@no_of_customers"
    end
end
# Create Objects
cust1 = Customer.new("1", "Ram", "BPTP, Faridabad")
cust2 = Customer.new("2", "Ruchi", "Gol Chakkar road,Kalkaji")
# Call Methods
cust1.display_details()
cust1.total_no_of_customers()
cust2.display_details()
cust2.total_no_of_customers()

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Customer id 1
Customer name Ram
Customer address BPTP, Faridabad
Total number of customers: 1
Customer id 2
Customer name Ruchi
Customer address Gol Chakkar road,Kalkaji
Total number of customers: 2

3.Instance variables: An instance variable name starts with a @ sign. It belongs to one instance of the class and can be accessed from any instance of the class within a method. 
They only have limited access to a particular instance of a class,instance variables can change from object to object.
They don't need to be initialize. An uninitialized instance variable will have a nil value.
# EXAMPLE OF INSTANCE VARIABLE:
class Customer
 def initialize(id, name, addr)
# Instance Variables     
 @cust_id = id
 @cust_name = name
 @cust_addr = addr
 end 
 # displaying result
 def display_details()
 puts "Customer id #@cust_id"
 puts "Customer name #@cust_name"
 puts "Customer address #@cust_addr"
 end
end
# Create Objects
cust1 = Customer.new("1", "John", "Wisdom Apartments, Ludhiya")
cust2 = Customer.new("2", "Poul", "New Empire road, Khandala")
# Call Methods
cust1.display_details()
cust2.display_details()

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Customer id 1
Customer name John
Customer address Wisdom Apartments, Ludhiya
Customer id 2
Customer name Poul
Customer address New Empire road, Khandala

# Another example:
class Student
  def initialize(student_id, student_name)
    @student_id = student_id
    @student_name = student_name
  end
  
  def show
    puts "Student Name and ID : "
    puts(@student_id, @student_name)
  end
end
Student.new(1, "Sara").show
Student.new(2, "Raju").show
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Student Name and ID : 
1
Sara
Student Name and ID : 
2
Raju

4.Global variables: A global variable name starts with a $ sign. Its scope is globally, means it can be accessed from any where in a program.An uninitialized global variable will have a nil value.
# Example of Gloabal Variable:
# global variable
$global_variable = 10
class Class1
 def print_global
 puts "Global variable in Class1 is #$global_variable"
 end
end
class Class2
 def print_global
 puts "Global variable in Class2 is #$global_variable"
 end
end
class1obj = Class1.new
class1obj.print_global
class2obj = Class2.new
class2obj.print_global

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Global variable in Class1 is 10
Global variable in Class2 is 10

# Symbol	Type of Variable:
[a-z] or _	Local Variable
@	Instance Variable
@@	Class Variable
$	Global Variable

# Ruby Constants:
Constants begin with an uppercase letter. Constants defined within a class or module can be accessed from within that class or module, and those defined outside a class or module can be accessed globally.

ex- class Example
 VAR1 = 100
 VAR2 = 200
 def show
 puts "Value of first constant is #{VAR1}"
 puts "Value of second constant is #{VAR2}"
 end
end
object = Example.new()
object.show

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Value of first constant is 100
Value of second constant is 200

# Operators:
1.Ruby Arithmetic Operators:
Operator  Description	                                                                                    Example
+         Addition − Adds values on either side of the operator.	                                     a + b will give 30
−	  Subtraction − Subtracts right hand operand from left hand operand.	                             a - b will give -10
*	  Multiplication − Multiplies values on either side of the operator.	                             a * b will give 200
/	  Division − Divides left hand operand by right hand operand.	                             b / a will give 2
%	  Modulus − Divides left hand operand by right hand operand and returns remainder.	              b % a will give 0
**	  Exponent − Performs exponential (power) calculation on operators.	                            a**b will give 10 to the power 20

3.0.0 :013 >  a = 10
 => 10 
3.0.0 :014 > b = 20
 => 20 
3.0.0 :015 > a+b
 => 30 
3.0.0 :016 > a-b
 => -10 
3.0.0 :017 > a*b
 => 200 
3.0.0 :018 > b/a
 => 2 
3.0.0 :019 > b%a
 => 0 
3.0.0 :020 > a**b
 => 100000000000000000000 

2.Ruby Comparison Operators:
Operator	Description	                                                                                                       Example
==	Checks if the value of two operands are equal or not, if yes then condition becomes true.	                                   (a == b) is not true.
!=	Checks if the value of two operands are equal or not, if values are not equal then condition becomes true.	                    (a != b) is true.
>	Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.	    (a > b) is not true.
<	Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.	            (a < b) is true.
>=	Checks if the value of left operand is greater than or equal to the value of right operand,if yes then condition becomes true.  (a >= b) is not true.
<=	Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.    (a <= b) is true.
<=>	Combined comparison operator. Returns 0 if first operand equals second, 1 if first operand is greater than the second 
        and -1 if first operand is less than the second.	                                                                          (a <=> b) returns -1.
===	Used to test equality within a when clause of a case statement.	                                                           (1...10) === 5 returns true.
.eql?	True if the receiver and argument have both the same type and equal values.(Checks datatype as 1!=1.0 i.e 1 is int)              1 == 1.0 returns true, but 1.eql?(1.0) is false.
equal?	True if the receiver and argument have the same object id.	                                                                   if aObj is duplicate of bObj then aObj == bObj is true, 
                                                                                                                                         a.equal?bObj is false but a.equal?aObj is true.

                                                                                                                                         
3.0.0 :021 > a==b
 => false 
3.0.0 :022 > a!=b
 => true 
3.0.0 :023 > a>b
 => false 
3.0.0 :024 > a<b
 => true 
3.0.0 :025 > a>=b
 => false 
3.0.0 :026 > a<=b
 => true 
3.0.0 :027 > a===b
 => false 
3.0.0 :030 > 10.eql?20
 => false 
3.0.0 :031 > c = 1
 => 1 
3.0.0 :032 > d = 1.0
 => 1.0 
3.0.0 :033 > 1.eql?1.0
 => false 
3.0.0 :034 > c = 1
 => 1 
3.0.0 :035 > d = 2
 => 2 
3.0.0 :036 > 1.eql?2
 => false 
3.0.0 :037 > d = 1
 => 1 
3.0.0 :038 > c.eql?d
 => true 
 
 3. Ruby Assignment Operators:
 Ruby Assignment Operator
 
= it is simple assignmnet operator
+= add and assignment operator
-= subtract and assignment operator
*=
/=
%=
**=
 all above are arithmatic and assignment operator which behave in same way
 fist the arithmatic operator works and than the result value is assigned to 
 the left operand

 3.0.0 :001 > a=4
 => 4 
3.0.0 :002 > b=5
 => 5 
3.0.0 :003 > a+b
 => 9 
3.0.0 :004 > a+=b
 => 9 
3.0.0 :005 > a
 => 9 

4.Parallel Assignment
 This enables multiple values to be initialized  within single line

 eg  a,b,c =10,20,30
 3.0.0 :046 > a,b,c=10,20,30
 => [10, 20, 30] 
 
3.0.0 :006 > a,b,c = 10, 20, 30
 => [10, 20, 30] 
3.0.0 :007 > a
 => 10 
3.0.0 :008 > b
 => 20 
 => 30 
3.0.0 :011 > puts(a,b,c)
10
20
30
 => nil

5.Ruby Bitwise Operators
  Bitwise Operators works on Bits and Perform Bit by Bit Operation
  a    =  0011 1100
  b    =  0000 1101
  ------------------
  a&b  =  0000 1100   it is binary AND
  a|b  =  0011 1101   it is binary OR
  a^b  =  0011 0001   it is binary XOR
  ~a   =  1100 0011   it is complemantary operator

  << it is Left Shift Operator moved by the no of bits speacified
  >> It is Right Shift Operator moved by the no of bits speacified
eg, if a is 0011 1100
 a<<2 is 1111 0000
a>>2  is 0000 1111

6.Ruby Logical Operator

and  logical and Operator both conditions must be true 
or  logical or operator either conditions should be true 
&&  anothe way of writing AND but bothe side must be non zero
||  another way of writing OR but either side need to be non zero
!   Logical NOT Operator reverses the state of the operator
not  same as above


7.Ruby Ternary Operator
?:  Conditonal expression
If Condition is true ? Then value X : Otherwise value Y


8.Ruby Range Operator
It is used to create a range of successive values - 
consisting of a start value, an end value, and a 
range of values in between.

The two-dot form creates an inclusive range, 
while the three-dot form creates a range that 
excludes the specified high value.
so 1..10 is 1,2,3,4,5,6,7,8,9,10
and 1...10 is 1,2,3,4,5,6,7,8,9

9.Ruby defined? Operators
defined? is a special operator that takes the form of a method call to determine whether or not the passed expression is defined. 
It returns a description string of the expression, or nil if the expression isn't defined.
-defined? variable # True if variable is initialized.
-defined? method_call # True if a method is defined
-# True if a method exists that can be called with super user
defined? super
-defined? yield   # True if a code block has been passed
Ex- defined? yield    # => "yield" (if there is a block passed)
defined? yield    # => nil (if there is no block)

10.Ruby Dot "." and Double Colon "::" Operators
You call a module method by preceding its name with the module's name and a period, and you reference a constant using the module name and two colons.
The :: is a unary operator that allows: constants, instance methods and class methods defined within a class or module, to be accessed from anywhere outside the class or module.
Remember in Ruby, classes and methods may be considered constants too.
You need to just prefix the :: Const_name with an expression that returns the appropriate class or module object.
If no prefix expression is used, the main Object class is used by default.
Ex- MR_COUNT = 0         # constant defined on main Object class
module Foo
   MR_COUNT = 0
   ::MR_COUNT = 1    # set global count to 1
   MR_COUNT = 2      # set local count to 2
end
puts MR_COUNT        # this is the global constant
puts Foo::MR_COUNT   # this is the local "Foo" constant

# If-else,unless in Ruby:
# Ruby if...else Statement:
The if expressions execute a single statement or a group of statements if a certain condition is met. It can not do anything if the condition is false. For this purpose else is used.
Syntax
if conditional [then]
   code...
[elsif conditional [then]
   code...]...
[else
   code...]
end

3.0.0 :047 > x = 1
 => 1 
3.0.0 :048 > if x > 2
3.0.0 :049 >    puts "x is greater than 2"
3.0.0 :050 > elsif x <= 2 and x!=0
3.0.0 :051 >    puts "x is 1"
3.0.0 :052 > else
3.0.0 :053 >    puts "I can't guess the number"
3.0.0 :054 > end
x is 1
 => nil 
 
 3.0.0 :061 > x = 100
 => 100 
3.0.0 :062 > if x == 1
3.0.0 :063 >   puts "x is One."
3.0.0 :064 > elsif x == 100
3.0.0 :065 >   puts "x is Hundred."
3.0.0 :066 > else
3.0.0 :067 >   puts "x has different value."
3.0.0 :068 > end
x is Hundred.
 => nil 

# Ruby unless Statement
The unless expression is the opposite of the if expression. If the value is false the "then" expression is executed :
Syntax
unless conditional [then]
   code
[else
   code ]
end
Executes code if conditional is false. If the conditional is true, code specified in the else clause is executed.
3.0.0 :070 > unless x > 0
3.0.0 :071 >  puts "x is less than 0"
3.0.0 :072 > end
 => nil 
3.0.0 :073 > x = 1
 => 1 
3.0.0 :074 > unless x > 0
3.0.0 :075 >  puts "x is less than 0"
3.0.0 :076 > else   
3.0.0 :077 >  puts "x is greater than 0"
3.0.0 :078 > end
x is greater than 0
 => nil 

.0.0 :088 > if a>b
3.0.0 :089 > puts"a is greater than b"
3.0.0 :090 > elseif b>a
3.0.0 :091 > puts"b is greater than a"
3.0.0 :092 > else
3.0.0 :093 > puts"a is equal to b"
3.0.0 :094 > end
a is greater than b

#Ruby case Statement
Syntax
case expression
[when expression [, expression ...] [then]
   code ]...
[else
   code ]
end

case expr0
when expr1, expr2
   stmt1
when expr3, expr4
   stmt2
else
   stmt3
end

is basically similar to the following −
_tmp = expr0
if expr1 === _tmp || expr2 === _tmp
   stmt1
elsif expr3 === _tmp || expr4 === _tmp
   stmt2
else
   stmt3
end

Ex- 3.0.0 :108 > $age = 16
 => 16 
3.0.0 :109 > case $age
3.0.0 :110 > when 0 .. 2
3.0.0 :111 >    puts "baby"
3.0.0 :112 > when 3 .. 6
3.0.0 :113 >    puts "little child"
3.0.0 :114 > when 7 .. 12
3.0.0 :115 >    puts "child"
3.0.0 :116 > when 13 .. 18
3.0.0 :117 >    puts "youth"
3.0.0 :118 > else
3.0.0 :119 >    puts "adult"
3.0.0 :120 > end
youth
 => nil 
 
  Loops in Ruby:
Loops in Ruby are used to execute the same block of code a specified number of times.
1.Ruby while Statement
Syntax
while conditional [do]
   code
end

Ex-3.0.0 :121 > $i = 0
 => 0 
3.0.0 :122 > $num = 5
 => 5 
3.0.0 :123 > while $i<$num do
3.0.0 :124 >   puts("Inside the loop i=#$i")
3.0.0 :125 >   $i +=1
3.0.0 :126 > end
Inside the loop i=0
Inside the loop i=1
Inside the loop i=2
Inside the loop i=3
Inside the loop i=4
 => nil 

-Ruby while modifier
Syntax
code while condition

OR

begin 
  code 
end while conditional

Ex- 3.0.0 :127 > $i = 0
 => 0 
3.0.0 :128 > $num = 5
 => 5 
3.0.0 :129 > begin
3.0.0 :130 >    puts("Inside the loop i = #$i" )
3.0.0 :131 >    $i +=1
3.0.0 :132 > end while $i < $num
Inside the loop i = 0
Inside the loop i = 1
Inside the loop i = 2
Inside the loop i = 3
Inside the loop i = 4
 => nil 

# Ruby until Statement
until conditional [do]
   code
end

Ex- 3.0.0 :133 > $i = 0
 => 0 
3.0.0 :134 > $num = 5
 => 5 
3.0.0 :135 > 
3.0.0 :136 > until $i > $num  do
3.0.0 :137 >    puts("Inside the loop i = #$i" )
3.0.0 :138 >    $i +=1;
3.0.0 :139 > end
Inside the loop i = 0
Inside the loop i = 1
Inside the loop i = 2
Inside the loop i = 3
Inside the loop i = 4
Inside the loop i = 5
 => nil 
 
3.Ruby for Statement
Syntax
for variable [, variable ...] in expression [do]
   code
end

Ex- 3.0.0 :001 > for i in 0..5
3.0.0 :002 >    puts "Value of local variable is #{i}"
3.0.0 :003 > end
Value of local variable is 0
Value of local variable is 1
Value of local variable is 2
Value of local variable is 3
Value of local variable is 4
Value of local variable is 5
 => 0..5 

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ irb
3.0.0 :001 > for i in 1...10
3.0.0 :002 >     puts"Hello Ruby"
3.0.0 :003 > end
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
 => 1...10 
## Here ... means loop will print value one less than given condition i.e here value is printed 9 times.

3.0.0 :004 > for i in 1..10
3.0.0 :005 >     puts"Hello Ruby"
3.0.0 :006 > end
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
 => 1..10 
 ## Here .. means loop will print value equal to the given condition i.e here value is printed 10 times.
 
# Another method of writing For loop using each do:
A for...in loop is almost exactly equivalent to the following −
(expression).each do |variable[, variable...]| code end

3.0.0 :005 > (0..8).each do |i|
3.0.0 :006 >    puts "Value of local variable is #{i}"
3.0.0 :007 > end
Value of local variable is 0
Value of local variable is 1
Value of local variable is 2
Value of local variable is 3
Value of local variable is 4
Value of local variable is 5
Value of local variable is 6
Value of local variable is 7
Value of local variable is 8

4.Ruby break Statement
Syntax
break
Terminates the most internal loop. Terminates a method with an associated block if called within the block (with the method returning nil).

ex- 3.0.0 :008 > for i in 0..5
3.0.0 :009 >    if i > 2 then
3.0.0 :010 >       break
3.0.0 :011 >    end
3.0.0 :012 >    puts "Value of local variable is #{i}"
3.0.0 :013 > end
Value of local variable is 0
Value of local variable is 1
Value of local variable is 2
 => nil 

# Ruby next Statement
Syntax
next
Jumps to the next iteration of the most internal loop. Terminates execution of a block if called within a block (with yield or call returning nil).
Ex-3.0.0 :014 > for i in 0..4
3.0.0 :015 >    if i < 2 then
3.0.0 :016 >       next
3.0.0 :017 >    end
3.0.0 :018 >    puts "Value of local variable is #{i}"
3.0.0 :019 > end
Value of local variable is 2
Value of local variable is 3
Value of local variable is 4
 => 0..4 

#Ruby redo Statement
Syntax
redo
Restarts this iteration of the most internal loop, without checking loop condition. Restarts yield or call if called within a block.
Ex- for i in 0..5
   if i < 2 then
      puts "Value of local variable is #{i}"
      redo
   end
end
This will produce the following result and will go in an infinite loop −
Value of local variable is 0
Value of local variable is 0
............................

# Ruby retry Statement
Syntax
retry
If retry appears in rescue clause of begin expression, restart from the beginning of the begin body.
begin
   do_something # exception raised
rescue
   # handles error
   retry  # restart from beginning
end
Ex-If retry appears in the iterator, the block, or the body of the for expression, restarts the invocation of the iterator call. Arguments to the iterator is re-evaluated.

for i in 1..5
   retry if some_condition # restart from i == 1
end
Ex- for i in 0..5
   retry if i > 2
puts "Value of local variable is #{i}"
end
This will produce the following result and will go in an infinite loop −

Value of local variable is 1
Value of local variable is 2
Value of local variable is 1
Value of local variable is 2
Value of local variable is 1
Value of local variable is 2
............................

# Ruby - Methods:
-A method in ruby always starts with the "def" keyword.
-Method name always starts with a lower case character,just like we define local variables in ruby.
-Method always end with the 'end' keyword.
-Methods should be defined before calling them, otherwise Ruby will raise an exception for undefined method invoking.
-The return statement in ruby is used to return one or more values from a Ruby Method.
- Last line of method is already considered as return statement so no need to use "return" keyword.
Syntax:
def method_name 
   expr..
end

Ex- 3.0.0 :007 > def example_method
3.0.0 :008 >   puts"Hello World"
3.0.0 :009 > end
 => :example_method 
3.0.0 :010 > example_method
Hello World
 => nil 
 
 # Methods with arguments:
 3.0.0 :011 > def area(length,width)
3.0.0 :012 >   length*width
3.0.0 :013 > end
 => :area 
3.0.0 :014 > area(3,2)
 => 6 
 
 # Methods with no arguments:
 3.0.0 :015 > def rectangle_area
3.0.0 :016 >   length = 10
3.0.0 :017 >   width = 5
3.0.0 :018 >   length * width
3.0.0 :019 > end
 => :rectangle_area 
3.0.0 :020 > rectangle_area
 => 50 
 
 # Method with default arguments:
 - Arguments can be anything like string,arrays,boolean etc.
 3.0.0 :021 > def area(length=10, width=20)
3.0.0 :022 >   length*width
3.0.0 :023 > end
 => :area 
3.0.0 :024 > area
 => 200 
 
 3.0.0 :025 > def test(a1 = "Ruby", a2 = "Perl")
3.0.0 :026 >    puts "The programming language is #{a1}"
3.0.0 :027 >    puts "The programming language is #{a2}"
3.0.0 :028 > end
 => :test 
3.0.0 :029 > test "C", "C++"
The programming language is C
The programming language is C++
 => nil 
3.0.0 :030 > test
The programming language is Ruby
The programming language is Perl
 => nil 

# Ruby Return statement:
.0.0 :031 > def test
3.0.0 :032 >   i = 100
3.0.0 :033 >   j = 200
3.0.0 :034 >   k = 300
3.0.0 :035 >   return i,j,k
3.0.0 :036 > end
 => :test 
3.0.0 :037 > var = test
 => [100, 200, 300] 
3.0.0 :038 > puts var
100
200
300
 => nil 

# Class Methods:
3.0.0 :039 > class Accounts
3.0.0 :040 >    def reading_charge
3.0.0 :041 >    end
3.0.0 :042 >    def Accounts.return_date
3.0.0 :043 >    end
3.0.0 :044 > end
 => :return_date 
See how the method return_date is declared. It is declared with the class name followed by a period, which is followed by the name of the method.
To access this method, you need not create objects of the class Accounts.

# Ruby alias Statement
This gives alias to methods or global variables. Aliases cannot be defined within the method body. The alias of the method keeps the current definition of the method, even when methods are overridden.
Syntax-
alias method-name method-name
alias global-variable-name global-variable-name
Example-
alias foo bar
alias $MATCH $&
Here we have defined foo alias for bar, and $MATCH is an alias for $&

# Ruby undef Statement
This cancels the method definition. An undef cannot appear in the method body.
By using undef and alias, the interface of the class can be modified independently from the superclass, but notice it may be broke programs by the internal method call to self.
Syntax-
undef method-name

# Ruby - Blocks
Ruby defines methods where you can put number of statements and then you call that method. Similarly, Ruby has a concept of Block.
-A block consists of chunks of code.
-You assign a name to a block.
-The code in the block is always enclosed within braces ({}).
-A block is always invoked from a function with the same name as that of the block. This means that if you have a block with the name test, then you use the function test to invoke this block.
-You invoke a block by using the yield statement.
Syntax-
block_name {
   statement1
   statement2
   ..........
}

# The yield Statement:
Ex- 3.0.0 :051 > def test
3.0.0 :052 >   puts "You are in the method"
3.0.0 :053 >   yield
3.0.0 :054 >   puts "you are again back to the method"
3.0.0 :055 >   yield
3.0.0 :056 > end
 => :test 
3.0.0 :057 > test{puts "You are in the block"}
You are in the method
You are in the block
you are again back to the method
You are in the block
 => nil 

Ex-3.0.0 :058 > def test
3.0.0 :059 >   yield 5
3.0.0 :060 >   puts "You are in the method test"
3.0.0 :061 >   yield 50
3.0.0 :062 > end
 => :test 
3.0.0 :063 > test{|i| puts "You are in the block #{i}"}
You are in the block 5
You are in the method test
You are in the block 50
 => nil 
Here, the yield statement is written followed by parameters. You can even pass more than one parameter. In the block, you place a variable between two vertical lines (||) to accept the parameters. Therefore, in the preceding code, the yield 5 statement passes the value 5 as a parameter to the test block.

-If you want to pass more than one parameters, then the yield statement becomes −
yield a, b
and the block is −
test {|a, b| statement}

# Blocks and Methods:
You normally invoke a block by using the yield statement from a method that has the same name as that of the block.

Ex- 3.0.0 :069 > def test
3.0.0 :070 >   yield
3.0.0 :071 > end
 => :test 
3.0.0 :072 > test{puts"hello world"}
hello world
 => nil 
 
-But if the last argument of a method is preceded by &, then you can pass a block to this method and this block will be assigned to the last parameter. In case both * and & are present in the argument list, & should come later.
3.0.0 :001 > def test(&block)
3.0.0 :002 >   block.call
3.0.0 :003 > end
 => :test 
3.0.0 :004 > test {puts "Hello"}
Hello
 => nil 

# Begin and End blocks:
BEGIN { 
   # BEGIN block code 
   puts "BEGIN code block"
} 

END { 
   # END block code 
   puts "END code block"
}
   # MAIN block code 
puts "MAIN code block"

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
BEGIN code block
MAIN code block
END code block
