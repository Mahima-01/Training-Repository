Ruby is a perfect Object Oriented Programming Language. The features of the object-oriented programming language include −
Data Encapsulation
Data Abstraction
Polymorphism
Inheritance

# Basic ruby code practice:
itsacheckmate@itsacheckmate:~$ irb
3.0.0 :001 > puts "Learning Ruby";
Learning Ruby
 => nil 
3.0.0 :002 > def Helloout = "Hello World"
3.0.0 :003 >   
 => :Helloout 
3.0.0 :004 > def hello
3.0.0 :005 >   out = "Hello World"
3.0.0 :006 >   puts out
3.0.0 :007 > end
 => :hello 
3.0.0 :008 > hello
Hello World
 => nil 
3.0.0 :009 > exit

itsacheckmate@itsacheckmate:~$ cd Training-Repository/
itsacheckmate@itsacheckmate:~/Training-Repository$ Rvm\ and\ Ruby/
Hello,started learning Rub
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Hello,started learning Ruby
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ irb
3.0.0 :001"> print <<EOF
3.0.0 :002"> This is the first way of creating
3.0.0 :003"> here document ie. multiple string.
3.0.0 :004"> EOF
3.0.0 :006"> This is the second way of creating
3.0.0 :007"> here document ie. multiple line string.
3.0.0 :008 > EOF
This is the second way of creating
here document ie. multiple line string.
 => nil 

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ irb
3.0.0 :001"> print <<"EOC";
3.0.0 :002"> echo hy
3.0.0 :003"> EOC
echo hy
 => nil 
3.0.0 :004`> print <<`EOC`;                      #SAME AS ABOVE
3.0.0 :005`> echo hy
3.0.0 :006`> echo there
3.0.0 :007 > EOC
hy
there
 => nil 
3.0.0 :008"> print <<"foo",<<"bar"
3.0.0 :009"> I said foo.
3.0.0 :010"> foo
3.0.0 :011"> I said bar.
3.0.0 :012 > bar
I said foo.
I said bar.
 => nil 

3.0.0 :013 > puts "This is main Ruby Program"
This is main Ruby Program
 => nil 

# Using BEGIN Statement:
--> First put block of code in a file then it will execute.
--> It will show the line which is entered in "begin" block firstly then other lines of the file.
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Initializing Ruby Program
Hello,started learning Ruby
This is main Ruby Program

# Using END Statement:
--> Declares code to be called at the end of the program.
puts "Hello,started learning Ruby";
puts "This is main Ruby Program"
BEGIN {
   puts "Initializing first Ruby Program"
}
END {
   puts "Terminating Ruby Program"
}
BEGIN {
   puts "Initializing second Ruby Program"
}
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Initializing first Ruby Program
Initializing second Ruby Program
Hello,started learning Ruby
This is main Ruby Program
Terminating Ruby Program

# Ruby Comments
-->A comment hides a line, part of a line, or several lines from the Ruby interpreter. You can use the hash character (#) at the beginning of a line −
# I am a comment. Just ignore me.
Or, a comment may be on the same line after a statement or expression −
name = "Maddy" # This is again comment
You can comment multiple lines as follows −
# This is a comment.
# This is a comment, too.
# This is a comment, too.
# I said that already.
Here is another form. This block comment conceals several lines from the interpreter with =begin/=end −
=begin
This is a comment.
This is a comment, too.
This is a comment, too.
I said that already.
=end (Will not display anything becoz it is a comment.)

# Defining a Class in Ruby:
A class in Ruby always starts with the keyword class followed by the name of the class. The name should always be in initial capitals. The class Customer can be displayed as −
Syntax:
class Customer
end
You terminate a class by using the keyword end.

# Variables:
Variables are the memory locations, which hold any data to be used by any program.
Unlike other programming languages, there is no need to declare a variable in Ruby. A prefix is needed to indicate it.
There are four types of variables in Ruby:

1.Local variables: A local variable name starts with a lowercase letter or underscore (_). It is only accessible or have its scope within the block of its initialization. Once the code block completes, variable has no scope.
When uninitialized local variables are called, they are interpreted as call to a method that has no arguments.
# Example of local variable:
color = "Red"
def method1 
color = 192
puts("Color Value in method1 : ",color)
end 
def method2
color = 255
puts("Color Value method2: ",color)
end
method1 
method2  
method1
puts("Color Value outside methods : "+color)

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Color Value in method1 : 
192
Color Value method2: 
255
Color Value in method1 : 
192
Color Value outside methods : Red

2.Class variables: A class variable name starts with @@ sign. They need to be initialized before use. A class variable belongs to the whole class and can be accessible from anywhere inside the class. If the value will be changed at one instance, it will be changed at every instance.
A class variable is shared by all the descendents of the class. An uninitialized class variable will result in an error.
# Example of class variable:
class Customer
# class variable
 @@no_of_customers = 0
 def initialize(id, name, addr)   
# An instance Variable
 @cust_id = id
 @cust_name = name
 @cust_addr = addr
 end
# displaying result 
 def display_details()
 puts "Customer id #@cust_id"
 puts "Customer name #@cust_name"
 puts "Customer address #@cust_addr"
 end 
 def total_no_of_customers()   
# class variable
 @@no_of_customers += 1
 puts "Total number of customers: #@@no_of_customers"
    end
end
# Create Objects
cust1 = Customer.new("1", "Ram", "BPTP, Faridabad")
cust2 = Customer.new("2", "Ruchi", "Gol Chakkar road,Kalkaji")
# Call Methods
cust1.display_details()
cust1.total_no_of_customers()
cust2.display_details()
cust2.total_no_of_customers()

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Customer id 1
Customer name Ram
Customer address BPTP, Faridabad
Total number of customers: 1
Customer id 2
Customer name Ruchi
Customer address Gol Chakkar road,Kalkaji
Total number of customers: 2

3.Instance variables: An instance variable name starts with a @ sign. It belongs to one instance of the class and can be accessed from any instance of the class within a method. 
They only have limited access to a particular instance of a class,instance variables can change from object to object.
They don't need to be initialize. An uninitialized instance variable will have a nil value.
# EXAMPLE OF INSTANCE VARIABLE:
class Customer
 def initialize(id, name, addr)
# Instance Variables     
 @cust_id = id
 @cust_name = name
 @cust_addr = addr
 end 
 # displaying result
 def display_details()
 puts "Customer id #@cust_id"
 puts "Customer name #@cust_name"
 puts "Customer address #@cust_addr"
 end
end
# Create Objects
cust1 = Customer.new("1", "John", "Wisdom Apartments, Ludhiya")
cust2 = Customer.new("2", "Poul", "New Empire road, Khandala")
# Call Methods
cust1.display_details()
cust2.display_details()

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Customer id 1
Customer name John
Customer address Wisdom Apartments, Ludhiya
Customer id 2
Customer name Poul
Customer address New Empire road, Khandala

# Another example:
class Student
  def initialize(student_id, student_name)
    @student_id = student_id
    @student_name = student_name
  end
  
  def show
    puts "Student Name and ID : "
    puts(@student_id, @student_name)
  end
end
Student.new(1, "Sara").show
Student.new(2, "Raju").show
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Student Name and ID : 
1
Sara
Student Name and ID : 
2
Raju

4.Global variables: A global variable name starts with a $ sign. Its scope is globally, means it can be accessed from any where in a program.An uninitialized global variable will have a nil value.
# Example of Gloabal Variable:
# global variable
$global_variable = 10
class Class1
 def print_global
 puts "Global variable in Class1 is #$global_variable"
 end
end
class Class2
 def print_global
 puts "Global variable in Class2 is #$global_variable"
 end
end
class1obj = Class1.new
class1obj.print_global
class2obj = Class2.new
class2obj.print_global

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Global variable in Class1 is 10
Global variable in Class2 is 10

# Symbol	Type of Variable:
[a-z] or _	Local Variable
@	Instance Variable
@@	Class Variable
$	Global Variable

# Ruby Constants:
Constants begin with an uppercase letter. Constants defined within a class or module can be accessed from within that class or module, and those defined outside a class or module can be accessed globally.

ex- class Example
 VAR1 = 100
 VAR2 = 200
 def show
 puts "Value of first constant is #{VAR1}"
 puts "Value of second constant is #{VAR2}"
 end
end
object = Example.new()
object.show

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Value of first constant is 100
Value of second constant is 200

# Operators:
1.Ruby Arithmetic Operators:
Operator  Description	                                                                                    Example
+         Addition − Adds values on either side of the operator.	                                     a + b will give 30
−	  Subtraction − Subtracts right hand operand from left hand operand.	                             a - b will give -10
*	  Multiplication − Multiplies values on either side of the operator.	                             a * b will give 200
/	  Division − Divides left hand operand by right hand operand.	                             b / a will give 2
%	  Modulus − Divides left hand operand by right hand operand and returns remainder.	              b % a will give 0
**	  Exponent − Performs exponential (power) calculation on operators.	                            a**b will give 10 to the power 20

3.0.0 :013 >  a = 10
 => 10 
3.0.0 :014 > b = 20
 => 20 
3.0.0 :015 > a+b
 => 30 
3.0.0 :016 > a-b
 => -10 
3.0.0 :017 > a*b
 => 200 
3.0.0 :018 > b/a
 => 2 
3.0.0 :019 > b%a
 => 0 
3.0.0 :020 > a**b
 => 100000000000000000000 

2.Ruby Comparison Operators:
Operator	Description	                                                                                                       Example
==	Checks if the value of two operands are equal or not, if yes then condition becomes true.	                                    (a == b) is not true.
!=	Checks if the value of two operands are equal or not, if values are not equal then condition becomes true.	                   (a != b) is true.
>	Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.	           (a > b) is not true.
<	Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.	              (a < b) is true.
>=	Checks if the value of left operand is greater than or equal to the value of right operand,if yes then condition becomes true.  (a >= b) is not true.
<=	Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.    (a <= b) is true.
<=>	Combined comparison operator. Returns 0 if first operand equals second, 1 if first operand is greater than the second 
        and -1 if first operand is less than the second.	                                                                          (a <=> b) returns -1.
===	Used to test equality within a when clause of a case statement.	                                                               (1...10) === 5 returns true.
.eql?	True if the receiver and argument have both the same type and equal values.(Checks datatype as 1!=1.0 i.e 1 is int)          1 == 1.0 returns true, but 1.eql?(1.0) is false.
equal?	True if the receiver and argument have the same object id.	                                                                 if aObj is duplicate of bObj then aObj == bObj is true, 
                                                                                                                                    a.equal?bObj is false but a.equal?aObj is true.

                                                                                                                                         
3.0.0 :021 > a==b
 => false 
3.0.0 :022 > a!=b
 => true 
3.0.0 :023 > a>b
 => false 
3.0.0 :024 > a<b
 => true 
3.0.0 :025 > a>=b
 => false 
3.0.0 :026 > a<=b
 => true 
3.0.0 :027 > a===b
 => false 
3.0.0 :030 > 10.eql?20
 => false 
3.0.0 :031 > c = 1
 => 1 
3.0.0 :032 > d = 1.0
 => 1.0 
3.0.0 :033 > 1.eql?1.0
 => false 
3.0.0 :034 > c = 1
 => 1 
3.0.0 :035 > d = 2
 => 2 
3.0.0 :036 > 1.eql?2
 => false 
3.0.0 :037 > d = 1
 => 1 
3.0.0 :038 > c.eql?d
 => true 
 
 3. Ruby Assignment Operators:
 Ruby Assignment Operator
 
= it is simple assignmnet operator
+= add and assignment operator
-= subtract and assignment operator
*=
/=
%=
**=
 all above are arithmatic and assignment operator which behave in same way
 fist the arithmatic operator works and than the result value is assigned to 
 the left operand

 3.0.0 :001 > a=4
 => 4 
3.0.0 :002 > b=5
 => 5 
3.0.0 :003 > a+b
 => 9 
3.0.0 :004 > a+=b
 => 9 
3.0.0 :005 > a
 => 9 

4.Parallel Assignment
 This enables multiple values to be initialized  within single line

 eg  a,b,c =10,20,30
 3.0.0 :046 > a,b,c=10,20,30
 => [10, 20, 30] 
 
3.0.0 :006 > a,b,c = 10, 20, 30
 => [10, 20, 30] 
3.0.0 :007 > a
 => 10 
3.0.0 :008 > b
 => 20 
 => 30 
3.0.0 :011 > puts(a,b,c)
10
20
30
 => nil

5.Ruby Bitwise Operators
  Bitwise Operators works on Bits and Perform Bit by Bit Operation
  a    =  0011 1100
  b    =  0000 1101
  ------------------
  a&b  =  0000 1100   it is binary AND
  a|b  =  0011 1101   it is binary OR
  a^b  =  0011 0001   it is binary XOR
  ~a   =  1100 0011   it is complemantary operator

  << it is Left Shift Operator moved by the no of bits speacified
  >> It is Right Shift Operator moved by the no of bits speacified
eg, if a is 0011 1100
 a<<2 is 1111 0000
a>>2  is 0000 1111

6.Ruby Logical Operator

and  logical and Operator both conditions must be true 
or  logical or operator either conditions should be true 
&&  anothe way of writing AND but bothe side must be non zero
||  another way of writing OR but either side need to be non zero
!   Logical NOT Operator reverses the state of the operator
not  same as above


7.Ruby Ternary Operator
?:  Conditonal expression
If Condition is true ? Then value X : Otherwise value Y


8.Ruby Range Operator
It is used to create a range of successive values - 
consisting of a start value, an end value, and a 
range of values in between.

The two-dot form creates an inclusive range, 
while the three-dot form creates a range that 
excludes the specified high value.
so 1..10 is 1,2,3,4,5,6,7,8,9,10
and 1...10 is 1,2,3,4,5,6,7,8,9

9.Ruby defined? Operators
defined? is a special operator that takes the form of a method call to determine whether or not the passed expression is defined. 
It returns a description string of the expression, or nil if the expression isn't defined.
-defined? variable # True if variable is initialized.
-defined? method_call # True if a method is defined
-# True if a method exists that can be called with super user
defined? super
-defined? yield   # True if a code block has been passed
Ex- defined? yield    # => "yield" (if there is a block passed)
defined? yield    # => nil (if there is no block)

10.Ruby Dot "." and Double Colon "::" Operators
You call a module method by preceding its name with the module's name and a period, and you reference a constant using the module name and two colons.
The :: is a unary operator that allows: constants, instance methods and class methods defined within a class or module, to be accessed from anywhere outside the class or module.
Remember in Ruby, classes and methods may be considered constants too.
You need to just prefix the :: Const_name with an expression that returns the appropriate class or module object.
If no prefix expression is used, the main Object class is used by default.
Ex- MR_COUNT = 0         # constant defined on main Object class
module Foo
   MR_COUNT = 0
   ::MR_COUNT = 1    # set global count to 1
   MR_COUNT = 2      # set local count to 2
end
puts MR_COUNT        # this is the global constant
puts Foo::MR_COUNT   # this is the local "Foo" constant

# If-else,unless in Ruby:
# Ruby if...else Statement:
The if expressions execute a single statement or a group of statements if a certain condition is met. It can not do anything if the condition is false. For this purpose else is used.
Syntax
if conditional [then]
   code...
[elsif conditional [then]
   code...]...
[else
   code...]
end

3.0.0 :047 > x = 1
 => 1 
3.0.0 :048 > if x > 2
3.0.0 :049 >    puts "x is greater than 2"
3.0.0 :050 > elsif x <= 2 and x!=0
3.0.0 :051 >    puts "x is 1"
3.0.0 :052 > else
3.0.0 :053 >    puts "I can't guess the number"
3.0.0 :054 > end
x is 1
 => nil 
 
 3.0.0 :061 > x = 100
 => 100 
3.0.0 :062 > if x == 1
3.0.0 :063 >   puts "x is One."
3.0.0 :064 > elsif x == 100
3.0.0 :065 >   puts "x is Hundred."
3.0.0 :066 > else
3.0.0 :067 >   puts "x has different value."
3.0.0 :068 > end
x is Hundred.
 => nil 

# Ruby unless Statement
The unless expression is the opposite of the if expression. If the value is false the "then" expression is executed :
Syntax
unless conditional [then]
   code
[else
   code ]
end
Executes code if conditional is false. If the conditional is true, code specified in the else clause is executed.
3.0.0 :070 > unless x > 0
3.0.0 :071 >  puts "x is less than 0"
3.0.0 :072 > end
 => nil 
3.0.0 :073 > x = 1
 => 1 
3.0.0 :074 > unless x > 0
3.0.0 :075 >  puts "x is less than 0"
3.0.0 :076 > else   
3.0.0 :077 >  puts "x is greater than 0"
3.0.0 :078 > end
x is greater than 0
 => nil 

.0.0 :088 > if a>b
3.0.0 :089 > puts"a is greater than b"
3.0.0 :090 > elseif b>a
3.0.0 :091 > puts"b is greater than a"
3.0.0 :092 > else
3.0.0 :093 > puts"a is equal to b"
3.0.0 :094 > end
a is greater than b

#Ruby case Statement
Syntax
case expression
[when expression [, expression ...] [then]
   code ]...
[else
   code ]
end

case expr0
when expr1, expr2
   stmt1
when expr3, expr4
   stmt2
else
   stmt3
end

is basically similar to the following −
_tmp = expr0
if expr1 === _tmp || expr2 === _tmp
   stmt1
elsif expr3 === _tmp || expr4 === _tmp
   stmt2
else
   stmt3
end

Ex- 3.0.0 :108 > $age = 16
 => 16 
3.0.0 :109 > case $age
3.0.0 :110 > when 0 .. 2
3.0.0 :111 >    puts "baby"
3.0.0 :112 > when 3 .. 6
3.0.0 :113 >    puts "little child"
3.0.0 :114 > when 7 .. 12
3.0.0 :115 >    puts "child"
3.0.0 :116 > when 13 .. 18
3.0.0 :117 >    puts "youth"
3.0.0 :118 > else
3.0.0 :119 >    puts "adult"
3.0.0 :120 > end
youth
 => nil 
 
  Loops in Ruby:
Loops in Ruby are used to execute the same block of code a specified number of times.
1.Ruby while Statement
Syntax
while conditional [do]
   code
end

Ex-3.0.0 :121 > $i = 0
 => 0 
3.0.0 :122 > $num = 5
 => 5 
3.0.0 :123 > while $i<$num do
3.0.0 :124 >   puts("Inside the loop i=#$i")
3.0.0 :125 >   $i +=1
3.0.0 :126 > end
Inside the loop i=0
Inside the loop i=1
Inside the loop i=2
Inside the loop i=3
Inside the loop i=4
 => nil 

-Ruby while modifier
Syntax
code while condition

OR

begin 
  code 
end while conditional

Ex- 3.0.0 :127 > $i = 0
 => 0 
3.0.0 :128 > $num = 5
 => 5 
3.0.0 :129 > begin
3.0.0 :130 >    puts("Inside the loop i = #$i" )
3.0.0 :131 >    $i +=1
3.0.0 :132 > end while $i < $num
Inside the loop i = 0
Inside the loop i = 1
Inside the loop i = 2
Inside the loop i = 3
Inside the loop i = 4
 => nil 

# Ruby until Statement
until conditional [do]
   code
end

Ex- 3.0.0 :133 > $i = 0
 => 0 
3.0.0 :134 > $num = 5
 => 5 
3.0.0 :135 > 
3.0.0 :136 > until $i > $num  do
3.0.0 :137 >    puts("Inside the loop i = #$i" )
3.0.0 :138 >    $i +=1;
3.0.0 :139 > end
Inside the loop i = 0
Inside the loop i = 1
Inside the loop i = 2
Inside the loop i = 3
Inside the loop i = 4
Inside the loop i = 5
 => nil 
 
3.Ruby for Statement
Syntax
for variable [, variable ...] in expression [do]
   code
end

Ex- 3.0.0 :001 > for i in 0..5
3.0.0 :002 >    puts "Value of local variable is #{i}"
3.0.0 :003 > end
Value of local variable is 0
Value of local variable is 1
Value of local variable is 2
Value of local variable is 3
Value of local variable is 4
Value of local variable is 5
 => 0..5 

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ irb
3.0.0 :001 > for i in 1...10
3.0.0 :002 >     puts"Hello Ruby"
3.0.0 :003 > end
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
 => 1...10 
## Here ... means loop will print value one less than given condition i.e here value is printed 9 times.

3.0.0 :004 > for i in 1..10
3.0.0 :005 >     puts"Hello Ruby"
3.0.0 :006 > end
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
 => 1..10 
 ## Here .. means loop will print value equal to the given condition i.e here value is printed 10 times.
 
# Another method of writing For loop using each do:
A for...in loop is almost exactly equivalent to the following −
(expression).each do |variable[, variable...]| code end

3.0.0 :005 > (0..8).each do |i|
3.0.0 :006 >    puts "Value of local variable is #{i}"
3.0.0 :007 > end
Value of local variable is 0
Value of local variable is 1
Value of local variable is 2
Value of local variable is 3
Value of local variable is 4
Value of local variable is 5
Value of local variable is 6
Value of local variable is 7
Value of local variable is 8

4.Ruby break Statement
Syntax
break
Terminates the most internal loop. Terminates a method with an associated block if called within the block (with the method returning nil).

ex- 3.0.0 :008 > for i in 0..5
3.0.0 :009 >    if i > 2 then
3.0.0 :010 >       break
3.0.0 :011 >    end
3.0.0 :012 >    puts "Value of local variable is #{i}"
3.0.0 :013 > end
Value of local variable is 0
Value of local variable is 1
Value of local variable is 2
 => nil 

# Ruby next Statement
Syntax
next
Jumps to the next iteration of the most internal loop. Terminates execution of a block if called within a block (with yield or call returning nil).
Ex-3.0.0 :014 > for i in 0..4
3.0.0 :015 >    if i < 2 then
3.0.0 :016 >       next
3.0.0 :017 >    end
3.0.0 :018 >    puts "Value of local variable is #{i}"
3.0.0 :019 > end
Value of local variable is 2
Value of local variable is 3
Value of local variable is 4
 => 0..4 

#Ruby redo Statement
Syntax
redo
Restarts this iteration of the most internal loop, without checking loop condition. Restarts yield or call if called within a block.
Ex- for i in 0..5
   if i < 2 then
      puts "Value of local variable is #{i}"
      redo
   end
end
This will produce the following result and will go in an infinite loop −
Value of local variable is 0
Value of local variable is 0
............................

# Ruby retry Statement
Syntax
retry
If retry appears in rescue clause of begin expression, restart from the beginning of the begin body.
begin
   do_something # exception raised
rescue
   # handles error
   retry  # restart from beginning
end
Ex-If retry appears in the iterator, the block, or the body of the for expression, restarts the invocation of the iterator call. Arguments to the iterator is re-evaluated.

for i in 1..5
   retry if some_condition # restart from i == 1
end
Ex- for i in 0..5
   retry if i > 2
puts "Value of local variable is #{i}"
end
This will produce the following result and will go in an infinite loop −

Value of local variable is 1
Value of local variable is 2
Value of local variable is 1
Value of local variable is 2
Value of local variable is 1
Value of local variable is 2
............................

# Ruby - Methods:
-A method in ruby always starts with the "def" keyword.
-Method name always starts with a lower case character,just like we define local variables in ruby.
-Method always end with the 'end' keyword.
-Methods should be defined before calling them, otherwise Ruby will raise an exception for undefined method invoking.
-The return statement in ruby is used to return one or more values from a Ruby Method.
- Last line of method is already considered as return statement so no need to use "return" keyword.
Syntax:
def method_name 
   expr..
end

Ex- 3.0.0 :007 > def example_method
3.0.0 :008 >   puts"Hello World"
3.0.0 :009 > end
 => :example_method 
3.0.0 :010 > example_method
Hello World
 => nil 
 
 # Methods with arguments:
 3.0.0 :011 > def area(length,width)
3.0.0 :012 >   length*width
3.0.0 :013 > end
 => :area 
3.0.0 :014 > area(3,2)
 => 6 
 
 # Methods with no arguments:
 3.0.0 :015 > def rectangle_area
3.0.0 :016 >   length = 10
3.0.0 :017 >   width = 5
3.0.0 :018 >   length * width
3.0.0 :019 > end
 => :rectangle_area 
3.0.0 :020 > rectangle_area
 => 50 
 
 # Method with default arguments:
 - Arguments can be anything like string,arrays,boolean etc.
 3.0.0 :021 > def area(length=10, width=20)
3.0.0 :022 >   length*width
3.0.0 :023 > end
 => :area 
3.0.0 :024 > area
 => 200 
 
 3.0.0 :025 > def test(a1 = "Ruby", a2 = "Perl")
3.0.0 :026 >    puts "The programming language is #{a1}"
3.0.0 :027 >    puts "The programming language is #{a2}"
3.0.0 :028 > end
 => :test 
3.0.0 :029 > test "C", "C++"
The programming language is C
The programming language is C++
 => nil 
3.0.0 :030 > test
The programming language is Ruby
The programming language is Perl
 => nil 

# Ruby Return statement:
.0.0 :031 > def test
3.0.0 :032 >   i = 100
3.0.0 :033 >   j = 200
3.0.0 :034 >   k = 300
3.0.0 :035 >   return i,j,k
3.0.0 :036 > end
 => :test 
3.0.0 :037 > var = test
 => [100, 200, 300] 
3.0.0 :038 > puts var
100
200
300
 => nil 

# Class Methods:
3.0.0 :039 > class Accounts
3.0.0 :040 >    def reading_charge
3.0.0 :041 >    end
3.0.0 :042 >    def Accounts.return_date
3.0.0 :043 >    end
3.0.0 :044 > end
 => :return_date 
See how the method return_date is declared. It is declared with the class name followed by a period, which is followed by the name of the method.
To access this method, you need not create objects of the class Accounts.

# Ruby alias Statement
This gives alias to methods or global variables. Aliases cannot be defined within the method body. The alias of the method keeps the current definition of the method, even when methods are overridden.
Syntax-
alias method-name method-name
alias global-variable-name global-variable-name
Example-
alias foo bar
alias $MATCH $&
Here we have defined foo alias for bar, and $MATCH is an alias for $&

# Ruby undef Statement
This cancels the method definition. An undef cannot appear in the method body.
By using undef and alias, the interface of the class can be modified independently from the superclass, but notice it may be broke programs by the internal method call to self.
Syntax-
undef method-name

# Ruby - Blocks
Ruby defines methods where you can put number of statements and then you call that method. Similarly, Ruby has a concept of Block.
-A block consists of chunks of code.
-You assign a name to a block.
-The code in the block is always enclosed within braces ({}).
-A block is always invoked from a function with the same name as that of the block. This means that if you have a block with the name test, then you use the function test to invoke this block.
-You invoke a block by using the yield statement.
Syntax-
block_name {
   statement1
   statement2
   ..........
}

# The yield Statement:
Ex- 3.0.0 :051 > def test
3.0.0 :052 >   puts "You are in the method"
3.0.0 :053 >   yield
3.0.0 :054 >   puts "you are again back to the method"
3.0.0 :055 >   yield
3.0.0 :056 > end
 => :test 
3.0.0 :057 > test{puts "You are in the block"}
You are in the method
You are in the block
you are again back to the method
You are in the block
 => nil 

Ex-3.0.0 :058 > def test
3.0.0 :059 >   yield 5
3.0.0 :060 >   puts "You are in the method test"
3.0.0 :061 >   yield 50
3.0.0 :062 > end
 => :test 
3.0.0 :063 > test{|i| puts "You are in the block #{i}"}
You are in the block 5
You are in the method test
You are in the block 50
 => nil 
Here, the yield statement is written followed by parameters. You can even pass more than one parameter. In the block, you place a variable between two vertical lines (||) to accept the parameters. Therefore, in the preceding code, the yield 5 statement passes the value 5 as a parameter to the test block.

-If you want to pass more than one parameters, then the yield statement becomes −
yield a, b
and the block is −
test {|a, b| statement}

# Blocks and Methods:
You normally invoke a block by using the yield statement from a method that has the same name as that of the block.

Ex- 3.0.0 :069 > def test
3.0.0 :070 >   yield
3.0.0 :071 > end
 => :test 
3.0.0 :072 > test{puts"hello world"}
hello world
 => nil 
 
-But if the last argument of a method is preceded by &, then you can pass a block to this method and this block will be assigned to the last parameter. In case both * and & are present in the argument list, & should come later.
3.0.0 :001 > def test(&block)
3.0.0 :002 >   block.call
3.0.0 :003 > end
 => :test 
3.0.0 :004 > test {puts "Hello"}
Hello
 => nil 

# Begin and End blocks:
BEGIN { 
   # BEGIN block code 
   puts "BEGIN code block"
} 

END { 
   # END block code 
   puts "END code block"
}
   # MAIN block code 
puts "MAIN code block"

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
BEGIN code block
MAIN code block
END code block

# Ruby - Modules:
Modules are a way of grouping together methods, classes, and constants. Modules give you two major benefits.
Modules provide a namespace and prevent name clashes.
Modules implement the mixin facility.
Modules define a namespace, a sandbox in which your methods and constants can play without having to worry about being stepped on by other methods and constant.

Syntax
module Identifier
   statement1
   statement2
   ...........
end
Like class methods, whenever you define a method in a module, you specify the module name followed by a dot and then the method name.

3.0.0 :001 > module Trig
3.0.0 :002 >   PI = 3.14159
3.0.0 :003 >   def Trig.sin(x)
3.0.0 :004 >   end
3.0.0 :005 >   def Trig.cos(x)
3.0.0 :006 >   end
3.0.0 :007 > end
 => :cos 

3.0.0 :009 > module Moral
3.0.0 :010 >    VERY_BAD = 0
3.0.0 :011 >    BAD = 1
3.0.0 :012 >    def Moral.sin(badness)
3.0.0 :013 >    # ...
3.0.0 :014 >    end
3.0.0 :015 > end
 => :sin 

# Ruby require Statement
The require statement is similar to the include statement of C and C++ and the import statement of Java. If a third program wants to use any defined module, it can simply load the module files using the Ruby require statement −
Syntax:
require filename

# Ruby include Statement
You can embed a module in a class. To embed a module in a class, you use the include statement in the class −
Syntax:
include modulename

If a module is defined in a separate file, then it is required to include that file using require statement before embedding module in a class.

module Week
   FIRST_DAY = "Sunday"
   def Week.weeks_in_month
      puts "You have four weeks in a month"
   end
   def Week.weeks_in_year
      puts "You have 52 weeks in a year"
   end
end
 
$LOAD_PATH << '.'
require "support"

class Decade
include Week
   no_of_yrs = 10
   def no_of_months
      puts Week::FIRST_DAY
      number = 10*12
      puts number
   end
end
d1 = Decade.new
puts Week::FIRST_DAY
Week.weeks_in_month
Week.weeks_in_year
d1.no_of_months
These above mention two codes are being put and called in the file.
 
In this we have save our required file in Ruby.rv file and then we have created a new file at same location with different name i.e New_file so that we can access required file from that New_file.
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby New_file.rb
Sunday
You have four weeks in a month
You have 52 weeks in a year
Sunday
120


# Mixins in Ruby:
Ruby does not support multiple inheritance directly but Ruby Modules have a unique feature called mixins to support multiple inheritance.

module A
   def a1
   end
   def a2
   end
end
module B
   def b1
   end
   def b2
   end
end

class Sample
include A
include B
   def s1
   end
end

samp = Sample.new
samp.a1
samp.a2
samp.b1
samp.b2
samp.s1

Module A consists of the methods a1 and a2. Module B consists of the methods b1 and b2. The class Sample includes both modules A and B. The class Sample can access all four methods, namely, a1, a2, b1, and b2. Therefore, you can see that the class Sample inherits from both the modules. Thus, you can say the class Sample shows multiple inheritance or a mixin.

Example:
3.0.0 :005 > module Child1
3.0.0 :006 >   def a1
3.0.0 :007 >     puts"This is a child one."
3.0.0 :008 >   end
3.0.0 :009 > end
 => :a1 
3.0.0 :010 > module Child2
3.0.0 :011 >   def a2
3.0.0 :012 >     puts"This is a child two"
3.0.0 :013 >   end
3.0.0 :014 > end
 => :a2 
3.0.0 :015 > module Child3
3.0.0 :016 >   def a3
3.0.0 :017 >     puts"This is a child three"
3.0.0 :018 >   end
3.0.0 :019 > end
 => :a3 
3.0.0 :020 > class Parent
3.0.0 :021 > include Child1
3.0.0 :022 > include Child2
3.0.0 :023 > include Child3
3.0.0 :020 >  def display
3.0.0 :021 >    puts"Three modules have included"
3.0.0 :022 >  end
3.0.0 :023 > end
 => :display 
3.0.0 :024 > object = Parent.new
 => #<Parent:0x0000560459b0e038> 
3.0.0 :025 > object.display
Three modules have included
 => nil 
3.0.0 :026 > object.a1
This is a child one
 => nil 
3.0.0 :027 > object.a2
This is a child two
 => nil 
3.0.0 :028 > object.a3
This is a child three
 => nil 

# Defining CALCULATE modules which consists of some methods for arithmetic operations.
module CALCULATE
def add(a,b)
puts "The sum of two number is #{a+b}"
end
def multi(a,b)
puts "The multiplication of two number is #{a*b}"
end
def div(a,b)
puts "The division of two number is #{a/b}"
end
defsubstract(a,b)
puts "The subtraction of two number is #{a-b}"
end
end
# Defining a main class method and inside the method we are simply including all the three modules which we have defined above.
class USECALCULATION
include CALCULATE
defdisplay_output
puts 'This is inside the USECALCULATION and method CALCULATE'
end
end
# Creating object
mainObject = USECALCULATION.new
# Calling methods
mainObject.display_output
mainObject.add(1,3)
mainObject.multi(2,4)
mainObject.div(2,4)
mainObject.substract(2,4)

3.0.0 :059 >   def add(a,b)
3.0.0 :061 >   end
3.0.0 :062 >   def mul(a,b)
3.0.0 :064 >   end
3.0.0 :065 >   def div(a,b)
3.0.0 :067 >   end
3.0.0 :068 >   def sub(a,b)
3.0.0 :070 >   end
3.0.0 :071 > end
3.0.0 :072 > class UseCalculation
3.0.0 :073 >   include Calculate
3.0.0 :075 >     puts"This is inside the UseCalculation and method Calculate"
3.0.0 :076 >   end
3.0.0 :077 > end
 => :display_output 
3.0.0 :078 > mainObject = UseCalculation.new
 => #<UseCalculation:0x000056045a10a9a0> 
3.0.0 :079 > mainObject.display_output
This is inside the UseCalculation and method Calculate
 => nil 
3.0.0 :080 > mainObject.add(1,3)
The sum of two number is 4
 => nil 
3.0.0 :081 > mainObject.mul(1,3)
The product of two number is 3
 => nil 
3.0.0 :082 > mainObject.div(2,4)
The division of two number is 0
 => nil 
3.0.0 :083 > mainObject.div(4,2)
The division of two number is 2
 => nil 
3.0.0 :084 > mainObject.sub(4,2)
The subtraction of two number is 2
 => nil 
------------------------------------------------------------------------------------------------------------------------------------

# Strings:
In Ruby, string is a sequence of one or more characters. It may consist of numbers, letters, or symbols. Here strings are the objects, and apart from other languages, strings are mutable, i.e. strings can be changed in place instead of creating new strings.
Creating Strings: To create the string, just put the sequence of characters either in double quotes or single quotes. Also, the user can store the string into some variable. In Ruby, there is no need to specify the data type of the variable.

3.0.0 :001 > puts'Ruby string using single quotes'
Ruby string using single quotes
 => nil 
3.0.0 :002 > puts"Ruby string using double quotes"
Ruby string using double quotes
 => nil 
3.0.0 :003 > str1 = 'Hello'
 => "Hello" 
3.0.0 :004 > str2 = "Hello! How are you?"
 => "Hello! How are you?" 

Strings are objects: As you know that Ruby is an object-oriented language so string in Ruby are objects.
3.0.0 :005 > str = "GeeksforGeeks"
 => "GeeksforGeeks" 
3.0.0 :006 > puts str
GeeksforGeeks
 => nil 
3.0.0 :007 > str2 = String.new"GeeksForGeeks"
 => "GeeksForGeeks" 
3.0.0 :008 > puts str2
GeeksForGeeks
 => nil 
 
Access String Elements: User can access the string elements by using the square brackets []. In square brackets [], the user can pass the strings, ranges or indexes.
Syntax:
name_of_string_variable[arguments]

# storing string in variable
3.0.0 :009 > str = "Hello Learning Ruby"
 => "Hello Learning Ruby" 
# accessing the specified substring
3.0.0 :010 > puts str["Hello"]
Hello
 => nil 
3.0.0 :011 > puts str['Ruby']
Ruby
 => nil 
# passing index as an argument which returns 
# the  specified character
3.0.0 :012 > puts str[3]
l
 => nil 
# passing the negative index as an argument which 
# returns the specified character from the
# last of the string 
3.0.0 :013 > puts str[-2]
b
 => nil 
 
3.0.0 :014 > puts str[14,10]
 Ruby
 => nil 
# passing Two arguments which are separated 
# by a comma that returns characters starting
# from the 1st index and the 2nd index is the
# number of characters
3.0.0 :015 > puts str[14..10]
 => nil 
# using range operators in passed arguments
3.0.0 :016 > puts str[10..12]
nin
 => nil 

#Creating Multiline Strings: 
There are three ways to create multiline strings in Ruby as follows:

1.Using Double Quotes(“”) It is the simplest way to create the multiline strings by just putting the string between the quotes. Between double quotes, the user can add the newline character and so on.
2.Using (%/ /) To create the multiline string just put the string between the %/ and /.
3.Using (<< STRING STRING) To create the multiline string just put the string between the << STRING and STRING. Here STRING should be in capital letters.

# Using Double Quotes
3.0.0 :017"> puts "In Ruby, a user can create the multiline
3.0.0 :018">       strings easily where in other programming 
3.0.0 :019">       languages creating multiline strings 
3.0.0 :020">       requires a lot of efforts"
In Ruby, a user can create the multiline
      strings easily where in other programming 
      languages creating multiline strings 
      requires a lot of efforts
 => nil 
 

# Using %/ /
3.0.0 :023"> puts %/ In Ruby, a user can create the multiline
3.0.0 :024">       strings easily where into other programming 
3.0.0 :025">       languages creating multiline strings 
3.0.0 :026">       requires a lot of efforts/
 In Ruby, a user can create the multiline
      strings easily where into other programming 
      languages creating multiline strings 
      requires a lot of efforts
 => nil 


# Using <<STRING STRING
3.0.0 :001"> puts <<STRING
3.0.0 :002">   
3.0.0 :003"> In Ruby, a user can create the multiline
3.0.0 :004"> strings easily where into other programming 
3.0.0 :005"> languages creating multiline strings 
3.0.0 :006"> requires a lot of efforts 
3.0.0 :007 > STRING
  
In Ruby, a user can create the multiline
strings easily where into other programming 
languages creating multiline strings 
requires a lot of efforts 
 => nil 


# String Replication:
To make the replication of string in Ruby, make the use of (*) operator. 
This operator is preceded by the string to be replicated and followed by the number of times to make replicas.
Syntax:
string_variable_or_string * number_of_times

3.0.0 :008'> str = 'Hello Ruby\n'
 => "Hello Ruby\\n" 
3.0.0 :009 > puts str*5
Hello Ruby\nHello Ruby\nHello Ruby\nHello Ruby\nHello Ruby\n
 => nil 
3.0.0 :010 > str = "Hello Ruby \n"
 => "Hello Ruby \n" 
3.0.0 :011 > puts str*6
Hello Ruby 
Hello Ruby 
Hello Ruby 
Hello Ruby 
Hello Ruby 
Hello Ruby 
 => nil 

# String concat Method:
-concat is a String class method in Ruby which is used to Concatenates two objects of String.
3.0.0 :012 > str = "Hello"
 => "Hello" 
3.0.0 :013 > str.concat("Welcome!")
 => "HelloWelcome!" 

3.0.0 :015 > str = "Hello!"
 => "Hello!" 
3.0.0 :016 > str.concat("Learn Ruby",20)
 => "Hello!Learn Ruby\u0014" 
3.0.0 :017 > str.concat("Learn Ruby",33)
 => "Hello!Learn Ruby\u0014Learn Ruby!"
 
# String length Method:
Syntax: str.length
Parameters: Here, str is the string whose length is to be calculated
Returns:It will return the charac3.0.0 :040 > puts "Sample".index('m')
2
 => nil 
3.0.0 :041 > puts "Program".index('gr')
3
 => nil 
3.0.0 :042 > puts "Checking".index('a')

 => nil 
ter length of the str.
3.0.0 :018 > puts"Welcome to Ruby".length
15
 => nil 

# String split() Method:
split is a String class method in Ruby which is used to split the given string into an array of substrings based on a pattern specified.
Syntax:
arr = str.split(pattern, limit) public
Parameters: arr is the list, str is the string, pattern is the either string or regExp, and limit is the maximum entries into the array.
Returns: Array of strings based on the parameters.

3.0.0 :019 > myArray = "Geeks for Geeks".split
 => ["Geeks", "for", "Geeks"] 
3.0.0 :020 > puts myArray
Geeks
for
Geeks
 => nil 
 
.0.0 :021 > myArray = "Geeks for Geeks".split('s',-1)
 => ["Geek", " for Geek", ""] 
3.0.0 :022 > puts myArray
Geek
 for Geek

 => nil 

# String Capitalize:
Capitalize first letter of a string.
3.0.0 :024 > "hello".capitalize
=> "Hello"

# String Capitalize!:
-Modifies string by converting the first character to uppercase and the reamainder to lowercase.
-Returns nil if no changes are made.
3.0.0 :025 > "hello".capitalize!
 => "Hello" 

# String Upcase:
-Converts string to uppercase.
3.0.0 :026 > "Learning Ruby".upcase
 => "LEARNING RUBY" 

# String Downcase:
-Converts string to lowercase.
3.0.0 :027 > "Learning Ruby".downcase
 => "learning ruby"

# Array slice() function:
Array#slice() : slice() is a Array class method which returns a subarray specified by range of indices.
Syntax: 
Array.slice()
Parameter: Array
Return: a subarray specified by range of indices.

3.0.0 :028 > a = [18,22,33,nil,5,6]
 => [18, 22, 33, nil, 5, 6] 
3.0.0 :029 > b = [1,4,1,1,88,9]
 => [1, 4, 1, 1, 88, 9] 
3.0.0 :030 > c = [18,22,50,6]
 => [18, 22, 50, 6] 
3.0.0 :031"> puts"slice() method form: #{a.slice(2,4)}\n\n"
slice() method form: [33, nil, 5, 6]
 => nil 
3.0.0 :032 > puts"slice() method form: #{b.slice(1,3)}\n\n"
slice() method form: [4, 1, 1]
 => nil 
3.0.0 :033 > puts"slice() method form: #{c.slice(2,3)}\n\n"
slice() method form: [50, 6]
 => nil 


3.0.0 :034 > a = ["abc","nil","dog"]
 => ["abc", "nil", "dog"] 
3.0.0 :035 > b = ["cat","nil"]
 => ["cat", "nil"] 
3.0.0 :036 > c = ["cow","nil","dog"]
 => ["cow", "nil", "dog"] 
3.0.0 :037 > puts"slice() method form: #{a.slice(1,3)}\n\n"
slice() method form: ["nil", "dog"]

 => nil 
3.0.0 :038 > puts"slice() method form: #{b.slice(1,2)}\n\n"
slice() method form: ["nil"]

 => nil 
3.0.0 :039 > puts"slice() method form: #{c.slice(0)}\n\n"
slice() method form: cow
 => nil 


# String index Method:
index is a String class method in Ruby which is used to returns the index of the first occurrence of the given substring or pattern (regexp) in the given string. It specifies the position in the string to begin the search if the second parameter is present. It will return nil if not found.
Syntax: str.index()
Parameters: Here, str is the given string.
Returns: Index of the first occurrence of the given substring or pattern (regexp) in str.

3.0.0 :040 > puts "Sample".index('m')
2
 => nil 
3.0.0 :041 > puts "Program".index('gr')
3
 => nil 
3.0.0 :042 > puts "Checking".index('a')

 => nil 


# Get the count of characters of a String:
The str.count takes one or more sets of characters as parameters.
3.0.0 :043 > puts "Looking".count('o')
2
 => nil 

# Reverse a String:
3.0.0 :044 > str = 'Mahima'
 => "Mahima" 
3.0.0 :045 > str.reverse
 => "amihaM" 
 
# Search for one or more characters of a String:
The str.include? returns true if the String or character present and false if it is not.
3.0.0 :046 > "heLLo wOrld".include?("w")
 => true 
3.0.0 :047 > "heLLo wOrld".include?("W")
 => false 

# Replace characters in a String
The str.gsub or global substitute replaces all occurrences with provided Strings. Here the first argument represents the characters set we want to substitute, and the second argument is the replacement characters set.
3.0.0 :048 > "Red, Red and Blue".gsub("Red", "Orange")
 => "Orange, Orange and Blue"
 
If you want to replace the first occurrence, use the str.sub.
3.0.0 :049 > "Red, Red and Blue".sub("Red", "Orange") 
 => "Orange, Red and Blue" 
 
# Split a String
3.0.0 :051 > words = sentence.split
 => ["There", "Is", "No", "Spoon"] 

You can limit the number of splits by providing the second argument.
3.0.0 :052 > sentence = "June 27,June 26,June 25"
 => "June 27,June 26,June 25" 
3.0.0 :053 > words = sentence.split(/,/, 2)
 => ["June 27", "June 26,June 25"] 


# Trim a String
The str.trim will remove any of the following leading and trailing characters: null("\x00"), horizontal tab("\t"), line feed(\n), vertical tab("\v"), form feed(f), carriage return(\r), space(" ").

--> Strip!:
Removes whitespaces from the reciever.Returns the altered reciever, or nil if there was no change.
3.0.0 :055 > "   hEllo   ".strip! 
 => "hEllo" 

# casecmp(other_str):
-1,0,1 or nil.

-1: if other_string is smaller.
0: if the two are equal.
1: if other_str is larger.
nil: if the two are incompatible.
 
3.0.0 :056 > 'foo'.casecmp('foo')
 => 0 
3.0.0 :057 > 'foo'.casecmp('food')
 => -1 
3.0.0 :058 > 'food'.casecmp('foo')
 => 1 
3.0.0 :059 > 'foo'.casecmp('FOO')
 => 0 
3.0.0 :060 > 'foo'.casecmp(1)
 => nil 

# casecmp?(other_str):
true,false or nil
Returns true if self and other_str are equal after Unicode case folding,otherwise false:

3.0.0 :061 > 'foo'.casecmp?('foo')
 => true 
3.0.0 :062 > 'foo'.casecmp?('food')
 => false 
3.0.0 :063 > 'food'.casecmp?('foo')
 => false 
3.0.0 :064 > 'foo'.casecmp?('FOO')
 => true 


# center(width,padstr='')-> new_str:
Centers str in width. If width is greater than the length of str,returns a new string of length width with str centered and padded with padstr;otherwise,returns str.
3.0.0 :065 > "hello".center(4)
 => "hello" 
3.0.0 :066 > "hello".center(14)
 => "    hello     " 
3.0.0 :067 > "hello".center(14,'40')
 => "4040hello40404"
 
# String chomp Method
chomp is a predefined method in Ruby's library which is used to eliminate implicit newline character '\n' attached with the string entered by the user during run time.
chomp is a String class method in Ruby which is used to returns new String with the given record separator removed from the end of str (if present). chomp method will also remove carriage return characters (that is it will remove \n, \r, and \r\n) if $/ has not been changed from the default Ruby record separator, t. If $/ is an empty string, it will remove all trailing newlines from the string.

Syntax: str.chomp
Parameters: Here, str is the given string.
Returns: A new string having no record separator from the end.

3.0.0 :068 > puts"Ruby\n".chomp
Ruby
 => nil 
3.0.0 :069"> puts"Ruby\n\r".chomp
Ruby
 => nil 
3.0.0 :070"> puts"Ruby\r\n".chomp
Ruby
 => nil 

3.0.0 :071 > puts"Ruby\r\n\r\n\n".chomp
Ruby

 => nil 
3.0.0 :072 > puts"Method".chomp("tho")
Method
 => nil 
 
# String chomp! Method:
Syntax: str.chomp!
Parameters: Here, str is the given string.
Returns: A new string having no record separator from the end or nil if no changes were made

3.0.0 :073 > puts"Ruby".chomp!

 => nil 
3.0.0 :074 > puts"Ruby\n".chomp!
Ruby
 => nil 
3.0.0 :075"> puts"Ruby\n\r".chomp!
Ruby
 => nil 
3.0.0 :076 > puts"String\r\n\r\n\n".chomp!
String

 => nil 
3.0.0 :077'> puts"String\r\n\r\n\n".chomp!('')
String
 => nil 
3.0.0 :078 > puts"Method".chomp!("tho")

 => nil 
 

# String chop Method:
chop is a String class method in Ruby which is used to return a new String with the last character removed. Both characters are removed if the string ends with \r\n, b. Applying chop to an empty string returns an empty string.
 

Syntax:str.chop
Parameters: Here, str is the given string.
Returns: A new string having no record separator. 

3.0.0 :079 > puts"Ruby".chop
Rub
 => nil 
3.0.0 :080 > puts"Ruby\r\n".chop
Ruby
 => nil 

3.0.0 :082 > puts"String\r\n\r\n\r\n".chop
String

 => nil 
3.0.0 :083 > puts"Method".chop.chop
Meth
 => nil 

# String Prepend:
Adds a string before another string.
Append one or more characters to a String at the beginning of a String.

3.0.0 :084 > a = "world"
 => "world" 
3.0.0 :085 > a.prepend("Hello")
 => "Helloworld" 
 
3.0.0 :086 > a = "to the Ruby"
 => "to the Ruby" 
3.0.0 :087 > a.prepend("Welcome")
 => "Welcometo the Ruby" 
 
# String Insert:
Insert a String.Add one or more characters to a specific position of a String.

3.0.0 :089 > a.insert(a.length,"world")
 => "helloworld" 
3.0.0 :090 > 'foo'.insert(1,'bar')
 => "fbaroo" 
3.0.0 :091 > 'How'.insert(2,'Are you')
 => "HoAre youw"
 
# String Replace:
Replaces the content of old string with the new.
3.0.0 :092 > s = "Hello"
 => "Hello" 
3.0.0 :093 > s.replace"Ruby"
 => "Ruby" 
3.0.0 :094 > s
 => "Ruby" 
 
# String Delete:
Deletes the string at given index.

3.0.0 :097 > "Welcome".delete"l"
 => "Wecome" 
3.0.0 :099 > "Welcome".delete"o"
 => "Welcme" 
 
# String delete_prefix(prefix)-> new_str:
3.0.0 :100 > "Hello".delete_prefix("He")
 => "llo" 

# String delete_prefix!-> self or nil
Deletes leading prefix from str, returning nil if no changes made.
3.0.0 :102 > "Learning".delete_prefix!("ear")
 => nil 
3.0.0 :103 > "Learning".delete_prefix!("Lea")
 => "rning" 
 
# String delete_suffix(suffix)-> new_str:
Returns a copy of str with suffix deleted.
3.0.0 :105 > "hello".delete_suffix("lo")
 => "hel" 
3.0.0 :106 > "hello".delete_suffix("llo")
 => "he" 
 
# String delete_suffix!-> self or nil:
Deletes suffix from str, returning nil if no change was made.

3.0.0 :107 > "hello".delete_suffix!("llo")
 => "he" 
3.0.0 :108 > "hello".delete_suffix!("hel")
 => nil 

# String starts_with?:
We can check if a string starts with a string.

3.0.0 :109 > str = "Mr. Raman"
 => "Mr. Raman" 
3.0.0 :110 > str.start_with?("Mr")
 => true 
3.0.0 :111 > str.start_with?("Mr.")
 => true 
3.0.0 :112 > str.start_with?("Ram")
 => false 

# String ends_with?:
We can check if a string ends with a string.

3.0.0 :113 > str = "This is a dog."
 => "This is a dog." 
3.0.0 :114 > str.end_with?(".")
 => true 
3.0.0 :115 > str.end_with?("dog")
 => false 
3.0.0 :116 > str.end_with?("dog.")
 => true 
 
# String Partition:
Searches sep or pattern in the string and returns the part beforeit, the match and the part after it.
If it is not found,returns two empty strings.

3.0.0 :117 > "Hello".partition("l")
 => ["He", "l", "lo"] 
3.0.0 :118 > "Hello".partition("x")
 => ["Hello", "", ""] 
3.0.0 :119 > "Hello".partition("/.l/")
 => ["Hello", "", ""] 
 
# String Empty?:
Returns true if the length of self is zero, false otherwise.

3.0.0 :120 > "Hello".empty?
 => false 
3.0.0 :121 > "".empty?
 => true 

# String bytes:
Returns an array of bytes in str.
Syntax: str.bytes
Parameters: Here, str is the specified string.
Returns: An array of bytes.

3.0.0 :001 > "hello".bytesize
 => 5 
3.0.0 :002 > "\x80\djbvjfd".bytesize
 => 8 

3.0.0 :003 > puts"ABCD".bytes
65
66
67
68
 => nil 

3.0.0 :004 > "hello".byteslice(1)
 => "e" 
3.0.0 :005 > "hello".byteslice(-1)
 => "o" 
3.0.0 :006 > "hello".byteslice(1,2)
 => "el" 

# String chr:
Returns a one-charcater string at the beginning of the string.
3.0.0 :007 > a = "abcde"
 => "abcde" 
3.0.0 :008 > a.chr
 => "a" 
3.0.0 :009 > a.clear
 => "" 
3.0.0 :010 > a = "Learning"
 => "Learning" 
3.0.0 :011 > a.chr
 => "L" 

# Clear -> String
Makes string empty.
3.0.0 :007 > a = "abcde"
 => "abcde" 
3.0.0 :008 > a.chr
 => "a" 
3.0.0 :009 > a.clear
 => "" 
3.0.0 :010 > a = "Learning"
 => "Learning" 
3.0.0 :011 > a.chr
 => "L" 
--------------------------------------------------------------------------------------------------------------------------------------------

# Iterators:
-The word iterate means doing one thing multiple times and that is what iterators do. -Sometimes iterators are termed as the custom loops. 
-Iterators is the object-oriented concept in Ruby.
-Iterators are the methods which are supported by collections(Arrays, Hashes etc.). Collections are the objects which store a group of data members.
-Ruby iterators return all the elements of a collection one after another.
-Ruby iterators are “chainable” i.e adding functionality on top of each other.

There are many iterators in Ruby as follows: 
1.Each Iterator
2.Collect Iterator
3.Times Iterator
4.Upto Iterator
5.Downto Iterator
6.Step Iterator
7.Each_Line Iterator

--> Each Iterator: This iterator returns all the elements of an array or a hash. Each iterator returns each value one by one. 
Syntax: 
 collection.each do |variable_name|
   # code to be iterate
end

3.0.0 :024 > (0..9).each do |i|
3.0.0 :025 >   puts i
3.0.0 :026 > end
0
1
2
3
4
5
6
7
8
9
 => 0..9 

3.0.0 :027 > a = ['M','A','H','I','M','A']
 => ["M", "A", "H", "I", "M", "A"] 
3.0.0 :028 > a.each do|a|
3.0.0 :029 >   puts a
3.0.0 :030 > end
M
A
H
I
M
A
 => ["M", "A", "H", "I", "M", "A"] 
 
 
--> Collect Iterator: This iterator returns all the elements of a collection. The collect iterator returns an entire collection, regardless of whether it is an array or hash.
The collect method need not always be associated with a block.
Syntax: 
Collection = collection.collect

3.0.0 :034 > a = [1,2,3,4,5,6,7,8,9,10]
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
3.0.0 :035 > b = a.collect{|y| (5 * y)}
 => [5, 10, 15, 20, 25, 30, 35, 40, 45, 50] 
3.0.0 :036 > puts b
5
10
15
20
25
30
35
40
45
50
 => nil 


--> Times Iterator: In this iterator, a loop is specified with number of time. The loop is initially started from zero and runs until the one less than the specified number.
We can add an iteration variable by using the vertical bars around the identifier. 
Syntax:
t.times do |variable_name|  # t is the specified number which is used to define number of iteration.
# code to be execute
end

3.0.0 :037 > 7.times do|i|
3.0.0 :038 >   puts i
3.0.0 :039 > end
0
1
2
3
4
5
6
 => 7 


--> Upto Iterator: This iterator follows top to bottom approach. It includes both the top and bottom variable in the iteration. 
Syntax:  
top.upto(bottom) do |variable_name|
# code to execute
end

NOTE: Point to remember that the value of bottom variable is always greater than the top variable and if it is not, then it will return nothing.

3.0.0 :040 > 4.upto(7) do |n|
3.0.0 :041 >   puts n
3.0.0 :042 > end
4
5
6
7
 => 4 
3.0.0 :043 > 7.upto(4) do |n|
3.0.0 :044 >   puts n
3.0.0 :045 > end
 => 7 
 
 
--> Downto Iterator: This iterator follows bottom to top approach. It includes both the top and bottom variable in the iteration. 
Syntax: 
top.downto(bottom) do |variable_name|
# code to execute
end
NOTE: Point to remember that the value of bottom variable is always smaller than the top variable and if it is not, then it will return nothing.

3.0.0 :046 > 7.downto(3) do |n|
3.0.0 :047 >   puts n
3.0.0 :048 > end
7
6
5
4
3
 => 7 
3.0.0 :049 > 4.downto(7) do |n|
3.0.0 :050 >   puts n
3.0.0 :051 > end
 => 4 


--> Step Iterator: Ruby step iterator is used to iterate where the user has to skip a specified range. 
Syntax: 
Collection.step(rng) do |variable_name|
# code to be executed
end 

3.0.0 :055 > (0..50).step(5) do|i|
3.0.0 :056 >   puts i
3.0.0 :057 > end
0
5
10
15
20
25
30
35
40
45
50
 => 0..50 

3.0.0 :052 > (0..60).step(10) do|i|
3.0.0 :053 >   puts i
3.0.0 :054 > end
0
10
20
30
40
50
60
 => 0..60 
 

--> Each_line Iterator: Ruby each_line iterator is used to iterate over a new line in the string. 
Syntax:
string.each_line do |variable_name|
# code to be executed
end

3.0.0 :058 > "Welcome\nto\nRuby\nPortal".each_line do|i|
3.0.0 :059 >   puts i
3.0.0 :060 > end
Welcome
to
Ruby
Portal
 => "Welcome\nto\nRuby\nPortal" 
--------------------------------------------------------------------------------------------------------------------------------------------

# Arrays:
Arrays are ordered, integer-indexed collections of any object.
Array indexing starts at 0.
In general, an array is created by listing the elements which will be separated by commas and enclosed between the square brackets[]. 
Negative indices start counting from the end, with -1 being the last element.

There are several ways to create an array. But there are two ways which mostly used are as follows: 
1.Using the new class method: new is a method which can be used to create the arrays with the help of dot operator.
Syntax:
name_of_array= Array.new

# creating array using new method
# without passing any parameter
arr = Array.new()
 
# creating array using new method
# passing one parameter i.e. the
# size of array
arr2 = Array.new(7)
 
# creating array using new method
# passing two parameters i.e. the
# size of array & element of array
arr3 = Array.new(4, "GFG")
 
# displaying the size of arrays
# using size and length method
puts arr.size
puts arr2.length
puts arr3.size
 
# displaying array elements
puts "#{arr3}"

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm_Ruby$ irb
3.0.0 :001 > arr = Array.new()
 => [] 
3.0.0 :002 > arr2 = Array.new(7)
 => [nil, nil, nil, nil, nil, nil, nil] 
3.0.0 :003 > arr3 = Array.new(4, "Learning Arrays")
 => ["Learning Arrays", "Learning Arrays", "Learning Arrays", "Learning Ar... 
3.0.0 :004 > puts arr.size
0
 => nil 
3.0.0 :005 > puts arr2.length
7
 => nil 
3.0.0 :006 > puts arr3.size
4
 => nil 
3.0.0 :007 > puts arr3
Learning Arrays
Learning Arrays
Learning Arrays
Learning Arrays
 => nil 

2.Using literal constructor[] In Ruby, [] is known as the literal constructor which can be used to create the arrays. Between [], different or similar type values can be assigned to an array:

3.0.0 :008 > arr = Array['a','b','Hello','hi',2,3]
 => ["a", "b", "Hello", "hi", 2, 3] 
3.0.0 :009 > puts "#{arr}"
["a", "b", "Hello", "hi", 2, 3]
 => nil 
3.0.0 :010 > puts "Size of arr is: #{arr.size}"
Size of arr is: 6
 => nil 
3.0.0 :011 > puts "Length of arr is: #{arr.length}"
Length of arr is: 6
 => nil 
 
# Retrieving Or Accessing Elements from Array:
In Ruby, there are several ways to retrieve the elements from the array. Ruby arrays provide a lot of different methods to access the array element. But the most used way is to use the index of an array.

3.0.0 :015 > arr =['a','b','Hello','hi',2,3,"Ruby"]
 => ["a", "b", "Hello", "hi", 2, 3, "Ruby"] 
3.0.0 :016 > puts arr[2]
Hello
 => nil 
3.0.0 :017 > puts arr[5]
3
 => nil 
3.0.0 :018 > puts arr[-2]
3
 => nil 

# Retrieving Multiple Elements from Array: There can be many situations where the user need to access the multiple elements from the array. So to access the multiple elements, pass the two specified array index into the [].

=> ["a", "b", "Hello", "hi", 2, 3, "Ruby"] 
3.0.0 :016 > puts arr[2]
Hello
 => nil 
3.0.0 :017 > puts arr[5]
3
 => nil 
3.0.0 :018 > puts arr[-2]
3
 => nil 
3.0.0 :019 > puts arr[3,4]
hi
2
3
Ruby
 => nil 
3.0.0 :020 > puts arr[2,3]
Hello
hi
2
 => nil 
3.0.0 :021 > puts arr[9]

 => nil 
3.0.0 :022 > arr[1..3]
 => ["b", "Hello", "hi"] 

Note: Another way to access a particular array element is by using the at method.
3.0.0 :023 > arr.at(2)
 => "Hello" 

## The special methods first and last will return the first and last elements of an array, respectively.
3.0.0 :024 > arr.first
 => "a" 
3.0.0 :025 > arr.last
 => "Ruby" 

## To return the first n elements of an array, use take:
3.0.0 :026 > arr.take(4)
 => ["a", "b", "Hello", "hi"] 

## drop does the opposite of take, by returning the elements after n elements have been dropped:
3.0.0 :028 > arr = [1,2,3,4,5,6,7,8]
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.0.0 :029 > arr.take(3)
 => [1, 2, 3] 
3.0.0 :030 > arr.drop(3)
 => [4, 5, 6, 7, 8] 

 ↑
# Arrays keep track of their own length at all times. To query an array about the number of elements it contains, use length, count or size.
3.0.0 :031 > browsers = ['Chrome','Firefox','Safari','Opera','IE']
 => ["Chrome", "Firefox", "Safari", "Opera", "IE"] 
3.0.0 :032 > browsers.length
 => 5 
3.0.0 :033 > browsers.count
 => 5 

# To check whether an array contains any elements at all:
3.0.0 :034 > browsers.empty?
 => false 

# To check whether a particular item is included in the array:
3.0.0 :035 > browsers.include?("Mini")
 => false 
3.0.0 :036

# Adding Items to Arrays:
Items can be added to the end of an array by using either push or <<.
3.0.0 :036 > arr = [1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.0.0 :037 > arr.push(6)
 => [1, 2, 3, 4, 5, 6] 
3.0.0 :038 > arr.push(7,8)
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.0.0 :039 > arr << 9
 => [1, 2, 3, 4, 5, 6, 7, 8, 9] 
 
# 'unshift' will add a new item to the beginning of an array.
3.0.0 :040 > arr.unshift(0)
 => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
3.0.0 :041 > arr.unshift("hi")
 => ["hi", 0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
3.0.0 :042 > arr.unshift(-1,-2)
 => [-1, -2, "hi", 0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 

# With insert you can add a new element to an array at any position.
Using the insert method, you can also insert multiple values at once.
arr = [-1, -2, "hi", 0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
3.0.0 :043 > arr.insert(3, 'Apple')
 => [-1, -2, "hi", "Apple", 0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
3.0.0 :044 > arr.insert(3, 'Apple','pear','grapes')
 => [-1, -2, "hi", "Apple", "pear", "grapes", "Apple", 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  

# Removing Items from an Array.
The method pop removes the last element in an array and returns it:
arr = [-1, -2, "hi", 0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
3.0.0 :045 > arr.pop
 => 9 

# To retrieve and at the same time remove the first item, use shift:
3.0.0 :046 > arr.shift
 => -1 
3.0.0 :047 > arr
 => [-2, "hi", "Apple", "pear", "grapes", "Apple", 0, 1, 2, 3, 4, 5, 6, 7, 8] 

# To delete an element at a particular index:
To delete a particular element anywhere in an array, use delete:
 => [-2, "hi", "Apple", "pear", "grapes", "Apple", 0, 1, 2, 3, 4, 5, 6, 7, 8] 
3.0.0 :048 > arr.delete(2)
 => 2 
3.0.0 :049 > arr
 => [-2, "hi", "Apple", "pear", "grapes", "Apple", 0, 1, 3, 4, 5, 6, 7, 8] 
3.0.0 :050 > arr.delete("hi")
 => "hi" 
3.0.0 :051 > arr
 => [-2, "Apple", "pear", "grapes", "Apple", 0, 1, 3, 4, 5, 6, 7, 8] 
3.0.0 :052 > arr.delete_at(0)
 => -2 
3.0.0 :053 > arr
 => ["Apple", "pear", "grapes", "Apple", 0, 1, 3, 4, 5, 6, 7, 8] 
3.0.0 :054 > 

# A useful method if you need to remove nil values from an array is compact:
3.0.0 :056 > arr.insert(3,nil,nil)
 => ["Apple", "pear", "grapes", nil, nil, "nil", "nil", "Apple", 0, 1, 3, 4, 5, 6, 7, 8] 
3.0.0 :057 > arr.compact
 => ["Apple", "pear", "grapes", "nil", "nil", "Apple", 0, 1, 3, 4, 5, 6, 7, 8] 

3.0.0 :064 > arr
 => ["Apple", "pear", "grapes", nil, nil, "nil", "nil", nil, nil, "Apple", 0, 1, 3, 4, 5, 6, 7, 8] 
3.0.0 :065 > arr.compact!
 => ["Apple", "pear", "grapes", "nil", "nil", "Apple", 0, 1, 3, 4, 5, 6, 7, 8] 

# Another common need is to remove duplicate elements from an arrayi.e uniq is used:
=> ["Apple", "pear", "grapes", "nil", "nil", "Apple", 0, 1, 3, 4, 5, 6, 7, 8] 
3.0.0 :066 > arr.uniq
 => ["Apple", "pear", "grapes", "nil", 0, 1, 3, 4, 5, 6, 7, 8] 


# Iterating over Arrays:
Each method is used for iterating over arrays.
3.0.0 :067 > arr = [1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.0.0 :068 > arr.each {|a| print a -= 10, " "}
-9 -8 -7 -6 -5  => [1, 2, 3, 4, 5] 

# reverse_each: used to reverse the order of array.
words = %w[first second third fourth fifth]
str = ''
words.reverse_each { |word| str += "#{word} "}
p str

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ r
uby Ruby.rb
"fifth fourth third second first "

# The map method can be used to create a new array based on the original array, but with the values modified by the supplied block: 
3.0.0 :067 > arr = [1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.0.0 :073 > arr.map {|a| 2*a}
 => [2, 4, 6, 8, 10] 
 
3.0.0 :067 > arr = [1,2,3,4,5]
3.0.0 :074 > arr.map {|a| 2**a}
=> [2, 4, 8, 16, 32] 

# Selecting Items from an Array:
select! and reject! are the corresponding destructive methods to select and reject.
drop_while can be used instead of reject.

3.0.0 :001 > arr = [1,2,3,4,5,6]
 => [1, 2, 3, 4, 5, 6] 
3.0.0 :002 > arr.drop_while { |a| a < 4 }
 => [4, 5, 6] 
3.0.0 :003 > arr.reject { |a| a < 4 }
 => [4, 5, 6] 
3.0.0 :004 > arr.select { |a| a < 3 }
 => [1, 2] 

# delete_if and keep_if:
3.0.0 :005 > arr.delete_if { |a| a < 4 }
 => [4, 5, 6] 
3.0.0 :006 > arr = [1,2,3,4,5,6]
 => [1, 2, 3, 4, 5, 6] 
3.0.0 :007 > arr.keep_if { |a| a < 4 }
 => [1, 2, 3] 



# Public Class Methods:
1. [](*args):
Returns a new array populated with the given objects.
3.0.0 :010 > Array.[](1,'a',/^A/)
 => [1, "a", /^A/] 
3.0.0 :011?> Array.[1,'a',/^A/]
3.0.0 :012?> (1,'a',/^A/]

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm_Ruby$ irb
3.0.0 :001 > First_array = ["Mahima","Tewatia"]
 => ["Mahima", "Tewatia"] 
3.0.0 :002 > Second_array = Array.new(First_array)
 => ["Mahima", "Tewatia"] 
3.0.0 :003 > First_array.equal? Second_array
 => false 

In the last form, an array of the given size is created. Each element in this array is created by passing the element's index to the given block and storing the return value.
3.0.0 :004 > Array.new(4) { |index| index**2 }
 => [0, 1, 4, 9] 
 
# try_convert:
Tries to convert obj into array using the 'to_ary' method. Returns converted array or nil if obj cannot be converted. 
This method can be used to check if an argument is an array.
3.0.0 :005 > Array.try_convert([1])
 => [1] 
3.0.0 :006 > Array.try_convert("1")
 => nil 


# Public Instance Methods:
-Set Intersection- ary & other_ary → new_ary
Returns a new array containing unique elements common to the two arrays.
3.0.0 :010 > [1,1,3,5] & [3,2,1,6]
 => [1, 3] 
3.0.0 :011'> ['a','b','c','d'] & ['a','b','c']
 => ["a", "b", "c"] 
 
Repetition: - ary * int → new_ary:
With string argument, equivalent to ary.join(str).
3.0.0 :012 > [1,2,3] * 3
 => [1, 2, 3, 1, 2, 3, 1, 2, 3] 
3.0.0 :013 > [1,2,3] * ","
 => "1,2,3" 
 
Concatenation — - ary + other_ary → new_ary
Returns a new array built by concatenating the two arrays together to produce a third array.
3.0.0 :014 > [1,2,3] + [4,5]
 => [1, 2, 3, 4, 5] 
3.0.0 :015 > a = ['a','b','c','d']
 => ["a", "b", "c", "d"] 
3.0.0 :016'> c = a + ['e','f','g']
 => ["a", "b", "c", "d", "e", "f", "g"] 
3.0.0 :017'> ['a','b','c','d'] + ['e','f']
 => ["a", "b", "c", "d", "e", "f"] 

- Array Difference: ary - other_ary → new_ary
Returns a new array that is a copy of the original array, removing all occurrences of any item that also appear in other_ary. The order is preserved from the original array.
3.0.0 :018 > [1,1,3,4,4,5,5,6] - [1,2,4]
 => [3, 5, 5, 6] 
NOTE: All repetetive occurrence of element are removed in final array.

-Append:ary << obj → ary
Pushes the given object on to the end of this array. This expression returns the array itself, so several appends may be chained together.
3.0.0 :019 > a = [1,2]
 => [1, 2] 
3.0.0 :020 > a << "c" << "hi" << "ruby"
 => [1, 2, "c", "hi", "ruby"] 

-Comparison: ary <=> other_ary → -1, 0, +1 or nil 
Returns an integer (-1, 0, or +1) if this array is less than, equal to, or greater than other_ary.
Each object in each array is compared (using the <=> operator).
the first element of ary is compared with the first one of other_ary using the <=> operator, then each of the second elements, etc…
nil is returned if the other_ary is not an array or if the comparison of two elements returned nil.
3.0.0 :001 > ['a','a','c'] <=> ['a','b','c']
 => -1 
3.0.0 :002 > [1,2,3,4,5,6] <=> [1,2]
 => 1 
3.0.0 :003 > [1,2] <=> [1,:two]
 => nil 

-Equality: ary == other_ary 
Two arrays are equal if they contain the same number of elements and if each element is equal to (according to Object#==) the corresponding element in other_ary.
3.0.0 :004 > ['a','c',6] == ['a','c']
 => false 
3.0.0 :005 > ['a','c',6] == ['a','c',7]
 => false 
3.0.0 :006 > ['a','c',6] == ['a','c',6]
 => true 
3.0.0 :007 > ['a','c',6] == ['a','c','f']
 => false 
 
Element Reference:
ary[index] → obj or nilclick to toggle source
ary[start, length] → new_ary or nil
ary[range] → new_ary or nil
slice(index) → obj or nil
slice(start, length) → new_ary or nil
slice(range) → new_ary or nil
Returns the element at index, or returns a subarray starting at the start index and continuing for length elements, or returns a subarray specified by range of indices.

Negative indices count backward from the end of the array (-1 is the last element). For start and range cases the starting index is just before an element. Additionally, an empty array is returned when the starting index for an element range is at the end of the array.

Returns nil if the index (or starting index) are out of range.

3.0.0 :008 > a = ['a','b','c','d','e','f']
 => ["a", "b", "c", "d", "e", "f"] 
3.0.0 :009 > a[2] + a[0] + a[1]
 => "cab" 
3.0.0 :010 > a[6]
 => nil 
3.0.0 :011 > a[1,2]
 => ["b", "c"] 
3.0.0 :012 > a[1..3]
 => ["b", "c", "d"] 
3.0.0 :013 > a[4..7]
 => ["e", "f"] 
3.0.0 :014 > a[7..10]
 => nil 
3.0.0 :015 > a[7]
 => nil 
3.0.0 :016 > a[4..7]
 => ["e", "f"] 
3.0.0 :017 > a[7,1]
 => nil 

# combination(n) {|c| block} → aryclick to toggle source
combination(n) → Enumerator
When invoked with a block, yields all combinations of length n of elements from the array and then returns the array itself.
The implementation makes no guarantees about the order in which the combinations are yielded.
If no block is given, an Enumerator is returned instead.

3.0.0 :018 > a = [1,2,3,4]
 => [1, 2, 3, 4] 
3.0.0 :019 > a.combination(1).to_a
 => [[1], [2], [3], [4]] 
3.0.0 :020 > a.combination(2).to_a
 => [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] 
3.0.0 :021 > a.combination(3).to_a
 => [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]] 
3.0.0 :022 > a.combination(4).to_a
 => [[1, 2, 3, 4]] 
3.0.0 :023 > a.combination(5).to_a
 => [] 
3.0.0 :024 > a.combination(0).to_a
 => [[]] 

# compact → new_ary
Returns a copy of self with all nil elements removed.
3.0.0 :025 > ['a',nil,'b',nil,'c',nil].compact
 => ["a", "b", "c"] 

# compact! → ary or nil
Removes nil elements from the array.
Returns nil if no changes were made, otherwise returns the array.
3.0.0 :026 > ['a',nil,'b',nil,'c',nil].compact!
 => ["a", "b", "c"] 
3.0.0 :027 > ['a','b','c'].compact!
 => nil 

# Count → int
Returns the number of elements.
count(obj) → int
If an argument is given, counts the number of elements which equal obj using ==.
count {|item| block} → int
If a block is given, counts the number of elements for which the block returns a true value.

3.0.0 :028 > arr = [1,2,3,4,2]
 => [1, 2, 3, 4, 2] 
3.0.0 :029 > arr.count
 => 5 
3.0.0 :030 > arr.count(3)
 => 1 
3.0.0 :031 > arr.count(2)
 => 2 
3.0.0 :032 > arr.count {|x| x % 2 == 0 }
 => 3 

# cycle(n=nil) {|obj| block} → nilclick to toggle source
Calls the given block for each element n times or forever if nil is given.
Does nothing if a non-positive number is given or the array is empty.

cycle(n=nil) → Enumerator
Returns nil if the loop has finished without getting interrupted.
If no block is given, an Enumerator is returned instead.
3.0.0 :033 > arr = ['a','b','c']
 => ["a", "b", "c"] 
3.0.0 :034 > a.cycle() { |x| puts x}
Will run infinity times.
3.0.0 :033 > arr = ['a','b','c']
 => ["a", "b", "c"] 
3.0.0 :034 > a.cycle(2) { |x| puts x}
1
2
3
4
1
2
3
4
 => nil 

# delete(obj) → item or nil
Deletes all items from self that are equal to obj.
Returns the last deleted item, or nil if no matching item is found.

delete(obj) {block} → item or result of block
If the optional code block is given, the result of the block is returned if the item is not found. (To remove nil elements and get an informative return value, use Array#compact!)

3.0.0 :035 > arr = ['a','b','c','b','c','b']
 => ["a", "b", "c", "b", "c", "b"] 
3.0.0 :036 > arr.delete('b')
 => "b" 
3.0.0 :037 > arr
 => ["a", "c", "c"] 
3.0.0 :038 > arr.delete('z')
 => nil 
3.0.0 :039 > arr.delete('z') {'not found'}
 => "not found"
 
# delete_at:
Deletes at a particular index.
3.0.0 :040 > arr.delete_at(2)
 => "c" 
 
# each {|item| block} → ary
Calls the given block once for each element in self, passing that element as a parameter. Returns the array itself.
each → Enumerator
If no block is given, an Enumerator is returned.
3.0.0 :041 > arr = ['a','b','c']
 => ["a", "b", "c"] 
3.0.0 :042 > a.each_index { |x| print x, " "}
0 1 2 3  => [1, 2, 3, 4] 

# fetch(index) → objclick to toggle source
fetch(index, default) → obj
Tries to return the element at position index, but throws an IndexError exception if the referenced index lies outside of the array bounds. This error can be prevented by supplying a second argument, which will act as a default value.

fetch(index) {|index| block} → obj
Alternatively, if a block is given it will only be executed when an invalid index is referenced.

Negative values of index count from the end of the array.

3.0.0 :043 > a = [11,22,33,44]
 => [11, 22, 33, 44] 
3.0.0 :044 > a.fetch(1)
 => 22 
3.0.0 :045 > 
3.0.0 :046 > a.fetch(-1)
 => 44 
3.0.0 :047'> a.fetch(4, 'cat')
 => "cat" 

# fill(obj) → ary
fill(obj, start [, length]) → ary
fill(obj, range) → ary
The first three forms set the selected elements of self (which may be the entire array) to obj.

fill {|index| block} → ary
fill(start [, length]) {|index| block} → ary
fill(range) {|index| block} → ary
A start of nil is equivalent to zero.
A length of nil is equivalent to the length of the array.
The last three forms fill the array with the value of the given block, which is passed the absolute index of each element to be filled.

Negative values of start count from the end of the array, where -1 is the last element.

3.0.0 :050 > arr = ['a','b','c','d']
 => ["a", "b", "c", "d"] 
3.0.0 :051'> a.fill('x')
 => ["x", "x", "x", "x"] 
3.0.0 :052 > a.fill('z',2,2)
 => ["x", "x", "z", "z"] 
3.0.0 :053'> a.fill('y',0..1)
 => ["y", "y", "z", "z"] 
3.0.0 :055 > a.fill{ |i| i*i }
 => [0, 1, 4, 9] 
3.0.0 :056 > a.fill(-2) { |i| i*i*i }
 => [0, 1, 8, 27] 
 
# filter {|item| block} → new_ary
Returns a new array containing all elements of ary for which the given block returns a true value.

filter → Enumerator
If no block is given, an Enumerator is returned instead.

3.0.0 :057 > [1,1,3,4,5].select { |num| num.even? }
 => [4] 
3.0.0 :058 > [1,1,3,4,5].select { |num| num.odd? }
 => [1, 1, 3, 5] 
3.0.0 :059 > a = %w[a b c d e f]
 => ["a", "b", "c", "d", "e", "f"] 
3.0.0 :060 > a.select { |v| v =~ /[aeiou]/ }
 => ["a", "e"] 
# first → obj or nil
first(n) → new_ary
Returns the first element, or the first n elements, of the array. If the array is empty, the first form returns nil, and the second form returns an empty array. See also Array#last for the opposite effect.
3.0.0 :061 > a = ['q','r','s','t']
 => ["q", "r", "s", "t"] 
3.0.0 :062 > a.first
 => "q" 
3.0.0 :063 > a.first(2)
 => ["q", "r"] 
3.0.0 :064 > a.first(3)
 => ["q", "r", "s"] 

# initialize_copy(other_ary) → ary
Replaces the contents of self with the contents of other_ary, truncating or expanding if necessary.
3.0.0 :065 > a = ['q','r','s','t']
 => ["q", "r", "s", "t"] 
3.0.0 :067 > a.replace(['a','b','c','d','e'])
 => ["a", "b", "c", "d", "e"] 
3.0.0 :068 > a
 => ["a", "b", "c", "d", "e"] 

# inspect → string
to_s → string
Creates a string representation of self, by calling inspect on each element.
3.0.0 :069 > ['a','b','c','d','e'].to_s
 => "[\"a\", \"b\", \"c\", \"d\", \"e\"]"
 
# join(separator=$,) → str
Returns a string created by converting each element of the array to a string, separated by the given separator. If the separator is nil, it uses current $,. If both the separator and $, are nil, it uses an empty string.
3.0.0 :068 > a
 => ["a", "b", "c", "d", "e"] 
3.0.0 :069 > ['a','b','c','d','e'].to_s
 => "[\"a\", \"b\", \"c\", \"d\", \"e\"]" 
3.0.0 :070 > ['a','b','c','d','e'].join
 => "abcde" 
3.0.0 :071 > ['a','b','c','d','e'].join("-")
 => "a-b-c-d-e" 
 
# rassoc(obj) → element_ary or nil
Searches through the array whose elements are also arrays.
Compares obj with the second element of each contained array using obj.==.
Returns the first contained array that matches obj.

3.0.0 :072 > a = [ [1,'one'], [2,'two'],[3,'three'],[4,'four'], ['ii','two']]
 => [[1, "one"], [2, "two"], [3, "three"], [4, "four"], ["ii", "two"]] 
3.0.0 :073 > a.rassoc('two')
 => [2, "two"] 
3.0.0 :074 > a.rassoc('ii')
 => nil 
3.0.0 :002 > a.rassoc('four')
 => [4, "four"] 
 
# Repeated_combination(n) {|c| block} → ary
When invoked with a block, yields all repeated combinations of length n of elements from the array and then returns the array itself.
The implementation makes no guarantees about the order in which the repeated combinations are yielded.

repeated_combination(n) → Enumerator
If no block is given, an Enumerator is returned instead.

3.0.0 :003 > a = [1,2,3]
 => [1, 2, 3] 
3.0.0 :004 > a.repeated_combination(1).to_a
 => [[1], [2], [3]] 
3.0.0 :005 > a.repeated_combination(2).to_a
 => [[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3]] 
3.0.0 :006 > a.repeated_combination(3).to_a
 => [[1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 2, 2], [1, 2, 3], [1, 3, 3], [2, 2, 2], [2, 2, 3], [2, 3, 3], [3, 3, 3]] 
3.0.0 :007 > a.repeated_combination(4).to_a
 => [[1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 1, 3], [1, 1, 2, 2], [1, 1, 2, 3], [1, 1, 3, 3], [1, 2, 2, 2], [1, 2, 2, 3], [1, 2, 3, 3], [1, 3, 3, 3], [2, 2, 2, 2], [2, 2, 2, 3], [2, 2, 3, 3], [2, 3, 3, 3], [3, 3, 3, 3]] 
3.0.0 :008 > a.repeated_combination(0).to_a
 => [[]] ; one combination of length zero.

# rindex(obj) → int or nil
rindex {|item| block} → int or nil
Returns the index of the last object in self == to obj.
If a block is given instead of an argument, returns the index of the first object for which the block returns true, starting from the last object.
Returns nil if no match is found.
See also Array#index.

rindex → Enumerator
If neither block nor argument is given, an Enumerator is returned instead.

3.0.0 :017 > a = [ "a","b","b","b","c" ]  
 => ["a", "b", "b", "b", "c"] 
3.0.0 :018 > a.rindex ("b")
 => 3 
3.0.0 :019 > a.rindex ("c")
 => 4 
3.0.0 :020 > a.rindex ("a")
 => 0 
3.0.0 :022 > a.rindex { |x| x === "b" }
 => 3 

# rotate(count=1) → new_ary
Returns a new array by rotating self so that the element at count is the first element of the new array.
If count is negative then it rotates in the opposite direction, starting from the end of self where -1 is the last element.
3.0.0 :023 > a = [ "a","b","c","d" ]  
 => ["a", "b", "c", "d"] 
3.0.0 :024 > a.rotate
 => ["b", "c", "d", "a"] 
3.0.0 :025 > a.rotate(2)
 => ["c", "d", "a", "b"] 
3.0.0 :026 > a.rotate(-3)
 => ["b", "c", "d", "a"] 
------------------------------------------------------------------------------------------------------------------------------------------------

# Hashes in ruby:

Hash is a data structure that maintains a set of objects which are termed as the keys and each key associates a value with it. 
A Hash maps each of its unique keys to a specific value.
A Hash has certain similarities to an Array, but:
An Array index is always an Integer.
A Hash key can be (almost) any object.

Hash Literals or Creating Hashes: A hash is created using the hash literal which is a comma-separated list of key/value pairs and it always enclosed within curly braces {}. 

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm_Ruby$ irb
3.0.0 :001 > person = {name: 'Martz', language: 'Ruby'}
 => {:name=>"Martz", :language=>"Ruby"} 
3.0.0 :002 > def some_method(hash)
3.0.0 :003 >   p hash
3.0.0 :004 > end
 => :some_method 
3.0.0 :007 > some_method({foo: 0, bar: 1, baz: 2})
{:foo=>0, :bar=>1, :baz=>2}
 => {:foo=>0, :bar=>1, :baz=>2} 
 
Note: when the last argument in a method call is a Hash, the curly braces may be omitted:
3.0.0 :008 > some_method(foo: 0, bar: 1, baz: 2)
{:foo=>0, :bar=>1, :baz=>2}
 => {:foo=>0, :bar=>1, :baz=>2}
 
# You can use a Hash to initialize an object:
3.0.0 :016 > class Learn
3.0.0 :017 >   attr_accessor :name, :language
3.0.0 :018 >   def initialize(hash)
3.0.0 :019 >     self.name = hash[:name]
3.0.0 :020 >     self.language = hash[:language]
3.0.0 :021 >   end
3.0.0 :022 > end
 => :initialize 
3.0.0 :023 > Mahima = Learn.new(name: 'Mahima', language: 'Ruby')
 => #<Learn:0x000055dc34e03b00 @name="Mahima", @language="Ruby"> 
 
# Creating a Hash¶ ↑
Here are three ways to create a Hash:
Method Hash.new
Method Hash[]
Literal form: {}.

--> You can create a Hash by calling method ::new.

Create an empty Hash:
3.0.0 :024 > h = Hash.new
 => {} 
3.0.0 :025 > h.class
 => Hash 

You can create a Hash by calling method ::[].

Create an empty Hash:
3.0.0 :026 > h = Hash[]
 => {} 
3.0.0 :027 > h = Hash(name: 'Mahima', language: 'Ruby')
 => {:name=>"Mahima", :language=>"Ruby"} 

You can create a Hash by using its literal form (curly braces).

Create an empty Hash:
3.0.0 :028 > h = {}
 => {} 
3.0.0 :032 > h = {foo: 1, bar: 2, baz: 3}
 => {:foo=>1, :bar=>2, :baz=>3} 


# Hash Value Basics:
The simplest way to retrieve a Hash value (instance method []):
3.0.0 :032 > h = {foo: 1, bar: 2, baz: 3}
 => {:foo=>1, :bar=>2, :baz=>3} 
Updating a value does not affect the order:
3.0.0 :033 > h[:bat] = 4
 => 4 
3.0.0 :034 > h 
 => {:foo=>1, :bar=>2, :baz=>3, :bat=>4} 
3.0.0 :035 > h[:foo] = 5
 => 5 
3.0.0 :036 > h
 => {:foo=>5, :bar=>2, :baz=>3, :bat=>4} 
 
The simplest way to delete a Hash entry (instance method delete):
But re-creating a deleted entry can affect the order:
3.0.0 :037 > h.delete(:bar)
 => 2 
3.0.0 :038 > h
 => {:foo=>5, :baz=>3, :bat=>4} 

# Hash Key Equivalence:
Two objects are treated as the same hash key when their hash value is identical and the two objects are eql? to each other.

# Modifying an Active Hash Key:
Modifying a Hash key while it is in use damages the hash's index.
This Hash has keys that are Arrays:
3.0.0 :039 > a0 = [ :foo, :bar ]
 => [:foo, :bar] 
3.0.0 :040 > a1 = [ :baz, :bat ]
 => [:baz, :bat] 
3.0.0 :041 > h = {a0 => 0, a1 => 1}
 => {[:foo, :bar]=>0, [:baz, :bat]=>1} 
3.0.0 :042 > h.include?(a0)
 => true 
3.0.0 :043 > h[a0]
 => 0 
3.0.0 :044 > a0.hash
 => 1589344940556418274 
 
Modifying array element a0[0] changes its hash value:
3.0.0 :045 > a0[0] = :bam
 => :bam 
3.0.0 :046 > a0.hash
 => 2610535359265828681 

And damages the Hash index:
3.0.0 :047 > h.include?(a0)
 => false 
 
# You can repair the hash index using method rehash:
3.0.0 :048 > h.rehash
 => {[:bam, :bar]=>0, [:baz, :bat]=>1} 
3.0.0 :049 > h.include?(a0)
 => true 
3.0.0 :050 > h[a0]
 => 0 

A String key is always safe. That's because an unfrozen String passed as a key will be replaced by a duplicated and frozen String:
3.0.0 :051 > s = 'foo'
 => "foo" 
3.0.0 :052 > s.frozen?
 => false 
3.0.0 :053 > h = {s => 0}
 => {"foo"=>0} 
3.0.0 :054 > first_key = h.keys.first
 => "foo" 
3.0.0 :055 > first_key.frozen?
 => true 

# User-Defined Hash Keys:
To be useable as a Hash key, objects must implement the methods hash and eql?. 
Note: this requirement does not apply if the Hash uses compare_by_id since comparison will then rely on the keys' object id instead of hash and eql?.
Object defines basic implementation for hash and eq? that makes each object a distinct key.

# You can retrieve the default value with method default:
3.0.0 :056 > h = Hash.new
 => {} 
3.0.0 :057 > h.default
 => nil 

You can set the default value by passing an argument to method ::new or with method default=
3.0.0 :058 > h = Hash.new(-1)
 => {} 
3.0.0 :059 > h.default
 => -1 
3.0.0 :060 > h.default
 => -1 
3.0.0 :061 > h.default
 => -1 

This default value is returned for [], values_at and dig when a key is not found:
3.0.0 :065 > counts[:foo]
 => 42 
3.0.0 :066 > counts[:bar]
 => nil 
3.0.0 :067 > counts.default
 => nil 
3.0.0 :068 > counts[:bar]
 => nil 
3.0.0 :069 > counts.values_at(:foo, :bar, :baz)
 => [42, nil, nil] 
3.0.0 :070 > counts.dig(:bar)
 => nil 

Note that the default value is used without being duplicated. It is not advised to set the default value to a mutable object:
3.0.0 :071?> synonyms = Hash.new([])
 => {} 
3.0.0 :072 > synonyms[:hello]
 => [] 
3.0.0 :073 > synonyms[:hello] << :hi
 => [:hi] 
3.0.0 :074 > synonyms.default
 => [:hi] 
3.0.0 :075 > synonyms[:world] << :universe
 => [:hi, :universe] 
3.0.0 :076 > synonyms.keys
 => [] 
3.0.0 :077 > synonyms[:world]
 => [:hi, :universe] 
3.0.0 :078 > synonyms.keys
 => [] 

To use a mutable object as default, it is recommended to use a default proc

# Default Proc:
When the default proc for a Hash is set (i.e., not nil), the default value returned by method [] is determined by the default proc alone.
You can retrieve the default proc with method default_proc:
3.0.0 :079 > h = Hash.new
 => {} 
3.0.0 :080 > h.default_proc
 => nil 

You can set the default proc by calling ::new with a block or calling the method default_proc=
3.0.0 :081 > h = Hash.new{ |hash, key| "Default value for #{key}" }
 => {} 
3.0.0 :083 > h.default_proc = proc { |hash, key| "Default value for #{key.inspec
t}" }
 => #<Proc:0x000055dc34a5c0b0 (irb):83> 
3.0.0 :084 > h.default_proc.class
 => Proc 

# When the single given argument is an Array of 2-element Arrays, returns a new Hash object wherein each 2-element array forms a key-value entry:
3.0.0 :087 > Hash[ [[:foo, 0], [:bar, 1]]]
3.0.0 :088 >   
 => {:foo=>0, :bar=>1} 

When the argument count is an even number; returns a new Hash object wherein each successive pair of arguments has become a key-value entry:
3.0.0 :089 > Hash[:foo, 0, :bar, 1]
3.0.0 :090 >   
 => {:foo=>0, :bar=>1} 

# ruby2_keywords_hash(hash) → hash
Duplicates a given hash and adds a ruby2_keywords flag. This method is not for casual use; debugging, researching, and some truly necessary cases like deserialization of arguments.
3.0.0 :091 > h = {k:1}
 => {:k=>1} 
3.0.0 :092 > h = Hash.ruby2_keywords_hash(h)
 => {:k=>1} 
3.0.0 :093 > def foo(k:42)
3.0.0 :094 >   k
3.0.0 :095 > end
 => :foo 
3.0.0 :096 > foo(*[h])
 => 1 

ruby2_keywords_hash?(hash) → true or false
Checks if a given hash is flagged by Module#ruby2_keywords (or Proc#ruby2_keywords). This method is not for casual use; debugging, researching, and some truly necessary cases like serialization of arguments.
3.0.0 :097 > ruby2_keywords def foo(*args)
3.0.0 :098 >   Hash.ruby2_keywords_hash?(args.last)
3.0.0 :099 > end
 => nil 
3.0.0 :100 > foo(k:1)
 => true 
3.0.0 :101 > foo({k:1})
 => false 

# try_convert(obj) → obj, new_hash, or nil
If obj is a Hash object, returns obj.
Otherwise if obj responds to :to_hash, calls obj.to_hash and returns the result.
Returns nil if obj does not respond to :to_hash
Raises an exception unless obj.to_hash returns a Hash object.

# hash < other_hash → true or false
Returns true if hash is a proper subset of other_hash, false otherwise:
3.0.0 :102 > h1 = {foo: 0, bar: 1}
 => {:foo=>0, :bar=>1} 
3.0.0 :105 > h2 = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :106 > h1 < h2
 => false 
3.0.0 :107 > h1 < h2
 => false 
3.0.0 :108 > h2 < h1
 => false 
3.0.0 :109 > h1 < h1
 => false 

# hash == object → true or false
Returns true if all of the following are true:
object is a Hash object.
hash and object have the same keys (regardless of order).
For each key key, hash[key] == object[key].
Otherwise, returns false.
3.0.0 :110 > h1 = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :111 > h2 = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :112 > h1 == h2
 => true 
3.0.0 :113 > h3 = { baz: 2, bar: 1, foo: 0}
 => {:baz=>2, :bar=>1, :foo=>0} 
3.0.0 :114 > h1 == h3
 => true 

# hash[key] → value
Returns the value associated with the given key, if found:
3.0.0 :115 > h[:foo]
 => nil 
 3.0.0 :116 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
If key is not found, returns a default value (see Default Values):
3.0.0 :117 > h[:nosuch]
 => nil 

If key does not exist, adds the key and value; the new entry is last in the order.
3.0.0 :118 > h = {foo: 0, bar: 1}
 => {:foo=>0, :bar=>1} 
3.0.0 :119 > h[:baz] = 2
 => 2 
3.0.0 :120 > h.store(:bat, 3)
 => 3 
3.0.0 :121 > h
 => {:foo=>0, :bar=>1, :baz=>2, :bat=>3} 

# any? → true or false:
any?(object) → true or false
any? {|key, value| ... } → true or false
Returns true if any element satisfies a given criterion; false otherwise.
With no argument and no block, returns true if self is non-empty; false if empty.
With argument object and no block, returns true if for any key key h.assoc(key) == object:
3.0.0 :122 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :123 > h.any?([:bar, 1])
 => true 
3.0.0 :124 > h.any?([:bar, 0])
 => false 
3.0.0 :125 > h.any?([:baz, 1])
 => false 

With no argument and a block, calls the block with each key-value pair; returns true if the block returns any truthy value, false otherwise:
3.0.0 :126 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :127 > h.any? { |key, value| value < 3}
 => true 
3.0.0 :128 > h.any? { |key, value| value > 3}
 => false 

# assoc(key) → new_array or nil
If the given key is found, returns a 2-element Array containing that key and its value:
3.0.0 :129 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :130 > h.assoc(:bar)
 => [:bar, 1] 

# clear → self
Removes all hash entries; returns self

# compact → new_hash
Returns a copy of self with all nil-valued entries removed:
3.0.0 :131 > h = {foo: 0, bar: 1, baz: nil}
 => {:foo=>0, :bar=>1, :baz=>nil} 
3.0.0 :132 > h1 = h.compact
 => {:foo=>0, :bar=>1} 
 
# compare_by_identity → self
Sets self to consider only identity in comparing keys; two keys are considered the same only if they are the same object; returns self.
By default, these two object are considered to be the same key, so s1 will overwrite s0:
3.0.0 :142 > s0 = 'x'
 => "x" 
3.0.0 :143 > s1 = 'x'
 => "x" 
3.0.0 :144 > h.compare_by_identity?
 => true 
3.0.0 :145 > h[s0]
 => nil 
3.0.0 :146 > h[s1]
 => nil 
 
# Delete:
3.0.0 :152 > h = {foo: 0, bar: 1, baz: nil}
 => {:foo=>0, :bar=>1, :baz=>nil} 
3.0.0 :153 > h.delete(:nosuch) { |key| "key #{key} not found"}
3.0.0 :154 >   
 => "key nosuch not found" 
3.0.0 :155 > h
 => {:foo=>0, :bar=>1, :baz=>nil}
 
# dig(key, *identifiers) → object
Finds and returns the object in nested objects that is specified by key and identifiers. The nested objects may be instances of various classes. See Dig Methods.

Nested Hashes:
3.0.0 :156 > h = {foo: { bar: { baz: 2}}}
 => {:foo=>{:bar=>{:baz=>2}}} 
3.0.0 :157 > h.dig(:foo)
 => {:bar=>{:baz=>2}} 
3.0.0 :158 > h.dig(:foo, :bar)
 => {:baz=>2} 
3.0.0 :159 > h.dig(:foo, :bar, :baz)
 => 2 
3.0.0 :160 > h.dig(:foo, :bar, :BAZ)
 => nil 

Nested Hashes and Arrays:
3.0.0 :161 > h = {foo: {bar: [:a, :b, :c]}}
 => {:foo=>{:bar=>[:a, :b, :c]}} 
3.0.0 :162 > h.dig(:foo, :bar, 2)
 => :c 

This method will use the default values for keys that are not present:
3.0.0 :163 > h = {foo: {bar: [:a, :b, :c]}}
 => {:foo=>{:bar=>[:a, :b, :c]}} 
3.0.0 :164 > h.dig(:hello)
 => nil 
3.0.0 :165 > h.default_proc
 => nil 
3.0.0 :166 > h.default_proc =
3.0.0 :167 > h.dig(:hello, :world)
 => nil 
3.0.0 :168 > h.default_proc =
3.0.0 :169 > h.dig(:hello, :world, :foo, :bar , 2)
 => nil 
 
# each {|key, value| ... } → self
each_pair {|key, value| ... } → self
each → new_enumerator
each_pair → new_enumerator
#each is an alias for #each_pair.
Calls the given block with each key-value pair; returns self:
3.0.0 :170 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :171 > h.each_pair {|key, value| puts "#{key}: #{value}"}
foo: 0
bar: 1
baz: 2
 => {:foo=>0, :bar=>1, :baz=>2} 
 
# except(*keys) → a_hash
Returns a new Hash excluding entries for the given keys:
3.0.0 :172 > h = { a: 100, b: 200, c: 300}
 => {:a=>100, :b=>200, :c=>300} 
3.0.0 :173:> h.except(:a)
 => {:b=>200, :c=>300} 

# fetch(key) → object
fetch(key, default_value) → object
fetch(key) {|key| ... } → object
Returns the value for the given key, if found.
3.0.0 :174:> h.fetch(:a)
 => 100 
3.0.0 :175 > {}.fetch(:nosuch, :default)
 => :default 
3.0.0 :176 > {}.fetch(:nosuch)

fetch_values(*keys) → new_array
fetch_values(*keys) {|key| ... } → new_array
Returns a new Array containing the values associated with the given keys *keys:
3.0.0 :177 > h = { a: 100, b: 200, c: 300}
 => {:a=>100, :b=>200, :c=>300} 
3.0.0 :178:> h.fetch_values(:a, :b)
 => [100, 200] 

Returns a new empty Array if no arguments given.
When a block is given, calls the block with each missing key, treating the block's return value as the value for that key:
3.0.0 :179 > h = { a: 100, b: 200, c: 300}
 => {:a=>100, :b=>200, :c=>300} 
3.0.0 :180 > values = h.fetch_values(:b, :a, :d) {|key| key.to_s}
 => [200, 100, "d"] 
3.0.0 :181 > values
 => [200, 100, "d"] 

# elect {|key, value| ... } → new_hash
select → new_enumerator
#filter is an alias for #select.
Returns a new Hash object whose entries are those for which the block returns a truthy value:
3.0.0 :185 > h = { a: 100, b: 200, c: 300}
 => {:a=>100, :b=>200, :c=>300} 
3.0.0 :186 > e = h.select
 => #<Enumerator: {:a=>100, :b=>200, :c=>300}:select> 
3.0.0 :187 > e.each {|key, value| value >100}
 => {:b=>200, :c=>300} 

# flatten → new_array
flatten(level) → new_array
Returns a new Array object that is a 1-dimensional flattening of self.
By default, nested Arrays are not flattened:
3.0.0 :188 > h = {foo: 0, bar: [:bat, 3], baz: 2}
 => {:foo=>0, :bar=>[:bat, 3], :baz=>2} 
3.0.0 :189 > h.flatten
 => [:foo, 0, :bar, [:bat, 3], :baz, 2] 
3.0.0 :190 > h = {foo: 0, bar: [:bat, [:baz, [:bat, ]]]}
 => {:foo=>0, :bar=>[:bat, [:baz, [:bat]]]} 
3.0.0 :191 > h.flatten(1)
 => [:foo, 0, :bar, [:bat, [:baz, [:bat]]]] 
3.0.0 :192 > h.flatten(2)
 => [:foo, 0, :bar, :bat, [:baz, [:bat]]] 
3.0.0 :193 > h.flatten(3)
 => [:foo, 0, :bar, :bat, :baz, [:bat]] 
3.0.0 :194 > h.flatten(4)
 => [:foo, 0, :bar, :bat, :baz, :bat] 

When level is negative, flattens all nested Arrays:
3.0.0 :195 > h.flatten(-1)
 => [:foo, 0, :bar, :bat, :baz, :bat] 
3.0.0 :196 > h.flatten(-2)
 => [:foo, 0, :bar, :bat, :baz, :bat] 
 
When level is zero, returns the equivalent of to_a :
3.0.0 :197 > h.flatten(0)
 => [[:foo, 0], [:bar, [:bat, [:baz, [:bat]]]]] 

# has_key?(key) → true or false
Methods has_key?, key?, and member? are aliases for #include?.
Returns true if key is a key in self, otherwise false.
has_value?(value) → true or false
Returns true if value is a value in self, otherwise false.

hash → an_integer
Returns the Integer hash-code for the hash.
Two Hash objects have the same hash-code if their content is the same (regardless or order):

# replace(other_hash) → self
Replaces the entire contents of self with the contents of other_hash; returns self:
3.0.0 :199 > h.replace({b: 400, c: 500})
 => {:b=>400, :c=>500} 
3.0.0 :200 > h
 => {:b=>400, :c=>500} 

# inspect → new_stringclick to toggle source
Returns a new String containing the hash entries:
#to_s is an alias for #inspect.
Also aliased as: to_s
3.0.0 :201 > h.inspect
 => "{:b=>400, :c=>500}" 

# invert → new_hash
Returns a new Hash object with the each key-value pair inverted:
3.0.0 :202 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :203 > h1 = h.invert
 => {0=>:foo, 1=>:bar, 2=>:baz} 
3.0.0 :204 > h = {foo: 0, bar: 1, baz: 1}
Overwrites any repeated new keys: (see Entry Order):
 => {:foo=>0, :bar=>1, :baz=>1} 
3.0.0 :205 > h.invert
 => {0=>:foo, 1=>:baz} 

# keep_if {|key, value| ... } → self
keep_if → new_enumerator
Calls the block for each key-value pair; retains the entry if the block returns a truthy value; otherwise deletes the entry; returns self.
3.0.0 :207 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :208 > h.keep_if {|key, value| key.start_with?('b')}
 => {:bar=>1, :baz=>2} 

# key(value)-> key or nill:
Returns the key for the first-found entry with the given value:
3.0.0 :210 > h.key(0)
 => :foo 
3.0.0 :211 > h.key(1)
 => nil 
3.0.0 :212 > h.key(2)
 => :bar 

Keys returns all key value:
3.0.0 :213 > h.keys
 => [:foo, :bar, :baz] 

# merge → copy_of_self
merge(*other_hashes) → new_hash
merge(*other_hashes) { |key, old_value, new_value| ... } → new_hash
Returns the new Hash formed by merging each of other_hashes into a copy of self.
Each argument in other_hashes must be a Hash.
With arguments and no block:
Returns the new Hash object formed by merging each successive Hash in other_hashes into self.
Each new-key entry is added at the end.
Each duplicate-key entry's value overwrites the previous value.
3.0.0 :214 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :215 > h1 = {bat: 3, bar: 4}
 => {:bat=>3, :bar=>4} 
3.0.0 :216 > h2 = {bam: 5, bat: 6 }
 => {:bam=>5, :bat=>6} 
3.0.0 :217 > h.merge(h1, h2)
 => {:foo=>0, :bar=>4, :baz=>2, :bat=>6, :bam=>5} 

# merge!:
3.0.0 :218 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :219 > h1 = {bat: 3, bar: 4}
 => {:bat=>3, :bar=>4} 
3.0.0 :220 > h2 = {bam: 5, bat: 6 }
 => {:bam=>5, :bat=>6} 
3.0.0 :221 > h.merge!(h1, h2)
 => {:foo=>0, :bar=>4, :baz=>2, :bat=>6, :bam=>5} 

# rassoc(value) → new_array or nil
Returns a new 2-element Array consisting of the key and value of the first-found entry whose value is == to value (see Entry Order):

3.0.0 :222 > h = {foo: 0, bar: 1, baz: 1}
 => {:foo=>0, :bar=>1, :baz=>1} 
3.0.0 :223 > h.rassoc(1)
 => [:bar, 1] 
Returns nil if no such value found.


# reject {|key, value| ... } → new_hash
reject → new_enumerator
Returns a new Hash object whose entries are all those from self for which the block returns false or nil:
3.0.0 :224 > h = {foo: 0, bar: 1, baz: 1}
 => {:foo=>0, :bar=>1, :baz=>1} 
3.0.0 :225 > h1 = h.reject { |key, value| key.start_with?('b') }
 => {:foo=>0} 
 
# select {|key, value| ... } → new_hash
select → new_enumerator
#filter is an alias for #select.
Returns a new Hash object whose entries are those for which the block returns a truthy value:
3.0.0 :226 > h = {foo: 0, bar: 1, baz: 1}
 => {:foo=>0, :bar=>1, :baz=>1} 
3.0.0 :227 > h.select {|key, value| value < 2}
 => {:foo=>0, :bar=>1, :baz=>1} 

# select! {|key, value| ... } → self or nil
select! → new_enumerator
#filter! is an alias for #select!.
Returns self, whose entries are those for which the block returns a truthy value:
3.0.0 :227 > h.select! {|key, value| value < 2}
 => {:foo=>0, :bar=>1} 
Returns nil if no entries were removed.
Returns a new Enumerator if no block given:

# shift → [key, value] or default_value
Removes the first hash entry (see Entry Order); returns a 2-element Array containing the removed key and value:
3.0.0 :231 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :232 > h.shift  
 => [:foo, 0] 
3.0.0 :233 > h 
 => {:bar=>1, :baz=>2} 

Returns the default value if the hash is empty.

# bize → integer
Returns the count of entries in self:
3.0.0 :234 > {foo: 0, bar: 1, baz: 2}.length
 => 3 
#length is an alias for #size.

# slice(*keys) → new_hashclick to toggle source
Returns a new Hash object containing the entries for the given keys:
3.0.0 :235 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :236 > h.slice(:baz, :foo)
 => {:baz=>2, :foo=>0}
Any given keys that are not found are ignored.


# store(key, value)
#store is an alias for #[]=.
Associates the given value with the given key; returns value.
If the given key exists, replaces its value with the given value; the ordering is not affected (see Entry Order):
3.0.0 :238 > h = {foo: 0, bar: 1}
 => {:foo=>0, :bar=>1} 
3.0.0 :239 > h[:foo]
 => 0 
3.0.0 :240 > h.store(:bar, 3)
 => 3 
3.0.0 :241 > h
 => {:foo=>0, :bar=>3} 
3.0.0 :242 > h[:bar]
 => 3 

# to_a → new_array
Returns a new Array of 2-element Array objects; each nested Array contains a key-value pair from self:
3.0.0 :243 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :244 > h.to_a
 => [[:foo, 0], [:bar, 1], [:baz, 2]] 

# to_h → self or new_hash
to_h {|key, value| ... } → new_hash
For an instance of Hash, returns self.
For a subclass of Hash, returns a new Hash containing the content of self.
When a block is given, returns a new Hash object whose content is based on the block; the block should return a 2-element Array object specifying the key-value pair to be included in the returned Array:
3.0.0 :243 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :245 > h1 = h.to_h {|key, value| [value, key]}
 => {0=>:foo, 1=>:bar, 2=>:baz} 
 
# to_proc → proc
Returns a Proc object that maps a key to its value:
3.0.0 :246 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :247 > proc = h.to_proc
 => #<Proc:0x000055dc34cf3c60 (lambda)> 
3.0.0 :248 > proc.class
 => Proc 
3.0.0 :249 > proc.call(:foo)
 => 0 
3.0.0 :250 > proc.call(:bar)
 => 1 
3.0.0 :251 > proc.call(:nosuch)
 => nil 

# transform_keys {|key| ... } → new_hash
transform_keys(hash2) → new_hash
transform_keys(hash2) {|other_key| ...} → new_hash
transform_keys → new_enumerator
Returns a new Hash object; each entry has:
A key provided by the block.
The value from self.
An optional hash argument can be provided to map keys to new keys. Any key not given will be mapped using the provided block, or remain the same if no block is given.

3.0.0 :252 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :253 > h1 =  h.transform_keys {|key| key.to_s}
 => {"foo"=>0, "bar"=>1, "baz"=>2} 
3.0.0 :254 > h1
 => {"foo"=>0, "bar"=>1, "baz"=>2} 

3.0.0 :261 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :262 > h1 = h.transform_keys {|key| :bat}
 => {:bat=>2} 

# transform_values {|value| ... } → new_hash
transform_values → new_enumerator
Returns a new Hash object; each entry has:
A key from self.
A value provided by the block.

Transform values: 
3.0.0 :263 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :264 > h1 = h.transform_values {|value| value*100}
 => {:foo=>0, :bar=>100, :baz=>200} 

# has_value?(value) → true or false
Returns true if value is a value in self, otherwise false.

# values → new_array
Returns a new Array containing all values in self:
3.0.0 :265 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :266 > h.values
 => [0, 1, 2] 
 
# values_at(*keys) → new_array
Returns a new Array containing values for the given keys:

3.0.0 :267 > h = {foo: 0, bar: 1, baz: 2}
 => {:foo=>0, :bar=>1, :baz=>2} 
3.0.0 :268 > h.values_at(:baz, :foo) 
 => [2, 0] 

The default values are returned for any keys that are not found:
3.0.0 :269 > h.values_at(:hello, :foo) 
 => [nil, 0] 
