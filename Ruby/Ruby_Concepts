Ruby is a perfect Object Oriented Programming Language. The features of the object-oriented programming language include −
Data Encapsulation
Data Abstraction
Polymorphism
Inheritance

# Basic ruby code practice:
itsacheckmate@itsacheckmate:~$ irb
3.0.0 :001 > puts "Learning Ruby";
Learning Ruby
 => nil 
3.0.0 :002 > def Helloout = "Hello World"
3.0.0 :003 >   
 => :Helloout 
3.0.0 :004 > def hello
3.0.0 :005 >   out = "Hello World"
3.0.0 :006 >   puts out
3.0.0 :007 > end
 => :hello 
3.0.0 :008 > hello
Hello World
 => nil 
3.0.0 :009 > exit

itsacheckmate@itsacheckmate:~$ cd Training-Repository/
itsacheckmate@itsacheckmate:~/Training-Repository$ Rvm\ and\ Ruby/
Hello,started learning Rub
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Hello,started learning Ruby
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ irb
3.0.0 :001"> print <<EOF
3.0.0 :002"> This is the first way of creating
3.0.0 :003"> here document ie. multiple string.
3.0.0 :004"> EOF
3.0.0 :006"> This is the second way of creating
3.0.0 :007"> here document ie. multiple line string.
3.0.0 :008 > EOF
This is the second way of creating
here document ie. multiple line string.
 => nil 

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ irb
3.0.0 :001"> print <<"EOC";
3.0.0 :002"> echo hy
3.0.0 :003"> EOC
echo hy
 => nil 
3.0.0 :004`> print <<`EOC`;                      #SAME AS ABOVE
3.0.0 :005`> echo hy
3.0.0 :006`> echo there
3.0.0 :007 > EOC
hy
there
 => nil 
3.0.0 :008"> print <<"foo",<<"bar"
3.0.0 :009"> I said foo.
3.0.0 :010"> foo
3.0.0 :011"> I said bar.
3.0.0 :012 > bar
I said foo.
I said bar.
 => nil 

3.0.0 :013 > puts "This is main Ruby Program"
This is main Ruby Program
 => nil 

# Using BEGIN Statement:
--> First put block of code in a file then it will execute.
--> It will show the line which is entered in "begin" block firstly then other lines of the file.
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Initializing Ruby Program
Hello,started learning Ruby
This is main Ruby Program

# Using END Statement:
--> Declares code to be called at the end of the program.
puts "Hello,started learning Ruby";
puts "This is main Ruby Program"
BEGIN {
   puts "Initializing first Ruby Program"
}
END {
   puts "Terminating Ruby Program"
}
BEGIN {
   puts "Initializing second Ruby Program"
}
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Initializing first Ruby Program
Initializing second Ruby Program
Hello,started learning Ruby
This is main Ruby Program
Terminating Ruby Program

# Ruby Comments
-->A comment hides a line, part of a line, or several lines from the Ruby interpreter. You can use the hash character (#) at the beginning of a line −
# I am a comment. Just ignore me.
Or, a comment may be on the same line after a statement or expression −
name = "Maddy" # This is again comment
You can comment multiple lines as follows −
# This is a comment.
# This is a comment, too.
# This is a comment, too.
# I said that already.
Here is another form. This block comment conceals several lines from the interpreter with =begin/=end −
=begin
This is a comment.
This is a comment, too.
This is a comment, too.
I said that already.
=end (Will not display anything becoz it is a comment.)

# Defining a Class in Ruby:
A class in Ruby always starts with the keyword class followed by the name of the class. The name should always be in initial capitals. The class Customer can be displayed as −
Syntax:
class Customer
end
You terminate a class by using the keyword end.

# Variables:
Variables are the memory locations, which hold any data to be used by any program.
Unlike other programming languages, there is no need to declare a variable in Ruby. A prefix is needed to indicate it.
There are four types of variables in Ruby:

1.Local variables: A local variable name starts with a lowercase letter or underscore (_). It is only accessible or have its scope within the block of its initialization. Once the code block completes, variable has no scope.
When uninitialized local variables are called, they are interpreted as call to a method that has no arguments.
# Example of local variable:
color = "Red"
def method1 
color = 192
puts("Color Value in method1 : ",color)
end 
def method2
color = 255
puts("Color Value method2: ",color)
end
method1 
method2  
method1
puts("Color Value outside methods : "+color)

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Color Value in method1 : 
192
Color Value method2: 
255
Color Value in method1 : 
192
Color Value outside methods : Red

2.Class variables: A class variable name starts with @@ sign. They need to be initialized before use. A class variable belongs to the whole class and can be accessible from anywhere inside the class. If the value will be changed at one instance, it will be changed at every instance.
A class variable is shared by all the descendents of the class. An uninitialized class variable will result in an error.
# Example of class variable:
class Customer
# class variable
 @@no_of_customers = 0
 def initialize(id, name, addr)   
# An instance Variable
 @cust_id = id
 @cust_name = name
 @cust_addr = addr
 end
# displaying result 
 def display_details()
 puts "Customer id #@cust_id"
 puts "Customer name #@cust_name"
 puts "Customer address #@cust_addr"
 end 
 def total_no_of_customers()   
# class variable
 @@no_of_customers += 1
 puts "Total number of customers: #@@no_of_customers"
    end
end
# Create Objects
cust1 = Customer.new("1", "Ram", "BPTP, Faridabad")
cust2 = Customer.new("2", "Ruchi", "Gol Chakkar road,Kalkaji")
# Call Methods
cust1.display_details()
cust1.total_no_of_customers()
cust2.display_details()
cust2.total_no_of_customers()

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Customer id 1
Customer name Ram
Customer address BPTP, Faridabad
Total number of customers: 1
Customer id 2
Customer name Ruchi
Customer address Gol Chakkar road,Kalkaji
Total number of customers: 2

3.Instance variables: An instance variable name starts with a @ sign. It belongs to one instance of the class and can be accessed from any instance of the class within a method. 
They only have limited access to a particular instance of a class,instance variables can change from object to object.
They don't need to be initialize. An uninitialized instance variable will have a nil value.
# EXAMPLE OF INSTANCE VARIABLE:
class Customer
 def initialize(id, name, addr)
# Instance Variables     
 @cust_id = id
 @cust_name = name
 @cust_addr = addr
 end 
 # displaying result
 def display_details()
 puts "Customer id #@cust_id"
 puts "Customer name #@cust_name"
 puts "Customer address #@cust_addr"
 end
end
# Create Objects
cust1 = Customer.new("1", "John", "Wisdom Apartments, Ludhiya")
cust2 = Customer.new("2", "Poul", "New Empire road, Khandala")
# Call Methods
cust1.display_details()
cust2.display_details()

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Customer id 1
Customer name John
Customer address Wisdom Apartments, Ludhiya
Customer id 2
Customer name Poul
Customer address New Empire road, Khandala

# Another example:
class Student
  def initialize(student_id, student_name)
    @student_id = student_id
    @student_name = student_name
  end
  
  def show
    puts "Student Name and ID : "
    puts(@student_id, @student_name)
  end
end
Student.new(1, "Sara").show
Student.new(2, "Raju").show
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Student Name and ID : 
1
Sara
Student Name and ID : 
2
Raju

4.Global variables: A global variable name starts with a $ sign. Its scope is globally, means it can be accessed from any where in a program.An uninitialized global variable will have a nil value.
# Example of Gloabal Variable:
# global variable
$global_variable = 10
class Class1
 def print_global
 puts "Global variable in Class1 is #$global_variable"
 end
end
class Class2
 def print_global
 puts "Global variable in Class2 is #$global_variable"
 end
end
class1obj = Class1.new
class1obj.print_global
class2obj = Class2.new
class2obj.print_global

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Global variable in Class1 is 10
Global variable in Class2 is 10

# Symbol	Type of Variable:
[a-z] or _	Local Variable
@	Instance Variable
@@	Class Variable
$	Global Variable

# Ruby Constants:
Constants begin with an uppercase letter. Constants defined within a class or module can be accessed from within that class or module, and those defined outside a class or module can be accessed globally.

ex- class Example
 VAR1 = 100
 VAR2 = 200
 def show
 puts "Value of first constant is #{VAR1}"
 puts "Value of second constant is #{VAR2}"
 end
end
object = Example.new()
object.show

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
Value of first constant is 100
Value of second constant is 200

# Operators:
1.Ruby Arithmetic Operators:
Operator  Description	                                                                                    Example
+         Addition − Adds values on either side of the operator.	                                     a + b will give 30
−	  Subtraction − Subtracts right hand operand from left hand operand.	                             a - b will give -10
*	  Multiplication − Multiplies values on either side of the operator.	                             a * b will give 200
/	  Division − Divides left hand operand by right hand operand.	                             b / a will give 2
%	  Modulus − Divides left hand operand by right hand operand and returns remainder.	              b % a will give 0
**	  Exponent − Performs exponential (power) calculation on operators.	                            a**b will give 10 to the power 20

3.0.0 :013 >  a = 10
 => 10 
3.0.0 :014 > b = 20
 => 20 
3.0.0 :015 > a+b
 => 30 
3.0.0 :016 > a-b
 => -10 
3.0.0 :017 > a*b
 => 200 
3.0.0 :018 > b/a
 => 2 
3.0.0 :019 > b%a
 => 0 
3.0.0 :020 > a**b
 => 100000000000000000000 

2.Ruby Comparison Operators:
Operator	Description	                                                                                                       Example
==	Checks if the value of two operands are equal or not, if yes then condition becomes true.	                                   (a == b) is not true.
!=	Checks if the value of two operands are equal or not, if values are not equal then condition becomes true.	                    (a != b) is true.
>	Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.	    (a > b) is not true.
<	Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.	            (a < b) is true.
>=	Checks if the value of left operand is greater than or equal to the value of right operand,if yes then condition becomes true.  (a >= b) is not true.
<=	Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.    (a <= b) is true.
<=>	Combined comparison operator. Returns 0 if first operand equals second, 1 if first operand is greater than the second 
        and -1 if first operand is less than the second.	                                                                          (a <=> b) returns -1.
===	Used to test equality within a when clause of a case statement.	                                                           (1...10) === 5 returns true.
.eql?	True if the receiver and argument have both the same type and equal values.(Checks datatype as 1!=1.0 i.e 1 is int)              1 == 1.0 returns true, but 1.eql?(1.0) is false.
equal?	True if the receiver and argument have the same object id.	                                                                   if aObj is duplicate of bObj then aObj == bObj is true, 
                                                                                                                                         a.equal?bObj is false but a.equal?aObj is true.

                                                                                                                                         
3.0.0 :021 > a==b
 => false 
3.0.0 :022 > a!=b
 => true 
3.0.0 :023 > a>b
 => false 
3.0.0 :024 > a<b
 => true 
3.0.0 :025 > a>=b
 => false 
3.0.0 :026 > a<=b
 => true 
3.0.0 :027 > a===b
 => false 
3.0.0 :030 > 10.eql?20
 => false 
3.0.0 :031 > c = 1
 => 1 
3.0.0 :032 > d = 1.0
 => 1.0 
3.0.0 :033 > 1.eql?1.0
 => false 
3.0.0 :034 > c = 1
 => 1 
3.0.0 :035 > d = 2
 => 2 
3.0.0 :036 > 1.eql?2
 => false 
3.0.0 :037 > d = 1
 => 1 
3.0.0 :038 > c.eql?d
 => true 
 
 3. Ruby Assignment Operators:
 Ruby Assignment Operator
 
= it is simple assignmnet operator
+= add and assignment operator
-= subtract and assignment operator
*=
/=
%=
**=
 all above are arithmatic and assignment operator which behave in same way
 fist the arithmatic operator works and than the result value is assigned to 
 the left operand

 3.0.0 :001 > a=4
 => 4 
3.0.0 :002 > b=5
 => 5 
3.0.0 :003 > a+b
 => 9 
3.0.0 :004 > a+=b
 => 9 
3.0.0 :005 > a
 => 9 

4.Parallel Assignment
 This enables multiple values to be initialized  within single line

 eg  a,b,c =10,20,30
 3.0.0 :046 > a,b,c=10,20,30
 => [10, 20, 30] 
 
3.0.0 :006 > a,b,c = 10, 20, 30
 => [10, 20, 30] 
3.0.0 :007 > a
 => 10 
3.0.0 :008 > b
 => 20 
 => 30 
3.0.0 :011 > puts(a,b,c)
10
20
30
 => nil

5.Ruby Bitwise Operators
  Bitwise Operators works on Bits and Perform Bit by Bit Operation
  a    =  0011 1100
  b    =  0000 1101
  ------------------
  a&b  =  0000 1100   it is binary AND
  a|b  =  0011 1101   it is binary OR
  a^b  =  0011 0001   it is binary XOR
  ~a   =  1100 0011   it is complemantary operator

  << it is Left Shift Operator moved by the no of bits speacified
  >> It is Right Shift Operator moved by the no of bits speacified
eg, if a is 0011 1100
 a<<2 is 1111 0000
a>>2  is 0000 1111

6.Ruby Logical Operator

and  logical and Operator both conditions must be true 
or  logical or operator either conditions should be true 
&&  anothe way of writing AND but bothe side must be non zero
||  another way of writing OR but either side need to be non zero
!   Logical NOT Operator reverses the state of the operator
not  same as above


7.Ruby Ternary Operator
?:  Conditonal expression
If Condition is true ? Then value X : Otherwise value Y


8.Ruby Range Operator
It is used to create a range of successive values - 
consisting of a start value, an end value, and a 
range of values in between.

The two-dot form creates an inclusive range, 
while the three-dot form creates a range that 
excludes the specified high value.
so 1..10 is 1,2,3,4,5,6,7,8,9,10
and 1...10 is 1,2,3,4,5,6,7,8,9

9.Ruby defined? Operators
defined? is a special operator that takes the form of a method call to determine whether or not the passed expression is defined. 
It returns a description string of the expression, or nil if the expression isn't defined.
-defined? variable # True if variable is initialized.
-defined? method_call # True if a method is defined
-# True if a method exists that can be called with super user
defined? super
-defined? yield   # True if a code block has been passed
Ex- defined? yield    # => "yield" (if there is a block passed)
defined? yield    # => nil (if there is no block)

10.Ruby Dot "." and Double Colon "::" Operators
You call a module method by preceding its name with the module's name and a period, and you reference a constant using the module name and two colons.
The :: is a unary operator that allows: constants, instance methods and class methods defined within a class or module, to be accessed from anywhere outside the class or module.
Remember in Ruby, classes and methods may be considered constants too.
You need to just prefix the :: Const_name with an expression that returns the appropriate class or module object.
If no prefix expression is used, the main Object class is used by default.
Ex- MR_COUNT = 0         # constant defined on main Object class
module Foo
   MR_COUNT = 0
   ::MR_COUNT = 1    # set global count to 1
   MR_COUNT = 2      # set local count to 2
end
puts MR_COUNT        # this is the global constant
puts Foo::MR_COUNT   # this is the local "Foo" constant

# If-else,unless in Ruby:
# Ruby if...else Statement:
The if expressions execute a single statement or a group of statements if a certain condition is met. It can not do anything if the condition is false. For this purpose else is used.
Syntax
if conditional [then]
   code...
[elsif conditional [then]
   code...]...
[else
   code...]
end

3.0.0 :047 > x = 1
 => 1 
3.0.0 :048 > if x > 2
3.0.0 :049 >    puts "x is greater than 2"
3.0.0 :050 > elsif x <= 2 and x!=0
3.0.0 :051 >    puts "x is 1"
3.0.0 :052 > else
3.0.0 :053 >    puts "I can't guess the number"
3.0.0 :054 > end
x is 1
 => nil 
 
 3.0.0 :061 > x = 100
 => 100 
3.0.0 :062 > if x == 1
3.0.0 :063 >   puts "x is One."
3.0.0 :064 > elsif x == 100
3.0.0 :065 >   puts "x is Hundred."
3.0.0 :066 > else
3.0.0 :067 >   puts "x has different value."
3.0.0 :068 > end
x is Hundred.
 => nil 

# Ruby unless Statement
The unless expression is the opposite of the if expression. If the value is false the "then" expression is executed :
Syntax
unless conditional [then]
   code
[else
   code ]
end
Executes code if conditional is false. If the conditional is true, code specified in the else clause is executed.
3.0.0 :070 > unless x > 0
3.0.0 :071 >  puts "x is less than 0"
3.0.0 :072 > end
 => nil 
3.0.0 :073 > x = 1
 => 1 
3.0.0 :074 > unless x > 0
3.0.0 :075 >  puts "x is less than 0"
3.0.0 :076 > else   
3.0.0 :077 >  puts "x is greater than 0"
3.0.0 :078 > end
x is greater than 0
 => nil 

.0.0 :088 > if a>b
3.0.0 :089 > puts"a is greater than b"
3.0.0 :090 > elseif b>a
3.0.0 :091 > puts"b is greater than a"
3.0.0 :092 > else
3.0.0 :093 > puts"a is equal to b"
3.0.0 :094 > end
a is greater than b

#Ruby case Statement
Syntax
case expression
[when expression [, expression ...] [then]
   code ]...
[else
   code ]
end

case expr0
when expr1, expr2
   stmt1
when expr3, expr4
   stmt2
else
   stmt3
end

is basically similar to the following −
_tmp = expr0
if expr1 === _tmp || expr2 === _tmp
   stmt1
elsif expr3 === _tmp || expr4 === _tmp
   stmt2
else
   stmt3
end

Ex- 3.0.0 :108 > $age = 16
 => 16 
3.0.0 :109 > case $age
3.0.0 :110 > when 0 .. 2
3.0.0 :111 >    puts "baby"
3.0.0 :112 > when 3 .. 6
3.0.0 :113 >    puts "little child"
3.0.0 :114 > when 7 .. 12
3.0.0 :115 >    puts "child"
3.0.0 :116 > when 13 .. 18
3.0.0 :117 >    puts "youth"
3.0.0 :118 > else
3.0.0 :119 >    puts "adult"
3.0.0 :120 > end
youth
 => nil 
 
  Loops in Ruby:
Loops in Ruby are used to execute the same block of code a specified number of times.
1.Ruby while Statement
Syntax
while conditional [do]
   code
end

Ex-3.0.0 :121 > $i = 0
 => 0 
3.0.0 :122 > $num = 5
 => 5 
3.0.0 :123 > while $i<$num do
3.0.0 :124 >   puts("Inside the loop i=#$i")
3.0.0 :125 >   $i +=1
3.0.0 :126 > end
Inside the loop i=0
Inside the loop i=1
Inside the loop i=2
Inside the loop i=3
Inside the loop i=4
 => nil 

-Ruby while modifier
Syntax
code while condition

OR

begin 
  code 
end while conditional

Ex- 3.0.0 :127 > $i = 0
 => 0 
3.0.0 :128 > $num = 5
 => 5 
3.0.0 :129 > begin
3.0.0 :130 >    puts("Inside the loop i = #$i" )
3.0.0 :131 >    $i +=1
3.0.0 :132 > end while $i < $num
Inside the loop i = 0
Inside the loop i = 1
Inside the loop i = 2
Inside the loop i = 3
Inside the loop i = 4
 => nil 

# Ruby until Statement
until conditional [do]
   code
end

Ex- 3.0.0 :133 > $i = 0
 => 0 
3.0.0 :134 > $num = 5
 => 5 
3.0.0 :135 > 
3.0.0 :136 > until $i > $num  do
3.0.0 :137 >    puts("Inside the loop i = #$i" )
3.0.0 :138 >    $i +=1;
3.0.0 :139 > end
Inside the loop i = 0
Inside the loop i = 1
Inside the loop i = 2
Inside the loop i = 3
Inside the loop i = 4
Inside the loop i = 5
 => nil 
 
3.Ruby for Statement
Syntax
for variable [, variable ...] in expression [do]
   code
end

Ex- 3.0.0 :001 > for i in 0..5
3.0.0 :002 >    puts "Value of local variable is #{i}"
3.0.0 :003 > end
Value of local variable is 0
Value of local variable is 1
Value of local variable is 2
Value of local variable is 3
Value of local variable is 4
Value of local variable is 5
 => 0..5 

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ irb
3.0.0 :001 > for i in 1...10
3.0.0 :002 >     puts"Hello Ruby"
3.0.0 :003 > end
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
 => 1...10 
## Here ... means loop will print value one less than given condition i.e here value is printed 9 times.

3.0.0 :004 > for i in 1..10
3.0.0 :005 >     puts"Hello Ruby"
3.0.0 :006 > end
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
Hello Ruby
 => 1..10 
 ## Here .. means loop will print value equal to the given condition i.e here value is printed 10 times.
 
# Another method of writing For loop using each do:
A for...in loop is almost exactly equivalent to the following −
(expression).each do |variable[, variable...]| code end

3.0.0 :005 > (0..8).each do |i|
3.0.0 :006 >    puts "Value of local variable is #{i}"
3.0.0 :007 > end
Value of local variable is 0
Value of local variable is 1
Value of local variable is 2
Value of local variable is 3
Value of local variable is 4
Value of local variable is 5
Value of local variable is 6
Value of local variable is 7
Value of local variable is 8

4.Ruby break Statement
Syntax
break
Terminates the most internal loop. Terminates a method with an associated block if called within the block (with the method returning nil).

ex- 3.0.0 :008 > for i in 0..5
3.0.0 :009 >    if i > 2 then
3.0.0 :010 >       break
3.0.0 :011 >    end
3.0.0 :012 >    puts "Value of local variable is #{i}"
3.0.0 :013 > end
Value of local variable is 0
Value of local variable is 1
Value of local variable is 2
 => nil 

# Ruby next Statement
Syntax
next
Jumps to the next iteration of the most internal loop. Terminates execution of a block if called within a block (with yield or call returning nil).
Ex-3.0.0 :014 > for i in 0..4
3.0.0 :015 >    if i < 2 then
3.0.0 :016 >       next
3.0.0 :017 >    end
3.0.0 :018 >    puts "Value of local variable is #{i}"
3.0.0 :019 > end
Value of local variable is 2
Value of local variable is 3
Value of local variable is 4
 => 0..4 

#Ruby redo Statement
Syntax
redo
Restarts this iteration of the most internal loop, without checking loop condition. Restarts yield or call if called within a block.
Ex- for i in 0..5
   if i < 2 then
      puts "Value of local variable is #{i}"
      redo
   end
end
This will produce the following result and will go in an infinite loop −
Value of local variable is 0
Value of local variable is 0
............................

# Ruby retry Statement
Syntax
retry
If retry appears in rescue clause of begin expression, restart from the beginning of the begin body.
begin
   do_something # exception raised
rescue
   # handles error
   retry  # restart from beginning
end
Ex-If retry appears in the iterator, the block, or the body of the for expression, restarts the invocation of the iterator call. Arguments to the iterator is re-evaluated.

for i in 1..5
   retry if some_condition # restart from i == 1
end
Ex- for i in 0..5
   retry if i > 2
puts "Value of local variable is #{i}"
end
This will produce the following result and will go in an infinite loop −

Value of local variable is 1
Value of local variable is 2
Value of local variable is 1
Value of local variable is 2
Value of local variable is 1
Value of local variable is 2
............................

# Ruby - Methods:
-A method in ruby always starts with the "def" keyword.
-Method name always starts with a lower case character,just like we define local variables in ruby.
-Method always end with the 'end' keyword.
-Methods should be defined before calling them, otherwise Ruby will raise an exception for undefined method invoking.
-The return statement in ruby is used to return one or more values from a Ruby Method.
- Last line of method is already considered as return statement so no need to use "return" keyword.
Syntax:
def method_name 
   expr..
end

Ex- 3.0.0 :007 > def example_method
3.0.0 :008 >   puts"Hello World"
3.0.0 :009 > end
 => :example_method 
3.0.0 :010 > example_method
Hello World
 => nil 
 
 # Methods with arguments:
 3.0.0 :011 > def area(length,width)
3.0.0 :012 >   length*width
3.0.0 :013 > end
 => :area 
3.0.0 :014 > area(3,2)
 => 6 
 
 # Methods with no arguments:
 3.0.0 :015 > def rectangle_area
3.0.0 :016 >   length = 10
3.0.0 :017 >   width = 5
3.0.0 :018 >   length * width
3.0.0 :019 > end
 => :rectangle_area 
3.0.0 :020 > rectangle_area
 => 50 
 
 # Method with default arguments:
 - Arguments can be anything like string,arrays,boolean etc.
 3.0.0 :021 > def area(length=10, width=20)
3.0.0 :022 >   length*width
3.0.0 :023 > end
 => :area 
3.0.0 :024 > area
 => 200 
 
 3.0.0 :025 > def test(a1 = "Ruby", a2 = "Perl")
3.0.0 :026 >    puts "The programming language is #{a1}"
3.0.0 :027 >    puts "The programming language is #{a2}"
3.0.0 :028 > end
 => :test 
3.0.0 :029 > test "C", "C++"
The programming language is C
The programming language is C++
 => nil 
3.0.0 :030 > test
The programming language is Ruby
The programming language is Perl
 => nil 

# Ruby Return statement:
.0.0 :031 > def test
3.0.0 :032 >   i = 100
3.0.0 :033 >   j = 200
3.0.0 :034 >   k = 300
3.0.0 :035 >   return i,j,k
3.0.0 :036 > end
 => :test 
3.0.0 :037 > var = test
 => [100, 200, 300] 
3.0.0 :038 > puts var
100
200
300
 => nil 

# Class Methods:
3.0.0 :039 > class Accounts
3.0.0 :040 >    def reading_charge
3.0.0 :041 >    end
3.0.0 :042 >    def Accounts.return_date
3.0.0 :043 >    end
3.0.0 :044 > end
 => :return_date 
See how the method return_date is declared. It is declared with the class name followed by a period, which is followed by the name of the method.
To access this method, you need not create objects of the class Accounts.

# Ruby alias Statement
This gives alias to methods or global variables. Aliases cannot be defined within the method body. The alias of the method keeps the current definition of the method, even when methods are overridden.
Syntax-
alias method-name method-name
alias global-variable-name global-variable-name
Example-
alias foo bar
alias $MATCH $&
Here we have defined foo alias for bar, and $MATCH is an alias for $&

# Ruby undef Statement
This cancels the method definition. An undef cannot appear in the method body.
By using undef and alias, the interface of the class can be modified independently from the superclass, but notice it may be broke programs by the internal method call to self.
Syntax-
undef method-name

# Ruby - Blocks
Ruby defines methods where you can put number of statements and then you call that method. Similarly, Ruby has a concept of Block.
-A block consists of chunks of code.
-You assign a name to a block.
-The code in the block is always enclosed within braces ({}).
-A block is always invoked from a function with the same name as that of the block. This means that if you have a block with the name test, then you use the function test to invoke this block.
-You invoke a block by using the yield statement.
Syntax-
block_name {
   statement1
   statement2
   ..........
}

# The yield Statement:
Ex- 3.0.0 :051 > def test
3.0.0 :052 >   puts "You are in the method"
3.0.0 :053 >   yield
3.0.0 :054 >   puts "you are again back to the method"
3.0.0 :055 >   yield
3.0.0 :056 > end
 => :test 
3.0.0 :057 > test{puts "You are in the block"}
You are in the method
You are in the block
you are again back to the method
You are in the block
 => nil 

Ex-3.0.0 :058 > def test
3.0.0 :059 >   yield 5
3.0.0 :060 >   puts "You are in the method test"
3.0.0 :061 >   yield 50
3.0.0 :062 > end
 => :test 
3.0.0 :063 > test{|i| puts "You are in the block #{i}"}
You are in the block 5
You are in the method test
You are in the block 50
 => nil 
Here, the yield statement is written followed by parameters. You can even pass more than one parameter. In the block, you place a variable between two vertical lines (||) to accept the parameters. Therefore, in the preceding code, the yield 5 statement passes the value 5 as a parameter to the test block.

-If you want to pass more than one parameters, then the yield statement becomes −
yield a, b
and the block is −
test {|a, b| statement}

# Blocks and Methods:
You normally invoke a block by using the yield statement from a method that has the same name as that of the block.

Ex- 3.0.0 :069 > def test
3.0.0 :070 >   yield
3.0.0 :071 > end
 => :test 
3.0.0 :072 > test{puts"hello world"}
hello world
 => nil 
 
-But if the last argument of a method is preceded by &, then you can pass a block to this method and this block will be assigned to the last parameter. In case both * and & are present in the argument list, & should come later.
3.0.0 :001 > def test(&block)
3.0.0 :002 >   block.call
3.0.0 :003 > end
 => :test 
3.0.0 :004 > test {puts "Hello"}
Hello
 => nil 

# Begin and End blocks:
BEGIN { 
   # BEGIN block code 
   puts "BEGIN code block"
} 

END { 
   # END block code 
   puts "END code block"
}
   # MAIN block code 
puts "MAIN code block"

itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby Ruby.rb
BEGIN code block
MAIN code block
END code block

# Ruby - Modules:
Modules are a way of grouping together methods, classes, and constants. Modules give you two major benefits.
Modules provide a namespace and prevent name clashes.
Modules implement the mixin facility.
Modules define a namespace, a sandbox in which your methods and constants can play without having to worry about being stepped on by other methods and constant.

Syntax
module Identifier
   statement1
   statement2
   ...........
end
Like class methods, whenever you define a method in a module, you specify the module name followed by a dot and then the method name.

3.0.0 :001 > module Trig
3.0.0 :002 >   PI = 3.14159
3.0.0 :003 >   def Trig.sin(x)
3.0.0 :004 >   end
3.0.0 :005 >   def Trig.cos(x)
3.0.0 :006 >   end
3.0.0 :007 > end
 => :cos 

3.0.0 :009 > module Moral
3.0.0 :010 >    VERY_BAD = 0
3.0.0 :011 >    BAD = 1
3.0.0 :012 >    def Moral.sin(badness)
3.0.0 :013 >    # ...
3.0.0 :014 >    end
3.0.0 :015 > end
 => :sin 

# Ruby require Statement
The require statement is similar to the include statement of C and C++ and the import statement of Java. If a third program wants to use any defined module, it can simply load the module files using the Ruby require statement −
Syntax:
require filename

# Ruby include Statement
You can embed a module in a class. To embed a module in a class, you use the include statement in the class −
Syntax:
include modulename

If a module is defined in a separate file, then it is required to include that file using require statement before embedding module in a class.

module Week
   FIRST_DAY = "Sunday"
   def Week.weeks_in_month
      puts "You have four weeks in a month"
   end
   def Week.weeks_in_year
      puts "You have 52 weeks in a year"
   end
end
 
$LOAD_PATH << '.'
require "support"

class Decade
include Week
   no_of_yrs = 10
   def no_of_months
      puts Week::FIRST_DAY
      number = 10*12
      puts number
   end
end
d1 = Decade.new
puts Week::FIRST_DAY
Week.weeks_in_month
Week.weeks_in_year
d1.no_of_months
These above mention two codes are being put and called in the file.
 
In this we have save our required file in Ruby.rv file and then we have created a new file at same location with different name i.e New_file so that we can access required file from that New_file.
itsacheckmate@itsacheckmate:~/Training-Repository/Rvm and Ruby$ ruby New_file.rb
Sunday
You have four weeks in a month
You have 52 weeks in a year
Sunday
120


# Mixins in Ruby:
Ruby does not support multiple inheritance directly but Ruby Modules have a unique feature called mixins to support multiple inheritance.

module A
   def a1
   end
   def a2
   end
end
module B
   def b1
   end
   def b2
   end
end

class Sample
include A
include B
   def s1
   end
end

samp = Sample.new
samp.a1
samp.a2
samp.b1
samp.b2
samp.s1

Module A consists of the methods a1 and a2. Module B consists of the methods b1 and b2. The class Sample includes both modules A and B. The class Sample can access all four methods, namely, a1, a2, b1, and b2. Therefore, you can see that the class Sample inherits from both the modules. Thus, you can say the class Sample shows multiple inheritance or a mixin.

Example:
3.0.0 :005 > module Child1
3.0.0 :006 >   def a1
3.0.0 :007 >     puts"This is a child one."
3.0.0 :008 >   end
3.0.0 :009 > end
 => :a1 
3.0.0 :010 > module Child2
3.0.0 :011 >   def a2
3.0.0 :012 >     puts"This is a child two"
3.0.0 :013 >   end
3.0.0 :014 > end
 => :a2 
3.0.0 :015 > module Child3
3.0.0 :016 >   def a3
3.0.0 :017 >     puts"This is a child three"
3.0.0 :018 >   end
3.0.0 :019 > end
 => :a3 
3.0.0 :020 > class Parent
3.0.0 :021 > include Child1
3.0.0 :022 > include Child2
3.0.0 :023 > include Child3
3.0.0 :020 >  def display
3.0.0 :021 >    puts"Three modules have included"
3.0.0 :022 >  end
3.0.0 :023 > end
 => :display 
3.0.0 :024 > object = Parent.new
 => #<Parent:0x0000560459b0e038> 
3.0.0 :025 > object.display
Three modules have included
 => nil 
3.0.0 :026 > object.a1
This is a child one
 => nil 
3.0.0 :027 > object.a2
This is a child two
 => nil 
3.0.0 :028 > object.a3
This is a child three
 => nil 

# Defining CALCULATE modules which consists of some methods for arithmetic operations.
module CALCULATE
def add(a,b)
puts "The sum of two number is #{a+b}"
end
def multi(a,b)
puts "The multiplication of two number is #{a*b}"
end
def div(a,b)
puts "The division of two number is #{a/b}"
end
defsubstract(a,b)
puts "The subtraction of two number is #{a-b}"
end
end
# Defining a main class method and inside the method we are simply including all the three modules which we have defined above.
class USECALCULATION
include CALCULATE
defdisplay_output
puts 'This is inside the USECALCULATION and method CALCULATE'
end
end
# Creating object
mainObject = USECALCULATION.new
# Calling methods
mainObject.display_output
mainObject.add(1,3)
mainObject.multi(2,4)
mainObject.div(2,4)
mainObject.substract(2,4)

3.0.0 :059 >   def add(a,b)
3.0.0 :061 >   end
3.0.0 :062 >   def mul(a,b)
3.0.0 :064 >   end
3.0.0 :065 >   def div(a,b)
3.0.0 :067 >   end
3.0.0 :068 >   def sub(a,b)
3.0.0 :070 >   end
3.0.0 :071 > end
3.0.0 :072 > class UseCalculation
3.0.0 :073 >   include Calculate
3.0.0 :075 >     puts"This is inside the UseCalculation and method Calculate"
3.0.0 :076 >   end
3.0.0 :077 > end
 => :display_output 
3.0.0 :078 > mainObject = UseCalculation.new
 => #<UseCalculation:0x000056045a10a9a0> 
3.0.0 :079 > mainObject.display_output
This is inside the UseCalculation and method Calculate
 => nil 
3.0.0 :080 > mainObject.add(1,3)
The sum of two number is 4
 => nil 
3.0.0 :081 > mainObject.mul(1,3)
The product of two number is 3
 => nil 
3.0.0 :082 > mainObject.div(2,4)
The division of two number is 0
 => nil 
3.0.0 :083 > mainObject.div(4,2)
The division of two number is 2
 => nil 
3.0.0 :084 > mainObject.sub(4,2)
The subtraction of two number is 2
 => nil 
------------------------------------------------------------------------------------------------------------------------------------

# Strings:
In Ruby, string is a sequence of one or more characters. It may consist of numbers, letters, or symbols. Here strings are the objects, and apart from other languages, strings are mutable, i.e. strings can be changed in place instead of creating new strings.
Creating Strings: To create the string, just put the sequence of characters either in double quotes or single quotes. Also, the user can store the string into some variable. In Ruby, there is no need to specify the data type of the variable.

3.0.0 :001 > puts'Ruby string using single quotes'
Ruby string using single quotes
 => nil 
3.0.0 :002 > puts"Ruby string using double quotes"
Ruby string using double quotes
 => nil 
3.0.0 :003 > str1 = 'Hello'
 => "Hello" 
3.0.0 :004 > str2 = "Hello! How are you?"
 => "Hello! How are you?" 

Strings are objects: As you know that Ruby is an object-oriented language so string in Ruby are objects.
3.0.0 :005 > str = "GeeksforGeeks"
 => "GeeksforGeeks" 
3.0.0 :006 > puts str
GeeksforGeeks
 => nil 
3.0.0 :007 > str2 = String.new"GeeksForGeeks"
 => "GeeksForGeeks" 
3.0.0 :008 > puts str2
GeeksForGeeks
 => nil 
 
Access String Elements: User can access the string elements by using the square brackets []. In square brackets [], the user can pass the strings, ranges or indexes.
Syntax:
name_of_string_variable[arguments]

# storing string in variable
3.0.0 :009 > str = "Hello Learning Ruby"
 => "Hello Learning Ruby" 
# accessing the specified substring
3.0.0 :010 > puts str["Hello"]
Hello
 => nil 
3.0.0 :011 > puts str['Ruby']
Ruby
 => nil 
# passing index as an argument which returns 
# the  specified character
3.0.0 :012 > puts str[3]
l
 => nil 
# passing the negative index as an argument which 
# returns the specified character from the
# last of the string 
3.0.0 :013 > puts str[-2]
b
 => nil 
 
3.0.0 :014 > puts str[14,10]
 Ruby
 => nil 
# passing Two arguments which are separated 
# by a comma that returns characters starting
# from the 1st index and the 2nd index is the
# number of characters
3.0.0 :015 > puts str[14..10]
 => nil 
# using range operators in passed arguments
3.0.0 :016 > puts str[10..12]
nin
 => nil 

#Creating Multiline Strings: 
There are three ways to create multiline strings in Ruby as follows:

1.Using Double Quotes(“”) It is the simplest way to create the multiline strings by just putting the string between the quotes. Between double quotes, the user can add the newline character and so on.
2.Using (%/ /) To create the multiline string just put the string between the %/ and /.
3.Using (<< STRING STRING) To create the multiline string just put the string between the << STRING and STRING. Here STRING should be in capital letters.

# Using Double Quotes
3.0.0 :017"> puts "In Ruby, a user can create the multiline
3.0.0 :018">       strings easily where in other programming 
3.0.0 :019">       languages creating multiline strings 
3.0.0 :020">       requires a lot of efforts"
In Ruby, a user can create the multiline
      strings easily where in other programming 
      languages creating multiline strings 
      requires a lot of efforts
 => nil 
 

# Using %/ /
3.0.0 :023"> puts %/ In Ruby, a user can create the multiline
3.0.0 :024">       strings easily where into other programming 
3.0.0 :025">       languages creating multiline strings 
3.0.0 :026">       requires a lot of efforts/
 In Ruby, a user can create the multiline
      strings easily where into other programming 
      languages creating multiline strings 
      requires a lot of efforts
 => nil 


# Using <<STRING STRING
3.0.0 :001"> puts <<STRING
3.0.0 :002">   
3.0.0 :003"> In Ruby, a user can create the multiline
3.0.0 :004"> strings easily where into other programming 
3.0.0 :005"> languages creating multiline strings 
3.0.0 :006"> requires a lot of efforts 
3.0.0 :007 > STRING
  
In Ruby, a user can create the multiline
strings easily where into other programming 
languages creating multiline strings 
requires a lot of efforts 
 => nil 


# String Replication:
To make the replication of string in Ruby, make the use of (*) operator. 
This operator is preceded by the string to be replicated and followed by the number of times to make replicas.
Syntax:
string_variable_or_string * number_of_times

3.0.0 :008'> str = 'Hello Ruby\n'
 => "Hello Ruby\\n" 
3.0.0 :009 > puts str*5
Hello Ruby\nHello Ruby\nHello Ruby\nHello Ruby\nHello Ruby\n
 => nil 
3.0.0 :010 > str = "Hello Ruby \n"
 => "Hello Ruby \n" 
3.0.0 :011 > puts str*6
Hello Ruby 
Hello Ruby 
Hello Ruby 
Hello Ruby 
Hello Ruby 
Hello Ruby 
 => nil 

# String concat Method:
-concat is a String class method in Ruby which is used to Concatenates two objects of String.
3.0.0 :012 > str = "Hello"
 => "Hello" 
3.0.0 :013 > str.concat("Welcome!")
 => "HelloWelcome!" 

3.0.0 :015 > str = "Hello!"
 => "Hello!" 
3.0.0 :016 > str.concat("Learn Ruby",20)
 => "Hello!Learn Ruby\u0014" 
3.0.0 :017 > str.concat("Learn Ruby",33)
 => "Hello!Learn Ruby\u0014Learn Ruby!"
 
# String length Method:
Syntax: str.length
Parameters: Here, str is the string whose length is to be calculated
Returns:It will return the charac3.0.0 :040 > puts "Sample".index('m')
2
 => nil 
3.0.0 :041 > puts "Program".index('gr')
3
 => nil 
3.0.0 :042 > puts "Checking".index('a')

 => nil 
ter length of the str.
3.0.0 :018 > puts"Welcome to Ruby".length
15
 => nil 

# String split() Method:
split is a String class method in Ruby which is used to split the given string into an array of substrings based on a pattern specified.
Syntax:
arr = str.split(pattern, limit) public
Parameters: arr is the list, str is the string, pattern is the either string or regExp, and limit is the maximum entries into the array.
Returns: Array of strings based on the parameters.

3.0.0 :019 > myArray = "Geeks for Geeks".split
 => ["Geeks", "for", "Geeks"] 
3.0.0 :020 > puts myArray
Geeks
for
Geeks
 => nil 
 
.0.0 :021 > myArray = "Geeks for Geeks".split('s',-1)
 => ["Geek", " for Geek", ""] 
3.0.0 :022 > puts myArray
Geek
 for Geek

 => nil 

# String Capitalize:
Capitalize first letter of a string.
3.0.0 :024 > "hello".capitalize
=> "Hello"

# String Capitalize!:
-Modifies string by converting the first character to uppercase and the reamainder to lowercase.
-Returns nil if no changes are made.
3.0.0 :025 > "hello".capitalize!
 => "Hello" 

# String Upcase:
-Converts string to uppercase.
3.0.0 :026 > "Learning Ruby".upcase
 => "LEARNING RUBY" 

# String Downcase:
-Converts string to lowercase.
3.0.0 :027 > "Learning Ruby".downcase
 => "learning ruby"

# Array slice() function:
Array#slice() : slice() is a Array class method which returns a subarray specified by range of indices.
Syntax: 
Array.slice()
Parameter: Array
Return: a subarray specified by range of indices.

3.0.0 :028 > a = [18,22,33,nil,5,6]
 => [18, 22, 33, nil, 5, 6] 
3.0.0 :029 > b = [1,4,1,1,88,9]
 => [1, 4, 1, 1, 88, 9] 
3.0.0 :030 > c = [18,22,50,6]
 => [18, 22, 50, 6] 
3.0.0 :031"> puts"slice() method form: #{a.slice(2,4)}\n\n"
slice() method form: [33, nil, 5, 6]
 => nil 
3.0.0 :032 > puts"slice() method form: #{b.slice(1,3)}\n\n"
slice() method form: [4, 1, 1]
 => nil 
3.0.0 :033 > puts"slice() method form: #{c.slice(2,3)}\n\n"
slice() method form: [50, 6]
 => nil 


3.0.0 :034 > a = ["abc","nil","dog"]
 => ["abc", "nil", "dog"] 
3.0.0 :035 > b = ["cat","nil"]
 => ["cat", "nil"] 
3.0.0 :036 > c = ["cow","nil","dog"]
 => ["cow", "nil", "dog"] 
3.0.0 :037 > puts"slice() method form: #{a.slice(1,3)}\n\n"
slice() method form: ["nil", "dog"]

 => nil 
3.0.0 :038 > puts"slice() method form: #{b.slice(1,2)}\n\n"
slice() method form: ["nil"]

 => nil 
3.0.0 :039 > puts"slice() method form: #{c.slice(0)}\n\n"
slice() method form: cow
 => nil 


# String index Method:
index is a String class method in Ruby which is used to returns the index of the first occurrence of the given substring or pattern (regexp) in the given string. It specifies the position in the string to begin the search if the second parameter is present. It will return nil if not found.
Syntax: str.index()
Parameters: Here, str is the given string.
Returns: Index of the first occurrence of the given substring or pattern (regexp) in str.

3.0.0 :040 > puts "Sample".index('m')
2
 => nil 
3.0.0 :041 > puts "Program".index('gr')
3
 => nil 
3.0.0 :042 > puts "Checking".index('a')

 => nil 


# Get the count of characters of a String:
The str.count takes one or more sets of characters as parameters.
3.0.0 :043 > puts "Looking".count('o')
2
 => nil 

# Reverse a String:
3.0.0 :044 > str = 'Mahima'
 => "Mahima" 
3.0.0 :045 > str.reverse
 => "amihaM" 
 
# Search for one or more characters of a String:
The str.include? returns true if the String or character present and false if it is not.
3.0.0 :046 > "heLLo wOrld".include?("w")
 => true 
3.0.0 :047 > "heLLo wOrld".include?("W")
 => false 

# Replace characters in a String
The str.gsub or global substitute replaces all occurrences with provided Strings. Here the first argument represents the characters set we want to substitute, and the second argument is the replacement characters set.
3.0.0 :048 > "Red, Red and Blue".gsub("Red", "Orange")
 => "Orange, Orange and Blue"
 
If you want to replace the first occurrence, use the str.sub.
3.0.0 :049 > "Red, Red and Blue".sub("Red", "Orange") 
 => "Orange, Red and Blue" 
 
# Split a String
3.0.0 :051 > words = sentence.split
 => ["There", "Is", "No", "Spoon"] 

You can limit the number of splits by providing the second argument.
3.0.0 :052 > sentence = "June 27,June 26,June 25"
 => "June 27,June 26,June 25" 
3.0.0 :053 > words = sentence.split(/,/, 2)
 => ["June 27", "June 26,June 25"] 


# Trim a String
The str.trim will remove any of the following leading and trailing characters: null("\x00"), horizontal tab("\t"), line feed(\n), vertical tab("\v"), form feed(f), carriage return(\r), space(" ").

--> Strip!:
Removes whitespaces from the reciever.Returns the altered reciever, or nil if there was no change.
3.0.0 :055 > "   hEllo   ".strip! 
 => "hEllo" 

# casecmp(other_str):
-1,0,1 or nil.

-1: if other_string is smaller.
0: if the two are equal.
1: if other_str is larger.
nil: if the two are incompatible.
 
3.0.0 :056 > 'foo'.casecmp('foo')
 => 0 
3.0.0 :057 > 'foo'.casecmp('food')
 => -1 
3.0.0 :058 > 'food'.casecmp('foo')
 => 1 
3.0.0 :059 > 'foo'.casecmp('FOO')
 => 0 
3.0.0 :060 > 'foo'.casecmp(1)
 => nil 

# casecmp?(other_str):
true,false or nil
Returns true if self and other_str are equal after Unicode case folding,otherwise false:

3.0.0 :061 > 'foo'.casecmp?('foo')
 => true 
3.0.0 :062 > 'foo'.casecmp?('food')
 => false 
3.0.0 :063 > 'food'.casecmp?('foo')
 => false 
3.0.0 :064 > 'foo'.casecmp?('FOO')
 => true 


# center(width,padstr='')-> new_str:
Centers str in width. If width is greater than the length of str,returns a new string of length width with str centered and padded with padstr;otherwise,returns str.
3.0.0 :065 > "hello".center(4)
 => "hello" 
3.0.0 :066 > "hello".center(14)
 => "    hello     " 
3.0.0 :067 > "hello".center(14,'40')
 => "4040hello40404"
 
# String chomp Method
chomp is a predefined method in Ruby's library which is used to eliminate implicit newline character '\n' attached with the string entered by the user during run time.
chomp is a String class method in Ruby which is used to returns new String with the given record separator removed from the end of str (if present). chomp method will also remove carriage return characters (that is it will remove \n, \r, and \r\n) if $/ has not been changed from the default Ruby record separator, t. If $/ is an empty string, it will remove all trailing newlines from the string.

Syntax: str.chomp
Parameters: Here, str is the given string.
Returns: A new string having no record separator from the end.

3.0.0 :068 > puts"Ruby\n".chomp
Ruby
 => nil 
3.0.0 :069"> puts"Ruby\n\r".chomp
Ruby
 => nil 
3.0.0 :070"> puts"Ruby\r\n".chomp
Ruby
 => nil 

3.0.0 :071 > puts"Ruby\r\n\r\n\n".chomp
Ruby

 => nil 
3.0.0 :072 > puts"Method".chomp("tho")
Method
 => nil 
 
# String chomp! Method:
Syntax: str.chomp!
Parameters: Here, str is the given string.
Returns: A new string having no record separator from the end or nil if no changes were made

3.0.0 :073 > puts"Ruby".chomp!

 => nil 
3.0.0 :074 > puts"Ruby\n".chomp!
Ruby
 => nil 
3.0.0 :075"> puts"Ruby\n\r".chomp!
Ruby
 => nil 
3.0.0 :076 > puts"String\r\n\r\n\n".chomp!
String

 => nil 
3.0.0 :077'> puts"String\r\n\r\n\n".chomp!('')
String
 => nil 
3.0.0 :078 > puts"Method".chomp!("tho")

 => nil 
 

# String chop Method:
chop is a String class method in Ruby which is used to return a new String with the last character removed. Both characters are removed if the string ends with \r\n, b. Applying chop to an empty string returns an empty string.
 

Syntax:str.chop
Parameters: Here, str is the given string.
Returns: A new string having no record separator. 

3.0.0 :079 > puts"Ruby".chop
Rub
 => nil 
3.0.0 :080 > puts"Ruby\r\n".chop
Ruby
 => nil 

3.0.0 :082 > puts"String\r\n\r\n\r\n".chop
String

 => nil 
3.0.0 :083 > puts"Method".chop.chop
Meth
 => nil 
